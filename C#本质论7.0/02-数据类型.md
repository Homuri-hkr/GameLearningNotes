- C#有几种类型非常简单，是其他所有类型的基础，它们称为预定义类型或基元类型，C#语言的基元类型包括八种整数类型，两种用于科学计算的二进制浮点类型、一种用于金融计算的十进制浮点类型、一种布尔类型以及一种字符

### 2.1 基本数值类型

#### 2.1.1 整数类型

- C#所有基元类型都有短名称和完整名称，完整名称对应BCL中的类型名称，该名称在所有语言中都相同，对程序集的类型进行了唯一性标识。由于基元类型是其他类型的基础，所以C#为基元类型的完整名称提供了短名称
- C#支持完整的BCL名称和关键字

#### 2.1.2 浮点类型

- 浮点数精度可变，除非用分数表示时，分母恰好是2的整次幂，否则用二进制浮点数类型无法准确表示该数

#### 2.1.3 decimal类型

- decimal是128位精度浮点类型，保证范围内的所有十进制数都是精确的，虽然其类型具有比浮点类型更高的进度，但其范围较小，所以从浮点数转换成decimal类型可能发成溢出错误，且decimal的计算速度稍慢
- decimal被表示成 +/-N*10^k，其中N是96位正整数，-28<=k<=0

#### 2.1.4 字面值

- 字面值表示源代码中的固定值

- 直接将值放在源代码中称为硬编码，因为以后如实更改了值就必须重新编译代码，所以在使用时必须慎重

- 默认情况下，输入带小数点的字面值，编译器自动解释称double类型，没有小数点通常默认为int，但无法用int存储则解释为long

- C#编译器允许向非int的数值类型赋值，前提是字面值对于目标数据类型来说合法，不同类型的非字面值类型不能赋值

- 字面值加后缀：

  - 无后缀的数值字面值按顺序解析成能存储该值的第一个数据类型：int、uint、long、ulong
  - 后缀U 的数值字面值按顺序解析成能存储该值的第一个数据类型：uint、ulong
  - 后缀L的数值字面值按顺序解析成能存储该值的第一个数据类型：long、ulong
  - 后缀Ul或LU解析成ulong
  - 后缀M解析成decimal，F解析成float，D解析成double

  后缀是不区分大小写的，但最好使用大写将1和l分开

- 可在书写数值字面值的时候使用下划线分割（_）方便观察（C#7.0），可在数字第一位和最后一位之间的任何位置添加分隔符，也可连写多个下划线

- 指数记数法使用e/E中缀，在中缀字母后面添加正整数或负整数，并在字面值最后添加恰当的数据类型后缀

- 使用0x/0X前缀可以指定十六进制值

- 使用0b/0B前缀可以指定二进制值（C#7.0）

- 可以将数字分隔符放在代表十六进制的x或者代表二进制的b后面（称为前导数字分隔符，C#7.2）

- 要显示数值的十六进制形式，必须使用x/X数值格式说明符，大小写决定了十六进制字母的大小写，格式前紧跟冒号不能有空白

  ```c#
  System.Console.WriteLine($"{42:X}");	//显示2A
  System.Console.WriteLine("{0:X}", 42);	//同上
  ```

- 可以使用round-trip格式说明符r/R准确标识double值，不会丢弃数位，使用round-trip格式将字符串转换回数值肯定能获得原始值，若没使用则不一定（没有试验出来有什么不同，可能我C#版本高了）

### 2.2 更多基本类型

#### 2.2.1 布尔类型

- 虽然一个二进制为足以容纳一个布尔类型的值，但其实际大小是一个字节

#### 2.2.2 字符类型

- char表示16位字符，取值范围对应Unicode字符集，输入char字面值需要将字符放到一对单引号
- 不是所有Unicode字符都能用一个16位char表示，一些Unicode字符要由一对称为“代理项”的char构成，总共32位

#### 2.2.3 字符串

- 零或多个字符的有限序列称为字符串，C#的基本字符串类型是string，是一种不可变类型

- C#允许在字符串前使用@符号指明转移序列不被处理，结果是一个逐字字符串字面值，不仅在反斜杠当作普通字符，还会逐字解释所有空白字符，唯一支持的转义序列是""，代表一个双引号不会终止字符串

- 若同一字符串字面值在程序集中多次出现，编译器在程序集中只定义字符串一次，所有变量都指向它

- 逐字（@）和插值（\$）可以组合使用，但需要先指定\$再指定@

- 字符串插值是调用string.Format()方法的语法糖，再调用时实际上还是会转换成Format方法

- Format()方法具有和Console.Write()和Console.WriteLine()方法相似的行为，其不是向控制台输出结果而是返回结果

- 调用静态方法需要附加命名空间和类型名前缀，可利用using static指令避免这些前缀（C#6.0），该指令需添加到文件顶部namespace的声明之前

- using指令可用于省略命名空间前缀，其作用于所在的整个文件或命名空间，而非仅作用于静态成员，使用using指令，不管在实例化时，在调用静态方法时，还是在使用nameof操作符时（C#6.0），都可省略对命名空间的引用3330

- 要在插值或格式化字符串中添加实际的左右大括号，可连写两个大括号表示

  ```c#
  string name = "zy";
  System.Console.WriteLine($"{{ {name} }}");
  ```

- 输出换行所需的字符由操作系统决定，为消除平台间的不一致，可以使用System.WriteLine()自动输出空行，或使用System.Environment.NewLine换行

- 判断字符串长度可以使用string的Length成员，其为只读属性（字符串不可变性）

- 可为string变量赋一个全新的值，但出于性能考虑，没有提供修改现有字符串的机制，所以所有更改字符串的方法都只是返回一个新字符串不会修改现有字符串

- 若有大量字符串需要修改，可考虑使用System.Text.StringBuilder类型，该类型的方法会修改本身的值而不是返回新字符串

### 2.3 null和void

- null值表明变量不引用任何有效的对象，void表示无类型、没有任何值

#### 2.3.1 null

- 只能将null赋给引用类型、指针类型和可控制类型，赋值了null的变量已设置，而未赋值的变量未设置，使用未赋值的变量会造成编译时错误

#### 2.3.2 void

- void本质上不是数据类型，只是指出没有数据类型这一事实
- 无论C++还是C#，void都有两个含义：标记方法不返回任何数据，以及代表指向未知类型的存储位置的一个指针

### 2.4 数据类型转换

- 会造成转换的最常见操作就是转型或是强制类型转换
- 有可能造成数据丢失或引发异常的任何转换都需要执行显式转型，相反不会丢失数据且不会引发异常的任何转换都可以隐式转型

#### 2.4.1 显式转型

- C#允许用转型操作符执行转型，通过在圆括号中指定希望变量转换成的类型，表明已确认发现显式转型时可能丢失精度和数据或者可能造成异常，但异常发生还是会引发异常

- C#提供了特殊关键字checked来表示代码块，指出若目标数据类型太小以至于容不下所赋的数据会发生什么情况，默认情况下容不下的数据在赋值时会悄悄溢出，checked块的代码在运行时发生赋值溢出将引发异常

  C#编译器提供了一个命令行选项将默认行为从unchecked改为checked

- C#支持unchecked快来强制不进行溢出检查，块中出的赋值不会引发异常，即使开启了编译器的checked选项，unchecked关键字也会阻止VES引发异常

- 转型操作符不能将一种类型任意转换成其他类型，编译器仍会检查类型操作的有效性

- C#不存在从数值类型到布尔类型的有效转型，这样是为了避免可能发生的歧义，还避免用户在本应使用相等操作符的时候使用赋值操作符

#### 2.4.3 不使用转型操作符的类型转换

- 未定义从字符串到数值类型的转换，所以每个数值数据类型都包含一个Parse()方法允许将字符串转换成对应的数值类型
- 还可能使用特殊类型System.Convert.To***()将一种类型转换成另一种，但其支持少量类型，且不可扩展，允许从bool、char、sbyte、short、int、long、ushort、uint、ulong、float、double、decimal、DateTime、string之间的互相转换
- 所有类型都支持ToString()方法，可用其提供类型的字符串表示，大多数类型的ToString()方法只是返回数据类型的名称，而不是数据的字符串表示，只有在类型显示实现了ToString()的前提下才会返回字符串表示
- 所有基元数值类型都包含静态TryParse()方法（C#2.0），这些方法与Parse()非常相似，其转换失败不是引发异常而是返回false

