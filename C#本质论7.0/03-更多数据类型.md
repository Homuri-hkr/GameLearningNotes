### 3.1 类型的划分

- 一个类型要么是值类型要么是引用类型，区别在于拷贝方式：值类型的数据总是拷贝值，而引用类型的数据总是拷贝引用

#### 3.1.1 值类型

- 值类型直接包含值，变量引用的位置就是内存中实际存储值的位置，将值类型的实例传给非引用参数的方法时也会生成内存拷贝，在方法内部对参数值进行的任何修改都不会影响调用函数中的原始值
- 由于值类型需要创建内存拷贝，因此定义时不要让它们占用了太多内存（通常应小于16字节）

#### 3.1.2 引用类型

- 引用类型的变量存储对数据存储位置的引用，而不是直接存储数据，为引用类型的变量分配实际数据的内存区域称为堆，将引用类型的变量赋给另一个引用类型的变量，只会拷贝引用而不需要拷贝所引用的数据，每个引用总是系统的“原生大小”，32位系统拷贝32位引用，64位系统拷贝64位引用

### 3.2 可空修饰符

- 一般不能将null值赋给值类型，根据定义，值类型不能包含引用，即使是“什么也没有”的一弄

- 为声明能存储null的值类型变量，要使用可空修饰符（?）

- 将null赋给值类型在数据库编程中尤其有用

- 上下文关键字var声明隐式类型的局部变量（C#3.0），声明变量时，若能用确定类型的表达式初始化它，就允许变量的数据类型为隐式的而不用显示声明

- 要避免使用隐式类型的局部变量，除非所赋的值的数据类型显而易见

- C#的var由编译器严格确定类型，确定了就不能变，且类型检查和成员调用都会在编译时进行验证

- var关键字的真正目的是支持匿类型，其是在方法内部动态声明的数据类型而不是通过显式类定义来声明，但从添加元组功能（C#7.0）后匿名类型就很少使用

  ```c#
  var person = new {Name = "zy"};
  ```

### 3.3 元组

- 元组允许在一个语句中完成所有变量的赋值（C#7.0）

  ```c#
  //将元组赋给单独声明的变量
  (string country, string capital, double gdpPerCapita) = ("Malawi", "Lilongwe", 226.50);
  //将元组赋给预声明的变量
  string country;
  string capital;
  double gdpPerCapita;
  (country, capital, gdpPerCapita) = ("Malawi", "Lilongwe", 226.50);
  //将元组赋给单独声明隐式类型的变量
  (var country, var capital, var gdpPerCapita) = ("Malawi", "Lilongwe", 226.50);
  var (country, capital, gdpPerCapita) = ("Malawi", "Lilongwe", 226.50);		//这里不能替换成具体类型
  //声明具名元组将元组值赋给它，且能使用其访问元组项
  (string country, string capital, double gdpPerCapita) countryInfo = ("Malawi", "Lilongwe", 226.50);
  var countryInfo = (country:"Malawi", capital:"Lilongwe", gdpPerCapita:226.50);
  //将元组项未具名的元组赋给隐式类型的变量，通过Item*访问元组项，索引从1开始即Item1，vs2019只有未具名的才可这么用（但书上隐式类型也可以这么用
  var countryInfo = ("Malawi", "Lilongwe", 226.50);
  //使用下划线丢弃元组的一部分,(vs2019不行)
  (string country, _, double gdpPerCapita) countryInfo = ("Malawi", "Lilongwe", 226.50);
  //通过变量和属性名推断元组项(C#7.1)
  string country = "Malawi";
  string capital = "Lilongwe";
  double gdpPerCapita = 226.50;
  var countryInfo = (country, capital, gdpPerCapita);
  ```

- 元组的宗旨是允许每一项都有不同数据类型，所以为每项都指定同一个显式类型名称和这个宗旨冲突，所以不能在括号前使用除var以外的其他具名类型

- 元组的赋值左侧和右侧都可以指定元组名，且可以不同，但以左侧的名字为基准

- 元组项的数据类型可以不一样，没有限制，但它们由编译器决定不能在运行时改变，且元组项的数量也是在编译时硬编码好的，不能为元组添加自定义行为（扩展方法除外）

- 自定义元组项名称及其类型没有包含在System.ValueTyple<...>定义中

- 编译器和IDE依赖元组剩下的作用域通过项的名称来访问值，即编译器查找元组声明中的项名称，并允许代码访问还在作用域中的项，因为这一点，IDE的“智能感知”不显示底层的ItemX成员，其会被忽略替换成显式命令的项

- 对于API公有或私有一部分的所有元组编译器都会以“特性”的形式将元组项名称添加到成员元数据中

- 若显式使用System.ValueTuple<...>类型，C#不允许使用自定义的元组项名称

- System.ValueTuple<...>：

  - 共有8个泛型System.ValueTuple<...>，前7个最大支持7元组，第8个System.ValueTuple<...>类型从而支持n元组，其中System.ValueTuple<\T1\>存在但仅仅是为了补全，因为元组至少要求两个
  - 非泛型的System.ValueTuple类型作为元组工厂使用，提供了和所有ValueTuple元数对应的Create()方法，C#7.0之后基本用不到此方法，使用var创建元组更简单
  - 有了元组之后，实际编程时可以完全忽略泛型和非泛型的System.ValueTuple
  - 还有一个元组类型为Microsoft .NET Framework4.5引入的System,Tuple<...>，之后发现值类型更佳所以量身定制了System.ValueTuple<...>，在几乎所有情况下都替代了Tuple类型

### 3.4 数组

- 在声明时括号中加逗号就多一维，且在声明时不能指定具体数目

- 通过default关键字可以获取对应类型的默认值（C#2.0）

  ```c#
  int count = default(int);
  ```

#### 3.4.1 数组的声明

- 在C#中，作为数组声明一部分的方括号紧跟在数据类型之后而不是在变量声明之后

#### 3.4.2 数组实例化和赋值

- 只用在同一个语句中声明并赋值才能使用大括号括起来的方式直接初始化，声明后只能使用关键字new进行初始化
- 不必再new后面指定数据类型，编译器能根据初始化列表中的数据类型推断数组类型，但方括号仍不可缺少（C#3.0）
- C#支持将new关键字作为声明语句的一部分，其作用是指示“运行时”为数据类型分配内存，即指示它实例化数据类型
- 数组赋值时只要使用了new关键字就可在方括号内指定数组大小，其必须和大括号中的元素数量匹配
- 可以只给定数组大小分配数组而不提供具体值，此时“运行时”将将每个元素初始化为其类型默认值，非基元类型会以递归方式初始化，每个字段都被初始化为默认值
- 数组大小不需要作为白能量声明的部分，所以可以在运行时指定数组大小
- 初始化多维数组时，每维的所含元素要相同。若要使用大小不一致的就需要交错数组，即数组的数组，声明方式为两个连续的方括号，其要求为内部的每个数组都创建数组实例

#### 3.4.3 数组的使用

- 访问时，多维数组仍是使用逗号分开索引，交错数组是在不同方括号中使用索引
- 数组长度固定，除非重新创建数组，否则不能随便更改大小
- 越过数据边界和使用无效索引来访问数组造成“运行时”错误
- CLR能防止所有C#和托管C++代码越界，消除了托管代码中发生缓冲区溢出的可能
- 一个好的实践是用Length取代硬编码的数组大小，对于交错数组，Length返回外部数组的元素数，当其指定中间第几个数组才会返回内部的元素数
- System.Array.Clear()方法不删除元素也不会设置长度为0，因为数组大小固定，所以其将每个元素设置为类型默认值
- System.Array.Resize()方法重新创建数组，并将所有元素拷贝到新数组（.NET2.0）
- 获取特定维的方法使用GetLength()实例成员，参数为需要返回的维度数
- Rank成员获取整个数组的维数
- 将一个数组变量赋给另一个默认只拷贝数组引用，要创建数组的全新拷贝需使用数组的Clone()方法，其返回数组拷贝

#### 3.4.4 字符串作为数组使用

- 可使用字符串的ToCharArray()方法将整个字符串作为字符数组返回

