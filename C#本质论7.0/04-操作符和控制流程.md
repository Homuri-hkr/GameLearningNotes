### 4.1 操作符

#### 4.1.1 一元正负操作符（+，-）

- 使用一元负操作符等价于从零减去操作数，一元正操作符对值几乎没有印象，但对于较小整数类型仍会转换成int等类型（C++的整数类型提升），其在C#语言中是多余的，只是出于对称性的考虑才加进来

#### 4.1.2 二元算术操作符（+，-，*，/，%）

- 除赋值之外的操作符的结果必须以某种方式使用，在C#中只有赋值、调用、递增、递减、await和对象创建表达式才能作为独立语句使用
- 在C#中，操作数总是从左向右求值（和结合律无关），而在C++里面没有明确的规定
- 要避免在需要准确的十进制小数算术运算时使用二进制浮点类型，应使用decimal浮点类型，比如判断是否相等
- 在C#中浮点0除以0会得到NaN，获取负数的平方根也是NaN
- 浮点数可能溢出边界，当正向溢出则为Infinity，负向溢出则-Infinity
- 浮点数能包含非常接近零但不是零的值，若只超过float或double类型的阈值，则值可能表示成-0或0

#### 4.1.4 递增和递减操作符（++，--）

- C#保证总是先将已递增的值赋给变量再使用表达式的值，加上从左到右使用对表达式求值，可以保证在方法调用中表达式的值没有歧义
- 虽然递增和递减操作符简化了代码，但两者执行的都不是原子级别的运算，在操作符执行期间，可能发生线程上下文切换，造成竞争条件，可用lock语句防止出现竞争条件。对于简单递增和递减运算，可以使用代价较低的替代方案，使用Sstem.Threading.Interlocked类提供的线程安全方法Increment()和Decrement()，这两方法依赖处理器功能来执行快速和线程安全的递增递减

#### 4.1.5 常量表达式和常量符号

- 常量表达式是C#编译器在编译时求值的表达式，因为其完全由常量操作数构成
- 常量表达式初始化常量符号，从而为常量值分配名称
- const关键字用于声明常量，对于常量在代码中任何企图修改的操作都会造成编译时错误

### 4.4 代码块、作用域和声明空间

- 声明空间覆盖所有的子代码块，C#编译器禁止一个代码块或参数声明中声明的局部变量在其子代码块中重复声明
- C#对于声明局部变量的那个块，局部变量都在作用域中，但声明前引用它属于非法，所以不会出现同一个块中包括其中的子块出现同一个变量名

### 4.5 布尔表达式

#### 4.5.2 逻辑操作符

- 逻辑操作符包括|、||、&、&&和^，对应OR、AND、XOR，其中OR和AND的|、&版本很少使用
- OR和AND操作符支持短路计算
- XOR操作符不会吃短路运算，始终要检查两个操作数，除非确切知道两个操作数的值，否则不能判定最终结果

#### 4.5.4 条件操作符（?:）

- 条件操作符支持一定程度的短路求值

- C#语言要求条件操作符：两边表达式结果类型一致，且在判定类型时不会检查表达式的上下文，即不会受最终需要的结果影响

#### 4.5.5 空合并操作符（??）

- ??操作符能简单的表示若该值为空就是用另一个值，操作数即可以是值类型，也可以是引用类型（C#2.0）
- ??操作符支持短路求值，对于exception1 ?? exception2来说，当exception1为空就返回exception2的值，否则返回exception1
- 空合并操作符能完美“链接”，可以和多个链接多个表达式，x??y??z，其从左向右选出第一个非空表达式，都为空则返回最后一个

#### 4.5.6 空条件操作符（?.）

- 空条件操作符（C#6.0）在调用方法前判断对象是否为空

- 最方便之处在于可“链接”，表达式之后的所有方法都必须在对象非空才能调用，例object?.func1().func()2仅在object非空才会调用之后两个方法

- 要使用该功能，最好在所有返回值类型的成员时总是返回可控版本

- 若要在判断语句中使用空条件操作符调用方法，需要联合使用空合并操作符保证返回一个bool值

  ```c#
  if(str?.ToLower().StartsWith("file")??false){
      
  }
  ```

- 空条件符还可和索引操作符组合使用

  ```c#
  string s = str?[0];
  ```

  这种用法空操作符展现了虚假的安全性，它暗示str非空则元素必然存在，但str非空该元素也不一定存在

### 4.6 按位操作符（<<，>>，|，&，^，~）

#### 4.6.2 按位操作符（&，|，^）

- 内键的CLR方法System.Conver.ToString();参数一指定需要转换的数值，参数二int类型指定进制，就可以将参数一转换成对应进制的字符串

### 4.7 控制流程语句（续）

#### 4.7.4 基本switch语句

- switch语句应该至少有一个switch小节，switch(){}合法但会产生一个警告
- 虽然一般情况下应避免省略大括号，但应省略case和break语句的大括号，这两个关键字本身就指示了块的开始和结束
- switch中各个小节小节可为任意顺序，default小节不一定要出现在switch语句最后，甚至可以省略
- C#要求每个switch小节包括最后一个小节的结束点不可到达，即要以break、return或goto结尾
- 模式匹配（C#7.0）可使switch表达式可使用任何类型的数据
- switch语句支持条件表达式，不仅可以用类型来标识应执行的case标签，还可以在case标签末尾使用boolean表达式标识该标签的执行条件

### 4.8 跳转语句

#### 4.8.3 goto语句

- C#goto只能用于在switch语句中实现贯穿，通过goto default跳到默认块，goto case xxx跳到对应case块
- C#禁止通过goto跳入代码块，只能用goto在代码块内部跳转或跳到另一个包围当前块的代码块

### 4.9 C#预处理器指令

- C#预处理器在编译时调用，预处理器指令告诉C#编译器要编译哪些代码，并指出如何处理代码中特定错误和警告，还可以告诉C#编译器有关代码组织信息

- 预处理器指令通常告诉编译器如何编译编译文件中的代码，而不参与实际编译过程。C#编译器将预处理器指令作为对源代码执行的常规词法分析的一部分，结果就是C#不支持更高级的预处理宏，最多只允许定义常量。所以“预处理器”在C++中显的更贴切，在C#就属于用词不当

- 预处理器指令：

  | 语句或表达式  | 常规语法结构                                                 |
  | ------------- | ------------------------------------------------------------ |
  | #if指令       | #if preprocessor-expression<br>code<br>#endif                |
  | #elif指令     | #if preprocessor-expression<br/>code<br/>#elseif preprocessor-expression<br>code<br>#endif |
  | #else指令     | #if preprocessor-expression<br/>code<br/>#else<br/>code<br/>#endif |
  | #define指令   | #define conditional-symbol                                   |
  | #undef指令    | #undef conditional-symbol                                    |
  | #error指令    | #error preproc-message                                       |
  | #warning 指令 | #warning preproc-message                                     |
  | #pragma 指令  | #pragma warning                                              |
  | #line 指令    | #line org-line new-line<br>#line default                     |
  | #region指令   | #region pre-proc-message<br>code<br>#endregion               |

#### 4.9.1 排除和包含代码

- 场用预处理器指令控制何时以及如何包含代码，可以用来处理不同平台的差异

#### 4.9.2 定义预处理器符号

- 有两种方式定义预处理器符号，第一种是#define指令，第二种是编译时使用define选项
- 取消符号定义使用#undef指令

#### 4.9.3 生成错误和警告

- 要标记代码中潜在的问题，可以插入#error和#warning指令来分别生成错误和警告信息
- 包含#warning指令后，编译器主动发出警告，可用这种警告标记代码中潜在的bug和可能改善的地方，是提醒开发者任务尚未完结的好帮手

#### 4.9.4 关闭警告信息

- #pragma（C#2.0）关闭或还原警告，编译器输出时会在警告编号前附加CS前缀，但是在用#pragma时不要添加该前缀

  ```c#
  #pragma warning disable 1030
  ```

- 重新启用警告仍是使用#pragma指令，只是需要在warning后添加restore选项

  ```c#
  #pragma warning restore 1030
  ```

- 场被禁用的警告是CS1591，该警告在使用/doc编译器选项生成xml文档，但并未注释程序中所有公共项时显示

#### 4.9.5 nowarn:<warn list\>选项

- C#支持nowarn:\<warn list\>选项，可以获得与#pragma相同的结果，只是不用加进源代码，而是作为编译器选项使用
- nowarn选项会影响整个编译过程，而#pragma指令只影响该指令所在的文件

#### 4.9.6 指定行号

- 用#line指令改变C#编译器在报告错误或警告时显示的行号，该指令主要由自动生成C#代码的实用程序和设计器使用
- #line default会反转之前所有#line的效果，并指示编译器报告真实的行号，而不是之前使用的#line指定的行号，但在两者之间的警告还是使用之前指定的行号

#### 4.9.7 可视编辑器提示

1. C#提供了只有在可视代码编辑器中才有用的两个预处理器指令：#region和#endregion。类似vs的代码编辑器能搜索源代码，找到这些指令，并在写代码时提供相应的编辑器功能
2. C#允许用#region指令声明代码区域，和#endregion必须成对使用，两个指令都可选择在指令后跟随一个描述性字符串，也可将一个区域嵌套到另一个区域中