### 5.1 方法的调用

- 方法的调用由方法名和实参列表构成，完全限定的方法名称包括命名空间、类型名和方法名，每部分以句点分割

#### 5.1.1 命名空间

- 命名空间是一种分类机制，用于分组功能相关的所有类型，其是分级的，级数任意，但超过5级就很罕见了

- 主要用命名空间按功能领域组织类型，以便查找和理解这些类型，还有助于防范类型名称冲突

- System命名空间包含用于执行大量基本编程活动的类型，几乎所有C#程序都要使用System命名空间中的类型

- 常用命名空间

  | 命名空间                       | 描述                                                         |
  | ------------------------------ | ------------------------------------------------------------ |
  | System                         | 包含基元类型，以及用于类型转换、数学计算、程序调用、环境管理的类型 |
  | System.Collections.Generics    | 包含使用泛型的强类型集合                                     |
  | System.Data                    | 包含用于数据库处理的类型                                     |
  | System.Drawing                 | 包含在显示设备上绘图和进行图像处理的类型                     |
  | System.IO                      | 包含用于文件和目录处理的类型                                 |
  | System.Linq                    | 包含使用”语言集成查询"（LINQ）对集合数据进行查询的类和接口   |
  | System.Text                    | 包含用于处理字符串和各种文本编码的类型，以及在不同编码方式之间转换的类型 |
  | System.Text.RegularExpressions | 包含用于处理正则表达式的类型                                 |
  | System.Threading               | 包含用于多线程编程的类型                                     |
  | System.Threading.Tasks         | 包含以任务为基础进行异步操作的类型                           |
  | System.Web                     | 包含用于实现浏览器到服务器通信的类型，用于支持ASP.NET        |
  | System.Windows                 | 包含用WPF创建富用户界面的类型（.NET 3.0），WPF用于XAML进行声明性UI设计 |
  | System.Xml                     | 为XML处理提供基于标准的支持                                  |

#### 5.1.2 类型名称

- 调用静态方法时，若目标方法和调用者不在同一个类型或基类中，就需要添加类型限定符。若要调用的静态方法是调用表达式所在类型的成员，C#就允许在调用时省略类型名称，编译器能够根据调用位置推断类型

#### 5.1.3 作用域

- 特定命名空间中的一个类型中的方法调用不需要指定该命名空间

### 5.2 方法的声明

- C#不支持全局方法，一切都必须在一个类型声明中，这也是Main()方法标记为static的原因，等价于C++的全局方法和Visual Basic的共享方法

#### 5.2.2 方法返回类型声明

- 若方法有返回类型，其主体必须有不可到达的结束点，方法不能在不返回值的情况下碰到大括号而自然结束
- 虽然从技术上说方法只能有一个返回类型，但返回类型可以是一个元组，多个值可通过C#元组语法打包成元组返回

#### 5.2.3 表达式主体方法

- 表达式主体方法允许用表达式代替完整方法主体（C#6.0）

- 表达式主体方法不是用大括号定义方法主体，而是用=>操作符，该操作符结果数据类型必须与方法返回类型匹配

  ```c#
  static string GetFullName(string firstName, string lastName) => $"{firstName} {lastName}";
  ```

### 5.3 using指令

- 可将一个或多个命名空间的所有类型"导入"文件，这样在使用时就不需要完全限定，通过using指令实现
- using指令不"导入"任何嵌套命名空间中的类型，嵌套命名空间必须显式导入
- C#不允许像java那样在using指令中使用通配符，每个命名空间都必须显式导入
- using指令可以在命名空间声明的顶部使用，也可以在命名空间声明的顶部使用，后者只对命名空间内的有效

#### 5.3.1 using static指令

- using static指令允许将命名空间和类型名称都省略，只需写静态成员名称
- 有的类拥有重叠的方，当使用using static指令引入后就会造成歧义，编译器不允许这种歧义，两个成员如具有相同签名调用时就会造成编译错误

#### 5.3.2 使用别名

- 可利用using指令为命名空间或类型取一个别名，别名是在using指令起作用的范围内可以使用的替代名称，最常见的用途是消除两个同名类型的歧义和缩写长的名称

### 5.4 Main()的返回值和参数

- C#支持在执行程序时提供命令行参数，并允许从Main()方法返回状态标识符，"运行时"通过一个string数组参数将命令行参数传给Main()，获取参数访问该数组即可
- Main函数若有返回值，程序就可以将状态码返回给调用者，非零返回值代表出错
- 虽然所有命令行参数可通过字符串数组传给Main()，但有时需要从非Main()方法中访问参数，可用System.Environment.GetCommandLineArgs()方法返回由命令行参数构成的数组
- 假如一个程序的两个类都有Main()方法，可在命令行csc.exe的/m开关指定包含入口点的类
- 每次调用新方法，"运行时"都创建一个"栈帧"或"活动帧"，其中包含了内容涉及传给新调用的实参、新调用的局部变量以及方法返回时应从哪里恢复，这样形成的一系列栈帧称为调用栈。用栈展开一词描述从调用栈中删除栈帧的过程，栈展开顺序通常与方法调用的顺序相反，方法调用完毕，控制会返回调用点

### 5.5 高级方法参数

#### 5.5.1 值参数

- 参数默认传值， 参数值会拷贝到目标参数中
- 引用类型的变量以值方式传给方法，拷贝的是引用地址，还是能改变地址处的数据，对string不行，string是不可变的。值类型以值方式传给方法，拷贝的是值，调用方法改变不了调用者的变量

#### 5.5.2 引用参数（ref）

- 关键字ref使参数以传入引用方式传递，被调用的方法可用新值更新调用者的变量。
- 若被调用你的方法将参数指定为ref，调用者调用该方法时提供了实参应附加的ref前缀的变量。调用者应初始化传引用的局部变量，被调用的方法可能直接从ref参数读取数据而不先对其进行赋值。ref参数只是传递的变量的别名

#### 5.5.3 输出参数（out）

- 方法经常要获取一个变量引用，且向变量写入而不读取，更安全的做法是以传引用的方法传入一个为初始化的局部变量，此时需要用关键字out修饰参数类型
- out参数功能上与ref完全一致，唯一区别是C#语言对别名变量的读写有不同规定，若是out，编译器会核实在方法所有正常返回的代码路径中是否都对该参数进行了赋值，若没有则报错
- 使用out参数常见的编码错误是忘记在使用前声明out变量，可在调用方法时以内联的形式声明out变量（C#7.0）
- 允许完全放弃out参数，使用下划线表示，out _（C#7.0）
- 在C#7.0以前，开发人员声明一个或多个out参数来解决方法只能有一个返回类型的限制

#### 5.5.4 只读传引用（in）

- C#支持以传引用的方式传入只读值类型（C#7.2），只读传引用将值类型以传引用的方式传给方法，不仅避免了每次调用方法都创建值类型的拷贝，而且别调用的方法不能修改值类型。其作用是在传值时减少拷贝量，同时把它标识为只读，从而增强性能。通过添加in修饰符表示只读引用参数
- 对于in修饰符修饰的参数，在方法中任何对该参数进行重新赋值的操作都会造成编译时错误

#### 5.5.5 返回引用

- 可以返回对变量的引用（C#7.0），有两个限制：对象引用再仍被引用时不应爱垃圾回收，且不存在任何引用时不应消耗内存。为了符合限制，从方法返回引用只能返回：
  - 对字段或数组元素的引用
  - 其他返回引用的属性或方法
  - 作为参数传给"返回引用的方法"的引用
- 返回引用时要注意几点：
  - 若决定返回引用，就必须返回一个引用
  - 声明引用局部变量的同时必须初始化它，为此需要将方法返回的引用赋给它，或将一个变量引用赋给他
  - 允许声明给你ref局部变量但不能声明ref字段
  - 自动实现的属性不能声明为引用类型
  - 允许返回引用的属性
  - 引用局部变量不能用值初始化，必须将返回引用的成员赋给它，或将局部变量、字段或数组赋给它

#### 5.5.6 参数数组（params）

- C#提供了一个特殊关键字params，允许在调用方法时提供数量可变的参数，而不是事先就固定好的参数数量
- param修饰的形参：
  1. 参数必须是数组且必须位于形参列表的最后一个，并且只能有一个
  2. 调用者可指定和参数数组对应的零个实参，这会使传递的参数数组包含零个数据项
  3. 参数数组是类型安全的，形参类型必须兼容参数数组的类型
  4. 调用者可传递一个实际的数组，而不是传递以逗号分隔的参数列表，最终生成的CIL代码一样
  5. 若目标方法的实现要求一个起码的参数数量，请在方法声明中显示指定必须提供的参数

### 5.7 方法重载

- 一个类中的所有方法都必须有唯一签名，C#根据方法名、参数数据类型或参数数量的差异来定义唯一性，返回类型不计入签名
- C#依据方法名、参数类型或参数数量的差异来定义唯一性
- 重载方法的常见模式：在一个方法中实现核心逻辑，其他所有重载版本都调用那个方法。通过此方法支持可选参数时十分有用

### 5.8 可选参数

- 可选参数（C#4.0）声明方法时将常量值赋给参数，以后调用方法时就不必为每个参数提供实参

- 可选参数一定要放在所有必须参数（无默认值参数）后面，且默认值必须是常量或其他能在编译时确定的值

- 调用者可利用具名参数（C#4.0）为一个参数显示赋值，而不是像以前那样只能依据参数顺序来决定哪个值赋给哪个参数

  ```c#
  public static void PrintName(string firstName, string lastName)
  {
       Console.WriteLine($"{firstName} {lastName}");
  }
  static void Main(string[] args)
  {
       PrintName(lastName: "y", firstName: "z");
  }
  ```

- 若一个方法中有大量参数，其中许多都可选，那么具名参数语法肯定能带来不少便利，但牺牲了方法接口的灵活性。参数名称为地方法结构的一部分，更改名称会导致使用具名参数的代码无法编译

- 编译器从一系列可用的方法中选择最终的调用的方法时，依据的是哪个方法类型最具体。C#规范包含额外的规则来决定byte、ushort、uint、ulong和其他数值类之间的隐式转换，但在写程序时最好使用显示转型，方便别人理解想调用的目标方法

### 5.9 用异常实现基本错误处理

#### 5.9.1 捕捉错误

- 抛出异常会终止执行当前分支，并跳到调用栈中用不处理异常的第一个代码块，若当前尚未提供任何异常处理，程序会向用户报告发生了未处理异常，若系统没有注册任何调试器，错误信息会出现在控制台上

- 捕捉异常：

  1. try块将可能抛出异常的代码包围起来，其告诉编译器：开发者认为块中的代码有可能抛出异常，若真的出了异常，则某个catch块要尝试处理该异常
  2. try块之后必须紧跟着一个或多个catch块，也可以跟一个finally块。catch块指定异常的数据类型，只要数据类型与异常类型匹配，对应的catch块就会执行，若一直找不到合适的catch块，抛出的异常就会变成一个未处理的异常，就好像没有进行异常处理一样

- 虽然catch块的数量随意，当处理异常的顺序不能随意，catch块必须从最具体到最不具体排列

- 无论try块的代码是否抛出异常，只要控制离开try块，finally块就会执行，其作用是提供一个最终位置，在其中放入无论是否发生异常都要执行的代码，其使用用来执行资源清理

- “运行时”先报告未处理的异常，再运行finally块。该行为合法，对于未处理的异常，”运行时“的行为是它自己实现的细节，任何行为都合法。一旦”运行时“发现未处理的异常，就会检查是否在机器上安装了调试器，因为用户可能是开发人员，要对该错误进行分析。若有调试器就允许用户在运行finally块之前将调试器与进程连接，若没有或者用户拒绝调试，默认行为就是在控制台上打印未处理的异常再看是否有任何finally块可供运行

- 所有异常都派生自System.Exception类（C#2.0），从其他语言抛出的异常类型若不是从System.Exception派生，会自动由一个从中派生的对象"封装"。最好的做法是写专门的catch块来处理更具体的派生类型，从而获取有关异常的具体信息，避免使用大量条件逻辑来判断具体发生了什么异常

- 常见异常类型：

  | 异常类型                          | 描述                                                         |
  | :-------------------------------- | :----------------------------------------------------------- |
  | System.Exception                  | 最“基本”的异常，所有异常类型都从其派生                       |
  | System.ArgumentException          | 传给方法的参数无效                                           |
  | System.ArgumentNullException      | 不应该为null的参数为null                                     |
  | System.ApplicationException       | 避免使用该异常，最开始是想区分系统异常和应用程序异常，但实际不好用 |
  | System.FormatException            | 实参类型不符合形参规范                                       |
  | System.IndexOutOfRangeException   | 试图访问不存在的数组或其他集合元素                           |
  | System.InvalidCastException       | 无效的类型转换                                               |
  | System.InvalidOperationException  | 发生非预期的情况，应用程序不再处于有效工作状态               |
  | System.NotImplementedException    | 虽然找到了对应的方法签名，但该方法尚未完全实现               |
  | System.NullReferenceException     | 引用为空，没有指向一个实例                                   |
  | System.ArithmeticException        | 发送被零除以外的无效数学运算                                 |
  | System.ArrayTypeMismatchExcpetion | 试图将类型有误的元素存储到数组中                             |
  | System.StackOverflowException     | 发生非预期的深递归                                           |

- 没有指定数据类型的catch块被称为常规catch块，等价于获取object数据类型的catch块，由于所有类最终都从object派生，所以没有数据类型的catch块必须放到最后

- 常规catch快很少使用，因为其没有办法捕捉有关异常的任何信息，且C#不允许抛出object类型的异常，只有使用C++这样的语言才允许任意类型的异常

- 从C#开始，若在捕捉System.Exception的catch块之后添加了一个常规catch块，编译器就会报告一条警告信息，指出常规catch块永远不会执行

#### 5.9.2 使用throw语句报告错误

- C#允许开发人员从代码中抛出异常，抛出异常需要有Exception的实例，大多数异常类型都允许在抛出异常时传递消息，以便在发生异常时获取消息

- 有时catch块能捕获异常，但不能正确或完整的处理，可以让该catch块重新抛出异常，方法是直接使用throw;语句，其和指定异常实例的throw语句相比，保留了调用栈的信息

- 开发人员应避免为预料之中的情况或正常控制流程抛出异常，异常是专为跟踪例外的、事先没有预料到的、可能造成严重后果的情况而设计的

- C#在抛出异常时会产生些许性能损失------相较于大多数操作都是纳秒级的速度，其可能造成毫秒级的延迟

- Parse()方法存在问题，其要知道是否能转换成功，唯一方法就是尝试执行类型转换并在失败时抛出并捕捉异常，更好的方法是使用TryParse()方法尝试执行转换同时不进行异常处理。C#第一个版本唯一支持的是double的TryParse方法，从.NET Framework2.0其，所有基元数值类型都支持该方法。其要求使用out关键字，因为从该方法返回的是bool值而不是转换好的值。

  从.NET Framework 4开始，枚举也支持TryParse()方法