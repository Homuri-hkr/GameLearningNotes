### 6.1 类的声明和实例化

- 虽然非必须，但一般应该将每个类都放到自己的文件中，用类名对文件进行命名，可以更容易的寻找定义了一个特定类的代码
- new操作符指示”运行时“为对象分配内存、实例化对象并返回对实例的引用
- “运行时”会在对象变得不可访问之后的某个时间自动回收内存，由垃圾回收器回收，判断哪些对象不再由其他活动对象引用，然后安排一个事件回收对象占用内存
- 在堆和栈分配对象都支持new操作符，强调了new不是关于内存分配的，也不是关于是否有必要进行回收的。C#也不需要C++中的delete，内存分配和回收都是“运行时”的细节
- 和C++不同，C#不支持隐式确定性资源清理（在编译时确定的位置进行隐式对象析构），C#通过using语句支持显示确定性资源清理，通过终结器支持隐式非确定性资源清理

### 6.2 实例化字段

- 比起成员变量，更标准、更符合规范的术语是字段，它是包容类型关联的具名存储单元，实例字段是在类级别上声明的变量，用于存储与对象实例关联的数据

### 6.4 使用this关键字

- C#允许用关键字显式指出当前访问字段或方法是包容类的实例成员，调用任何实例成员时this都是隐含的，其返回对象本身的实例

### 6.5 访问修饰符

- 可选择五个访问修饰符：public、private、protected、internal和protected internal

### 6.6 属性

#### 6.6.1 声明属性

- 属性的关键在于提供了从编程角度看类似于字段的API，事实上并不存在这样的字段。属性声明看上去和字段声明一样，但跟随在属性名之后的是一对大括号，要在其中添加属性的实现，其由三个上下文关键字（value、get、set）构成，get代表的属性取值方法，set代表的属性赋值方法，其中在set中可以用value关键字引用右侧部分

- C#7.0起可以用表达式主体方法声明属性的取值和赋值方法

  ```c#
  public string Name{
  	get => mName;
  	set => mName = value;
  }
  ```

#### 6.6.2 自动实现的属性

- 从C#3.0起属性语法有了简化版本，允许在声明属性时不添加取值或赋值方法，也不声明任何支持字段，一切都自动实现

  ```c#
  public string Name{get; set;}
  ```

- 从C#6.0开始可以对自动实现的属性进行初始化，在此之前只能通过方法来初始化属性

  ```c#
  public string Name{get; set;} = "zy";
  ```

#### 6.6.3 属性和字段的设计规范

- 方法代表行动，属性代表数据，属性旨在简化对简单数据的访问，调用属性的代价不应比访问字段高出太多
- 为符合封装原则，属性的支持字段不应声明为public或protected
- 避免从属性取值方法抛出异常，要在属性抛出异常时保留原始属性值
- 若不需要额外逻辑，要优先使用自动实现的属性，而不是属性加简单支持字段
- 考虑为支持字段和属性使用相同的大小写风格，为支持字段附加“_”前缀，但不要使用双下划线
- 考虑让某个属性和它的类型同名
- 若有意义的话，要为bool属性附加“Is”，“Can”，“Has”等前缀

#### 6.6.4 提供属性验证

- 属性验证时若判断新赋值无效，就需要抛出ArgumentException()或ArgumentNullException()类型的异常，两个异常都获取string类型的实参paramName来标识无效参数的名称。可用nameof（C#6.0）操作符来改进，该操作符获取一个标识符作为参数，返回该名称的字符串形式
- nameof操作符的优点在于，若标识符名称发生改变，重构工具能自动修改nameof的实参，不用重构工具代码将无法编译，强迫开发人员手动修改实参
- 对于属性验证代码，参数始终是value，所以是否使用nameof都一样，但对于所有paramName参数都应该坚持使用nameof操作符，对于ArgumentException和ArgumentNullException等获取paramName参数异常，从事为该参数使用nameof操作符

#### 6.6.5 只读和只写属性

- 可以出属性的取值方法或赋值方法来改变属性的可访问性
- C#6.0开始支持只读自动实现的属性，其和只读字段一样，编译器要求通过一个初始化器或构造函数来初始化

#### 6.6.6 属性作为虚字段

- 可以使用属性的取值返回表达式计算的值，赋值方法解析值且存到其他成员字中

#### 6.6.7 取值和赋值方法的访问修饰符

- C#1.0不允许为属性的取值和赋值方法指定不同的封装级别
- C#2.0允许属性的实现中为get和set部分指定访问修饰符但不能两者都指定，从而覆盖为声明属性指定的访问修饰符
- set和get的访问修饰符的“限制”必须比整个属性的访问修饰符要“严格”

#### 6.6.8 属性和方法调用不允许作为ref和out参数值

- C#允许属性向字段那样使用，只是不允许作为ref和out参数值传递，因为它们内部要将内存地址传给目标方法，但属性可能是无支持字段的虚字段，也可能为只读或只写，所以不可能传递存储地址。若需将属性或方法调用作为ref或out参数值传递，首先将值拷贝到变量再传递该变量，方法调用结束后将变量值赋回属性
- 属性在CIL中也是一种显式的构造，取值方法和赋值方法由CIL属性调用，而CIL属性是CIL代码中的一种显式构造。语言和编译器并非总是依据一个惯例解释属性，正是因为最后都会回归CIL属性，所以编译器和代码编辑器能随便提供自己的特殊语法
- 作为属性的一部分的取值方法和赋值方法包含了specialname元数据，IDE根据该修饰符在“智能感知”中隐藏成员
- 自动实现的属性在CIL中和显示定义支持字段的属性几乎完全一样，编译器在IL中生成名为\<PropertyName\>k_BackingField字段，该字段应用了名为System.Runtime.CompilerServices.CompilerGeneratedAttribute的特性，无论取值还是赋值方法都用同一个特性修饰

### 6.7 构造函数

#### 6.7.1 声明构造函数

- 构造函数是“运行时”用来初始化对象实例的方法
- new操作符内部和构造函数交互方式大致如下：new从内存管理区获取“空白”内存，调用指定构造函数，将对“空白”内存的引用作为隐式的this参数传给构造函数。构造函数链剩余部分开始执行，在构造函数之间传递引用，构造函数链上的执行结束后，new操作符返回内存引用，该引用指向的内存处于初始化好的形式

#### 6.7.2 默认构造函数

- 若类没有显示定义的构造函数，C#编译器会在编译时自动添加一个，该函数不获取参数，称为默认构造函数，当类提供了构造函数则编译器不再自动提供默认构造函数

#### 6.7.3 对象初始化器

- 对象初始化器（C#3.0）用于初始化对象中所有可以访问的字段和属性，调用构造函数创建对象时，可在后面的一对大括号中添加成员初始化类表，每个成员的初始化操作都是一个赋值操作，等号左边是可以访问的字段或属性

  ```c#
  Name name = new Name(){firstName = "z", lastName = "y"};
  ```

- 使用对象初始化器时要遵守相同的构造函数规则，其实际只是一种语法糖，最终生成的CIL代码和创建对象实例后单独用语句对字段及属性进行赋值无异，C#代码中的成员初始化顺序决定了在CIL中调用构造函数后的属性和字段赋值顺序

- 构造函数退出时，所有属性都应初始化成合理的默认值，偶尔一个或多个属性值可能导致同一个对象的其他属性战术包含无效值，此时应推迟抛出异常，知道对象实际使用这些相关属性时再决定是否抛出异常

- 集合初始化器（C#3.0）采用和对象初始化器相似的语法，用于在集合实例化期间向集合项赋值，借用数组语法来初始化集合中的每一项

  ```c#
  List<Name> names = new List<Name>(){
  	new Name("", ""),
  	new Name("", "")
  };
  ```

  像这样为新集合实例赋值，编译器生成的代码会按顺序实例化每个对象，并通过Add()方法将他们添加到集合中

- C#提供终结器为定义在对象销毁过程中发生的事情，其和C++析构函数不同，终结器不是在对一个对象的所有引用都消失后马上运行，而是在对象判定“不可到达之后的不确定时间内执行。垃圾回收器会在一次垃圾回收过程中识别出带有终结器的对象，但不是立即回收这些对象，而是将它们添加到一个终结队列中，一个独立的线程遍历终结队列的每个对象，调用其终结器，然后从队列中删除，使其再次可供垃圾回收器处理，C#7.0允许终结器作为表达式主体成员实现

#### 6.7.4 重载构造函数

- 构造函数可以重载，只要参数数量和类型有区别，可同时存在多个构造函数，和方法重载一样，多个构造函数使用少量参数支持简单情况，使用附加的参数支持复杂情况。但应优先使用可选参数而不是重载，以便在API中清楚看出“默认”属性的默认值

#### 6.7.5 构造函数链：使用this调用另一个构造函数

- 可以从一个构造函数中调用另一个构造函数，以避免重复输入代码，这称为构造函数链，用构造函数初始化器实现。构造函数初始化器会在执行当前构造函数的实现之前判断要调用另外哪一个构造函数

  ```c#
  public Name(string firstName){
  
  }
  public Name(string firstName, string lastName) : this(firstName){
  
  }
  ```

#### 6.7.6 解构函数

- 构造函数允许获取多个参数并把它们全部封装到一个对象中，但在C#7.0之前没有任何一个显式的语言构造将封装好的项拆分为它的各个组成部分，虽然可以简单将属性手动赋给变量但过于繁琐。C#7.0可以使用元组语法将操作简化

  ```c#
  public void Deconstruct(out string firstName, out string lastName){
  	(firstName, lastName) = (FirstName, LastName);
  }
  //隐式调用Deconstruct
  (firstName, lastName) = name;
  ```

- 只允许元组语法向那些和out参数匹配的变量赋值，不允许向元组类型的类型的变量赋值，也不允许向元组的具名项赋值

- 为声明解构函数，方法名必须是Deconstruct，签名返回void并接收两个或多个out参数，基于该签名，可将对象实例直接赋给一个元组而无须显示方法调用

### 6.8 静态成员

- C#没有全局变量和函数，所有字段和方法都在类的上下文中，与全局字段或函数等价的是静态字段或方法，只是静态字段和方法能包含访问修饰符，从而限制访问并提供更好的封装

#### 6.8.1 静态字段

- 静态字段也可在声明时初始化，和实例字段不同，未初始化的静态字段将获得默认值（default(type)），没有显示赋值的静态字段也是可以访问的
- 不能在同一个类中定义同名的静态字段和实例字段，重复的名称在声明空间中会造成编译错误

#### 6.8.3 静态构造函数

- C#支持静态构造函数，用于对类进行初始化。静态构造函数不显式调用，“运行时”在首次访问类时自动调用静态构造函数。“首次访问类”可能发生在调用普通构造函数时，也可能发生在访问类的静态方法或字段时
- 由于构造函数不能显式调用，所以不允许任何参数
- 静态构造函数的作用是将类中的静态数据初始化成特定值，尤其是在无法通过声明时的一次简单赋值来获得初始值的时候
- 若对静态字段赋值既在静态构造函数中进行，又在声明时进行，观察C#编译器生成的CIL代码，发现声明时的赋值被移动了位置，成为静态构造函数中的第一个语句，静态构造函数中的赋值优先于声明时的赋值，和实例字段的情况一样
- 没有“静态终结器”的说法，不要在静态构造函数中抛出异常，否则会造成类型在引用程序中剩余的生命期内无法使用
- 有时对静态成员进行初始化的代价比较高，且访问前没必要初始化，考虑使用内联方式初始化静态字段而不使用静态构造函数，要么在声明时初始化

#### 6.8.4 静态属性

- 使用静态属性几乎肯定比使用公共静态字段好，因为公共静态字段在任何地方都能调用，而静态属性至少提供了一定程度的封装

- 从C#6.0开始，整个静态属性都可简化实现为带初始化器的自动实现

  ```c#
  publci static Name{get; private set;} = 42;
  ```

#### 6.8.5 静态类

- 静态类不包含任何实例化字段和方法，所以无法创建实例化的对象
- 声明类时使用static关键字有两方面的意义：防止程序员写代码来实例化该类，防止类在内部声明任何实例化字段或方法
- 静态类的另一个特点是C#编译器自动在CIL代码中把它标记为abstract和sealed，这将使类不能被扩展

### 6.9 扩展方法

- 处理文件系统目录的System.IO.DirectoryInfo类，该类支持的功能包括列出文件和子目录（DirectoryInfo.GetFiles()）以及移动目录（DirectoryInfo.Move()），但其不支持拷贝功能

- 扩展方法（C#3.0）能模拟为其他类创建实例方法，只需要更改实例方法的签名，使第一个参数成为要扩展的类型，并在类型名称前附加this关键字

  ```c#
  public static void CopyTo(this DirectorInfo sourceDirectory, string target, SearchOption option, string searchPattern){
  
  }
  ```

- 扩展方法允许为任何类添加”实例方法“，即使那些不咋同一个程序集中的类，但查看CIL代码，会发现扩展方法是作为普通静态方法调用的，要求如下：

  - 第一个参数是要扩展或要操作的类型，称为“被扩展类型”
  - 为指定扩展方法，要在被扩展类型名称前附加this修饰符
  - 为了将方法作为扩展方法来访问，要用using指令导入扩展类型的命名空间，或将扩展类型和调用代码放在同一命名空间

- 若扩展方法的签名和被扩展类型中的现有的签名一致，则扩展方法永远不会得到调用，除非是普通的静态方法

- 通过继承来特化类型要优于扩展方法，扩展方法无益于建立清楚的版本控制机制，因为一旦在被扩展类型中添加匹配的签名，就会覆盖现有扩展方法，且不会发出任何警告

### 6.10 封装数据

#### 6.10.1 const

- const字段包含在编译时确定的值，运行时不可修改
- 常量字段自动成为静态字段，因为不需要为对象实例都生成生成新的字段实例。但将常量字段显式声明为static会造成编译错误
- 常量字段通常只声明为有字面值的类型

#### 6.10.2 readonly

- readonly修饰符只能用于字段不能用于局部变量，其指出字段值只能从构造函数中更改，或在声明时通过初始化器指定
- readonly字段可以是实例或者静态字段
- 可在执行时readonly字段赋值而非只能在编译时
- 编译器要求readonly字段能从其属性外部访问，但不能从属性外部访问属性的支持字段
- 和const字段相比，redonly字段不限于有字面值的类型
- 从C#6.0开始，优先选择只读自动实现的属性而不是只读字段

### 6.11 嵌套类

- 嵌套类指在类中定义另一个类
- 嵌套类可以为类自身指定private访问修饰符，可以限制类的作用域，防止类从外部访问
- 嵌套类鞥呢访问包括私有成员在内的包容类的任何成员，但包容类不能访问嵌套类的私有成员

### 6.12 分部类

- 从C#2.0 起支持分部类，一个类的多个部分，编译器可把它们合并成一个完整的类，虽然可在同一个文件中定义两个或多个分部类，但分部类的目的就是将一个类的定义划分到多个文件中

#### 6.12.1 定义分部类

- 在class前加上上下文关键字partial来声明分部类

  ```c#
  partial class Program{
  
  }
  ```

- 不允许用分部类扩展编译好的类或其他程序集中的类

#### 6.12.2 分部方法

- 分部方法（C#3.0）只能存在于分部类中，而且和分部类相似，主要是提供方便。在函数返回类型前加上关键字partial
- 分部方法允许声明方法而不需要实现，但若包含了可选的实现，则该实现就可以放到某个姐妹分部类定义中，该定义可能在单独的文件中
- 分部方法必须返回void，避免对放回值类型的无端猜测，且out参数不允许使用，只能使用ref参数
- 若没有为分部方法提供实现，CIL中不会出现分部方法的任何踪迹，这样在保持代码规模尽量小的同时还保证了高灵活性

