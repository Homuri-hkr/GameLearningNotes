### 7.1 派生

- 除非明确指定基类，否则所有类都默认从object派生

#### 7.1.1 基类型和派生类型之间的转型

- 由于派生建立了“属于”关系，所以总是可以将派生类型的值直接赋给基类型的变量，这称为隐式转型，不需要添加转型操作符，而且转换总会成功，不会引发异常，反之则不成立，从基类型转换成派生类型要求执行显式转型，而显式转型在运行时可能失败

- 执行显式转型，相当于程序员要求编译器信任他，或者程序员表示知道这么做的后果，只要圆括号中的目标类型确实从基类型派生，C#编译器就允许这个转换。虽然在编译时，C#编译器允许在可能兼容的类型之间执行显式转换，但CLR仍会在运行时验证该显式转型，对象实例不属于目标类型将引发异常

- 隐式转型为基类不会实例化新实例，而是令同一个引用基类型，它现在提供的功能是基类型的

- 类型间的转换并不限于单一继承链中的类型，完全不相关的类型也能相互转换，关键是要在两个类型之间提供转型操作符。C#允许类型包含显示隐式转型操作符，这样可提醒别人只有在确定转型会成功的时候才执行转换，否则就算准备好在失败时捕捉异常，执行有损转换时也应优先执行显式转型而不是隐式转换

  ```c#
  public static implicit operator A(B b){		//B向A隐式转换，若implicit改为explicit则为显式转换
  
  }
  ```

#### 7.1.2 private访问修饰符

- 派生类继承除构造函数和析构器之外的所有基类成员，但继承不意味着一定能访问，派生类不能访问基类中的private成员

#### 7.1.3 protected访问修饰符

- 要从派生类中访问受保护成员，必须能在编译时确定它是派生类或派生类的某个子类的实例，而不是在运行时通过拷贝确定的

  ```c#
  class A{
  	protected int item;
  }
  class B : A{
  	void Load(A a){
  		B b = a as B;		//必须转型，这里是A的实例，并不能直接被访问
  		b.item = 1;
  	}
  }
  ```

#### 7.1.4 扩展方法

- 扩展方法从技术上来说不是类型的成员，所以不能继承，但由于每个派生类都可作为它的任何基类使用，所以对一个类型进行扩展的方法也可扩展它的任何派生类型，所有扩展方法在派生类中也能使用，但出现相同签名仍然会被覆盖
- 扩展方法的一个基本原则：若受伤有基类的代码，直接修改会更好，即使基类代码不可用，程序员也应考虑在基类或个别派生类实现接口上添加扩展方法

#### 7.1.5 单继承

- C#是单继承语言，一个类不能直接从两个类派生

#### 7.1.6 密封类

- 密封类使用在class之前添加sealed修饰符禁止从其派生

### 7.2 重写基类

#### 7.2.1 virtual修饰符

- C#支持重写实例方法和属性，但不支持字段和任何静态成员的重写，基类必须将允许重写的每个成员都标记为virtual，若一个public和protected成员没有包含virtual修饰符，就不允许子类重写该成员

- C#要求显式使用override关键字重写方法。和java、C++不同，C#不允许隐式重写。为重写方法，基类和派生类成员必须匹配，且要有对应的virtual和override关键字，且override关键字意味着派生类的实现会替换基类的实现

- C++在构造期间不调度虚方法，类型会与基类型关联（静态类型），而不是与派生类型关联（在运行时关联为动态类型），虚方法调用的是基类的实现。C#会将虚方法调用调度给派生的最远的类型

- 不要在构造函数中调用会影响所构造对象的虚方法，假如该虚方法在当前要实例化的类型的派生类型中进行了重写，就会调用重写的实现，但在继承层次中，字段尚未完全初始化

  ```c#
  public class A{
      public A(){
          M1();
      }
  
      public virtual void M1(){}
  }
  
  public class B : A{
      private string _method;
      
      public B(){
          _method = "B_C";
      }
      
      public override void M1(){
          Console.WriteLine("Type:{0}, in B, {1}",GetType(), _method.ToUpper());
      }
  }
  public static void Main(string[] args){
      var b = new B();		//报错，此时_method未完全实例化
  }
  ```

#### 7.2.2 new修饰符

- new修饰符在基类面前隐藏了派生类重新声明的成员，此时不是调用派生类的最远的成员，相反是搜索继承链，找到使用new修饰符的那个成员之前的派生最远的虚函数
- 假如没有指定new或override，默认是new
- 对CIL来说，new修饰符对编译器生成的代码没有任何影响，但它会生成方法的newslot元数据特性，从C#角度看，唯一作用是移除编译器警告

#### 7.2.3 sealed修饰符

- 虚成员也可以用sealed修饰符密封

#### 7.2.4 base成员

- 调用基类的实现需使用base关键字

#### 7.2.5 构造函数

- 实例化派生类时，“运行时”首先调用基类构造函数，防止绕过基类的初始化机制
- 为避免因为缺少可访问的默认构造函数而造成错误，程序员需要在派生类构造函数的头部显式指定要运行哪一个基类构造函数

### 7.3 抽象类

- 抽象类是仅供派生的类，无法实例化的，定义抽象类要在class前添加abstract修饰符
- 抽象类的主要特点在于其包含抽象成员，抽象成员是没有实现的方法或属性，作用是强制所有派生类提供实现
- C++使用"=0"的语法定义抽象函数，且若子类中不实现抽象函数只会自动成为抽象类，不强迫对类有特殊声明，可以为abstract可以不为

### 7.4 所有类都从System.Object派生

- 任何类，不管是自定义类还是系统内建的类，都通过直接或间接继承从object派生，object所含有的方法都通过继承为对象所用，即使是字面值也支持这些方法：

  | 方法名                                                | 说明                                                       |
  | ----------------------------------------------------- | ---------------------------------------------------------- |
  | public virtual bool Equals(object o)                  | 若作为参数提供的对象和当时对象实例包含相同的值，返回true   |
  | public virtual int GetHashCode()                      | 返回对象值的哈希码，对HashTable这样的集合非常有用          |
  | public Type GetType()                                 | 返回与对象实例的类型对应的System.Type类型的一个对象        |
  | public static boolReferenceEquals(object a, object b) | 若两个参数引用同一个对象，返回true                         |
  | public virtual string ToString()                      | 返回对象实例的字符串提示                                   |
  | public virtual void Finalize()                        | 析构器的一个别名，通知对象准备终结，C#禁止直接调用此方法   |
  | protected object MemberwiseClone()                    | 执行浅拷贝来克隆对象，会拷贝引用，但被引用类型中的数据不会 |

### 7.5 使用is操作符验证基础类型

- C#用is判断一个对象对象的基础类型，即在继承链中的实际类型，若为目标类型则返回true，否则（包含空）返回false

  ```c#
  if(data is string){
  
  }
  ```

- is的好处是能创建一个显式环型可能失败但没有异常处理开销的代码路径

- 使用is操作符应衡量多态性问题，若可以用一个虚函数实现不同类型的相同用途，则可以不用使用is挨个判断

### 7.6 用is操作符进行模式匹配

- C#7.0增强了is操作符来支持模式匹配，先执行检查是否为目标类型，若是则将结果赋给新变量

- 大多数时候都可用模式匹配is操作符代替基本is操作符

  ```c#
  A b = new B();
  if( b is B b1)
  {
  	b1.Change();
  }
  ```

- 可以用模式匹配is操作符执行空检查，将相等性操作符替换成is操作符在可读性上没有任何区别

  ```c#
  if(b is null){
  
  }
  ```

### 7.7 switch语句中的模式匹配

- 支持模式匹配的switch语句提供了许多新功能：

  - 模式匹配case子句不限于有常量值的类型（string、int、long、enum等），任何类型都可以用

  - 模式匹配case标签在类型后面声明了一个变量，该变量的作用域限于当前switch小节

    ```c#
    case Usbkey usbKey:
    ```

  - 模式匹配case表情支持条件表达式，允许对条件进行额外筛选

    ```c#
    case Usbkey usbKey when usbKey.IsPluggedIn:
    ```

  - 模式匹配switch小节的顺序变得重要，为基类写一个case标签，且不添加任何条件表达式，后面为派生类写的switch块都不会执行，所以若后面存在派生类编译器会报错。若基类的case标签写了条件表达式（编译时解析不了），之后的派生类标签都会被屏蔽

  - 为null写的switch小节可在任何位置，它解析为true的条件总是具有唯一性，和基本switch语句的default标签一样

  - 允许针对相同类型写多个模式匹配的case标签，前提是其中最多一个没有条件表达式且该表达式放在所有拥有条件的标签之后

  - 常量switch小节可以和模式匹配switch小节混合使用，优先要考虑简化

    ```c#
    switch(num){
    	case int i when i == 42:
    	break;
    }
    ```

  - case子句不允许使用可空类型?.，改为使用分可空版本，应为空值会匹配case null，永远不会匹配针对可空类型的case子句

- 和is操作符一样，模式匹配只有在无法选择多态性方案时才会使用

### 7.8 使用as操作符进行转换

- as操作符尝试将对象转换成特定数据类型，若对象不能转换，as操作符会返回null

  ```c#
  if(data as string){
  
  }
  ```

- 使用as操作符可避免用额外的try-catch代码处理转换无效的情况，as操作符提供了尝试执行转型但转型失败后不引发异常的一种方式

- as能在继承链中向上或向下隐式转型，也提供了支持转型操作符的类型，但as不能判断基础类型

- as操作符一般要求采取额外步骤对被赋值的变量执行空检查，由于模式匹配的is操作符自动包含该检查，所以在C#7.0之后几乎用不着as操作符了

