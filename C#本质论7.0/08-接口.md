- 接口不包含任何实现，但和抽象类相似，接口也定义了一组成员，调用者可认为这些成员已经实现

### 8.1 接口概述

- 接口的关键之处是不包含实现和数据。其中方法声明用分号取代了大括号，字段不能在接口声明中出现。若接口要求派生类包含特定数据，会声明属性而不是字段，由于属性不含任何作为接口声明一部分的实现，所以不会也不能引用支持字段
- C#不允许为接口成员使用访问修饰符，所有成员都自动公共

### 8.3 接口实现

- 声明类来实现接口类似于从基类派生，要实现的接口和基类名称以逗号分割（基类在前，接口顺序任意）
- 类可以实现多个接口，但只能从一个类直接派生
- 实现接口时，接口所有成员都必须实现。抽象类可以将接口方法映射成自己的抽象方法，非抽象实现可在方法主体抛出NotImplementedException异常，但无论如何都要提供成员的一个实现
- 接口的重点在于永远不能实例化，即不能用new创建接口，所以接口没有构造函数或终结器
- 只有实例化实现了接口的类型，才能用接口实例
- 接口不能包含静态成员
- 不能为接口成员显示添加abstract修饰符
- 在类型中实现成员时有两种方式：显式和隐式。隐式是通过类型的公共成员实现接口成员

#### 8.3.1 显式成员实现

- 显式实现的方法只能通过接口本身调用，典型的做法是将对象转型为接口

- 在接口成员名称前附加接口名称前缀来显式实现接口成员

  ```c#
  string IName.GetName(){
  
  }
  ```

- 由于显式接口实现直接和接口关联，所以没必要使用virtual、override或public来修饰它们，事实上这些修饰符也是不被允许的

- 显式实现的成员不被视为类的公共成员，标注public可能有误导的嫌疑

#### 8.3.2 隐式成员实现

- 要隐式实现成员，只要求成员是公共的，且签名与接口成员签名相符，接口成员的实现不需要override关键字或其他任何便民该成员与接口关联的指示符
- 隐式成员实现不要求执行转型，成员可以直接调用，没有在它的类型中被隐藏起来
- 显式实现不允许的许多修饰符对于隐式实现都是必须或可选的，隐式成员实现必须是public的，而virtual是可选的，具体取决是否允许派生类重写实现，去掉virtual会导致成员被密封

#### 8.3.3 显式与隐式接口实现的比较

- 对于隐式和显示实现的接口成员，关键区别不在于成员声明的语法，而在于通过类型的实例而不是接口访问成员的能力
- 显式接口实现的目的就是将“机制问题”和“模型问题”分开，要求调用者先将对象转换成接口，然后才认为对象“可比较”，从而显示区分你想在什么时候和模型沟通，以及想在什么时候处理实现机制
- 可通过回答以下问题决定显式还是隐式实现：
  - 成员是不是核心的类功能？若不是，则没有必要设计成该类的直接可见，而设计成显式实现
  - 接口成员名称作为类成员名称是否恰当？隐式实现会混淆该方法的作用，就考虑成显式实现
  - 是否已经拥有相同签名的类成员？显示实现不会在类型的声明空间添加具名元素，所以若有则显示实现
- 由于从隐式变成显示会造成版本中断，因此较稳妥的做法是全部显示实现接口成员，使它们以后能安全的变成隐式
- 隐式还是显式不需要在所有接口成员间保持一致，所有完全可以将部分成员定义成显式将其他定义成隐式

### 8.4 在实现类和接口之间的转换

- 类似于派生类和基类的关系，实现类可隐式转换为接口，无须转型操作符，实现类的实例总是包含接口的全部成员，所以总是能成转换为类型接口
- 无法保证接口向实现类型的向下转型能成功，所以接口必须显式转型为它的某个实现类型

### 8.5 接口继承

- 一个接口可以从另一个接口派生，派生的接口将继承“基接口”的所有成员
- 显式实现接口成员，必须在完全限定的接口成员名称中引用最初声明它的那个接口名称
- 即使类实现的从基接口IA派生的接口IB，仍可明确声明自己要实现两个接口

### 8.6 多接口继承

- 接口能从多个接口继承，且语法和类的继承与实现语法一致

### 8.7 接口上的扩展方法

- 扩展方法还能作用于接口，方法的第一个参数是要扩展的接口，必须附加this修饰符
- C#不仅能为特定类型的实例添加扩展方法，还允许为该类型的对象集合添加，对扩展方法的支持是实现LINQ的基础
- IEnumerable是所有集合都要实现的基本接口，通过为IEnumerable定义扩展方法，所有集合都能享受LINQ支持

### 8.8 通过接口实现多继承

- 虽然类只能从一个基类派生，但可实现任意数量的接口，在一定程度上解决了C#不支持多继承的问题

### 8.9 版本控制

- 若组件或应用程序正在供其他开发者使用，创建新版本时不要修改接口。接口在实现接口的类和使用接口的类之间签订了契约，修改接口相当于修改契约，回事基于接口写的代码失效
- 更改或删除特定接口成员的签名明显会造成现有代码的中断，因为除非进行修改，否则对该成员的任何调用都不再能够编译。更改类的public或protected成员签名也会这样。但和类不同，在接口中添加成员也可能造成代码无法编译，除非进行额外的修改。问题在于实现接口的任何类都必须完整的实现，必须提供针对所有成员的实现

### 8.10 比较接口和类

- 接口引入了另一个类别的数据类型，是少数不扩展System.Object的类型之一。此外还有指针类型和类型参数类型。每个接口类型都可以转换成System.Object，并允许在接口的任何实例上调用System.Object的方法，所以这个区别没有多大

- 只能通过对实现接口的一个对象的引用来访问接口实例，不能用new操作符创建接口实例，所以接口不能包含任何构造函数和终结器，且不允许静态成员

- 接口和抽象类的区别

  | 抽象类                                                       | 接口                                                   |
  | ------------------------------------------------------------ | ------------------------------------------------------ |
  | 不能直接实例化，只能实例化一个派生类                         | 不能直接实例化，只能实例化一个实现类型                 |
  | 派生类要么自己是抽象的，要么必须实现所有抽象成员             | 实现类型必须实例化所有接口成员                         |
  | 可添加额外的非抽象后才能圆，由所有派生类继承，不会破坏跨版本兼容性 | 为接口添加额外的成员会破坏版本兼容性                   |
  | 可声明方法、属性和字段，以及其他成员类型，包括构造函数和终结器 | 可声明方法和属性但不能声明字段、构造函数、终结器       |
  | 成员可以是实例、虚、抽象或静态，非抽象成员可以提供默认实现供派生类使用 | 所有成员都基于实例，而且自动视为抽象，不能包含任何实现 |
  | 派生类只能从一个基类派生                                     | 实现类型可以实现多个接口                               |

### 8.11 比较接口和特性

- 有时用无任何成员的接口（不管是不是继承）来描述关于类型的信息。一般会认为这是对接口机制的滥用，接口应表示类型能执行的功能，而非陈述关于类型的事实，所以不要使用标记接口，改为使用特性

