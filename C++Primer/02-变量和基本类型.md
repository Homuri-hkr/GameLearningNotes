- 内置类型：语言自身定义的类型
- 库类型：标准库定义的类型
- 类类型：使用class定义的类型

### **2.1基本内置类型**

- C++定义了包含算术类型和空类型在内的基本数据类型，算术类型分为整型和浮点型

**算术类型**

| 类型        | 含义           | 最小尺寸     |
| ----------- | -------------- | ------------ |
| bool        | 布尔类型       | 未定义       |
| char        | 字符           | 8            |
| wchar_t     | 宽字符         | 16           |
| char16_t    | Unicode字符    | 16           |
| char32_t    | Unicode字符    | 32           |
| short       | 短整型         | 16           |
| int         | 整型           | 16           |
| long        | 长整型         | 32           |
| long long   | 长整型         | 64           |
| float       | 单精度浮点数   | 6位有效数字  |
| double      | 双精度浮点数   | 10位有效数字 |
| long double | 扩展精度浮点数 | 10位有效数字 |

- 除布尔型和扩展的字符型以外，其他的整型可以划分为无符号和有符号的两种，字符型被分为三种：char、signed char、unsigned char，其中char的实际表现会随编译器的不同表示为signed char或者unsigned char

**类型转换**

- 当赋值给无符号整型一个超过表示范围的值时，结果是初始值对无符号类型表示的数值的最大值取模后的余数
- 当赋值给有符号整型一个超过表示范围的值时，结果是未定义的
- 当一个算术表达式中既有无符号数又有int值时，有符号的数会转换为无符号数

**字面值常量**：一望而知的值。其形式和值决定了它的数据类型

- 整数字面值：以0开头的整数代表八进制数，以0x和0X开头的代表十六进制数。默认情况下十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号也可能是无符号。十进制字面值的类型是int、long、long long中尺寸最小的，前提是该类型能容下当前字面值，八进制和十六进制是这几个无符号有符号中能容下的最小的。类型short没有对应的字面值

  在书写字面值时前面的符号不算，它是对字面值取负值

- 浮点数字面值：默认是double类型

- 字符字面值：由单引号括起来的值，默认char型

- 字符串字面值：由双引号括起来的值，由常量字符够长的数组，编译器会在每个字符串结尾添加一个空字符('\0')

  若两个字符串字面值间仅有空格符间隔，则实际上是一个整体

- 两类不能直接使用的字符：不可打印的字符（如退格符）和特殊含义的字符（如双引号）

  这些字符通过使用转义序列来打印

  C++规定的转义序列

  | 含义                             | 转义序列 |
  | -------------------------------- | -------- |
  | 换行符                           | \n       |
  | 横向制表符                       | \t       |
  | 纵向制表符                       | \v       |
  | 响铃符                           | \a       |
  | 退格符                           | \b       |
  | 回车符(回到当前行首，输入会覆盖) | \r       |
  | 反斜线                           | \\\      |
  | 进纸符(下一页开始)               | \f       |
  | 问号                             | \?       |
  | 双引号                           | \\"      |
  | 单引号                           | \\'      |

  也可使用泛化的转义序列，形式是\x后跟1个或多个十六进制数字，或\后跟1个、2个或3个八进制数字，超过3位按普通字符算，其中数字部分表示的是字符对应的数值(结果与对应的字符集有关)

- 布尔字面值：true和false

- 指针字面值：nullptr

- 指定字面值类型

  - 字符和字符串

    | 前缀 | 含义                    | 类型     |
    | ---- | ----------------------- | -------- |
    | u    | Unicode16字符           | char16_t |
    | U    | Unicode32字符           | char32_t |
    | L    | 宽字符                  | wchar_t  |
    | u8   | UTF-8（仅限字符串常量） | char     |

  - 整型

    | 后缀  | 最小匹配类型 |
    | ----- | ------------ |
    | u/U   | unsigned     |
    | l/L   | long         |
    | ll/LL | long long    |

    最好使用L而不用l，因为容易和1混淆

    u可以和L以及LL混用，表示

  - 浮点型

    | 后缀 | 类型        |
    | ---- | ----------- |
    | f/F  | float       |
    | l/L  | long double |

### **2.2 变量**

- 变量：一个具名的、可供程序操作的存储空间。变量的数据类型决定了所在内存空间大小、布局方式、存储值的范围以及能参与的运算

- C++是一种静态数据类型语言，它的类型检查发生在编译时，编译器必须知道程序中每一种变量对应的数据类型。编译器负责检查数据类型是否支持要执行的运算，所以在使用变量前必须声明

- 初始化：创建变量时赋予其初始值

  赋值：把对象当前值擦除，而以一个新值来替代

  - 四种初始化语句：

    int var = 0;

    int var = {0};

    int var{0};

    int var(0);

    其中用花括号来初始化变量称为列表初始化（c11），当使用其对内置类型变量赋值时，若有丢失信息的风险则编译器会报错

  - 默认初始化：定义变量时未指定初值则对其赋予默认值

    定义于任何函数体之外的变量被初始化为0

    定义在函数体内部的内置类型变量不被初始化，使用未初始化的内置类型变量的值是未定义的

    每个类各自决定其初始化对象的方式，且是否允许不经过默认初始化就定义对象也由类自己决定。若类允许该行为则将决定对象的初始值是什么。string类规定初始值为空串

- C++支持分离式编译机制，允许将程序分割为若干个文件，每个文件可以被独立编译

- 声明：将名字告诉给程序以便使用

  定义：创建与名字关联的实体，并申请存储空间，且可能会赋初值

  若想声明一个变量而非定义它，在变量名前添加关键字extern且不显式的初始化变量（若初始化则抵消了extern作用，变为变量定义）。在函数内部初始化一个extern关键字标记的变量将引发错误

  变量只能被定义一次，但可以多次声明

- 标识符：由字母数字下划线组成，第一个字符不能为数字

  由c++具有保留字，所以不要出现两个连续的下划线，不能以下划线紧跟大写字母，定义在函数体外的标识符也不能以下划线开头

  c++关键字：详见00-关键字

- 定义在所有花括号外的名字具有全局作用域，能在整个程序范围内使用，其本身没有名字，当作用域操作符（::）左侧为空时，向全局作用于发出请求获取右侧名字

  定义在花括号内的具有块作用域，在当前块使用

  作用域能彼此包含，被包含的作用域称内层作用域，包含别的作用域称为外层作用域，内层作用域定义的名字将覆盖外层同名的名字

  名字的作用域始于声明语句，以声明语句所在作用域末端为结束

### 2.3 复合类型

- 复合类型：用其他类型定义的类型，包括引用类型，指针类型等

- 一条声明语句由一个基本数据类型和紧随其后的声明符列表组成，每个声明符命名了一个变量并指定该变量与基本数据类型有关的某种类型。

- 左值引用：

  - 和对象初始值绑定在一起，无法令引用重新绑定到另一个对象，因此引用必须初始化。

  - 引用只能绑定到对象上，不能绑定到字面值和计算结果

  - 引用类型本身不是一个对象，所以不能定义引用的引用。

  - 在一条语句中定义多个引用时，每个引用的标识符前都需要以&开头

- 指针：

  - 本身是一个对象，允许对指针的赋值和拷贝，且在指针的生命周期内他可以先后指向不同的对象。

  - 其无需再定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值

  - 因为引用不是对象，没有实际地址，所以不能定义指向引用的指针

  - 空指针不指向任何对象，赋值空指针有3种方式

    int *p1 = nullptr;

    int *p2 = 0;

    int *p3 = NULL;

    其中nullptr(c11)是特殊字面值，可以被转换成任意其他指针类型，NULL是预处理变量，在头文件cstdlib中定义，也就是0

  - void* 是一种特殊指针类型，可用于存放任意对象的地址，但不能判断其存放的是什么类型的对象，所以不能直接操作void* 指针指向的对象。一般用于和别的指针比较、作为函数的输入输出、赋给另一个void* 指针。

- 复合类型声明有两种常用书写方式，int*和int *，前者强调这是一个复合类型，后者强调了一个声明语句由基本数据类型加上声明符组成，可以防止误解一个复合类型声明可以作用一整段

- 阅读一个复合定义的用法是从右向左读

### 2.4 Const限定符

- const对象一旦创建后值不能改变，所以const对象必须初始化

- const对象进行的操作只要不改变自身的值都可行

- 默认情况下，const对象被设定为仅在文件内有效，当多个文件出现同名的const对象时，实际上是不同的对象

  对于const变量不管是声明还是定义，都带上extern关键字，这样就可以在多个文件中只定义一次即可

- 临时量对象：当编译器需要一个空间来暂存表达式 的求值结果时创建的一个未命名的对象

- const的引用（简称常量引用）：const 类型 &变量名;

  初始化常量引用允许使用任意表达式作为初始值，只要该表达式能转换成对应类型，常量对象的引用只能使用const 引用

  对引用可参与的操作进行了约束，但对于被引用的对象是没有任何约束的，所以可以为任意值

  类型  &const 变量名和普通的引用几乎没有区别，因为引用本身就不能改变所绑定的对象

- 指向常量的指针：const 类型 *变量名;

  不能通过指针改变所指向对象的值，若要存放常量对象的地址只能使用指向常量的指针，但指向常量的指针也可以指向非常量

- const指针(常量指针)：类型 * const 变量名;

  指针不能被改变但是指针指向的对象可以改变，必须初始化

- 顶层const：本身是个常量，对任意数据类型都适用，且在执行拷贝操作时不受影响

  底层const：指针所指的对象是一个常量，与复合类型的基本类型部分有关，在执行拷贝操作时双方必须是同等的底层const资格，或者两个对象数据类型必须能够转换，其中非常量可以转换为常量，反之则不行

  指针类型既可以是顶层const也可以是底层const。

**constexpr和常量表达式**

- 常量表达式：值不会改变且在编译过程就能得到计算结果的表达式，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式
- 将变量声明为constexpr类型（c11）就可以让编译器验证变量值是否为一个常量表达式，其将所定义的对象置为了顶层const

- 一个constexpr的指针初始值必须为0、nullptr或存储于某个固定地址中的对象；一个constexpr的引用初始值必须是存储于某个固定地址的对象。定义在函数内的对象除了静态对象地址一般不在固定地址，在所有函数体外的对象地址固定不变
- 字面值类型包括：算术类型，引用，指针，字面值常量类、枚举

### 2.5 处理类型

- 两种方法定义类型别名

  传统方法：typedef long long LL;

  别名声明：using LL=long long;（c11）

  - 类型别名引发的理解错误：typedef char * pstring; 

    const pstring cstr = 0;是一个指向char的常量指针而非拆解开的const char*是一个指向常量的指针

- auto（c11）：让编译器通过初始值来推算变量类型，其定义的变量必须有初始值

  - 使用auto在一条语句中声明的多个变量所有初始的基本数据类型相同
  - auto会忽略掉顶层const，保留底层const，若希望推断出的类型是一个顶层const则要明确指出
  - auto会将引用当成绑定对象的别名，将指针的取值也作为取值

- decltype（c11）：选择并返回操作数的数据类型，此过程中编译器分析并得到它的类型，却不实际计算其中的值

  - decltype不会忽略顶层const
  - decltype不会将引用类型当作其他类型的别名，而不会将取指针的操作当成取值，而是看做左值（获得引用类型），因为其不会让参数进行计算
  - 当变量再加一层括号时，将当作赋值左值的特殊表达式看待（结果永远是引用），若不加则作为变量看待

### 2.6 自定义数据结构

- 最好不要将对象的定义和类的定义放在一起，这样会显得代码混乱

- 类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员的拷贝

- C++11中可以为数据成员提供一个类内初始值用于初始化数据成员，没有初始值的成员将被默认初始化，类内初始值要么使用赋值语句，要么使用列表初始化，但不能使用()

- 头文件通常包含哪些只能被定义一次的实体，如类、const/constexpr变量，也经常使用其他头文件的功能

- 确保头文件多次包含仍能安全工作的常用技术是预处理器，其从C语言继承而来。

  预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量，#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真，一旦检查结果为真则执行后续操作直到#endif为止。

  预处理变量无视c++语言中关于作用域的规则

  实现使用头文件保护符，其依赖于预处理变量。整个程序中的预处理变量包括头文件保护符必须唯一，常用做法是基于头文件中的名字来构建保护符的名字，以确保其唯一性，且为避免和程序中其他实体发生冲突，一般将预处理变量的名字全部大写