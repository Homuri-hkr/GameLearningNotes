### 3.1 命名空间的using声明

- 按照规定，每个using声明引入命名空间中的一个成员
- 位于头文件的代码一般来说不应该使用using声明，因为头文件的内容会拷贝到所有引用它的文件中去，可能会导致名字冲突

### 3.2 标准库类型string

简介：string表示可变长的字符序列，使用string类型前先包含string头文件，且string名字定义在std命名空间中。严格来说string不属于容器类型，但其支持很多与容器类型类似的操作

- C++标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现者做出一些性能上面的需求，对于一般应用场合有足够的效率

- 初始化方式：

  - string s1;			//默认初始化，是一个空串

  - string s2(s1);      //s2是s1的副本

  - string s2=s1;       //等价于上一个

  - string s3("value");      //s3是字面值"value"的副本，除了字面值最后的那个空字符外

  - string s3="value";       //等价于上一个

  - string s4(n, 'c');          //将s4初始化为连续n个c组成的串

  - 若使用等号（=）来初始化一个变量，实际执行的拷贝初始化，编译器将等号右侧的初始值拷贝到左侧的对象中去

    若不使用等号，则执行的是直接初始化

    当初始值只有一个时，哪种初始化都行，若不止一个（类似于上面的s4），一般来说只能使用直接初始化

**string对象上的操作**

- 读写操作：is << string     os >> string

  - 在读取string对象时，会自动忽略开头的空白符，并从第一个真正的字符开始读取直到遇见下一处空白

  - 和内置对象的输入输出相同，string对象的此类操作也是返回运算符左侧的对象作为操作结果

- getline函数：

  参数是一个输入流和一个string对象，函数从给定的输入流中读取内容，直到遇到换行符为止（换行符也会被读入但会被丢弃），将读取的内容存入string对象中。getline也会返回其流参数，可以用来判断流的条件

- empty和size操作：

  empty根据string对象是否为空返回一个对应的bool值

  size返回string对象中字符的个数，类型为string::size_type

- string::size_type类型：一种无符号整型

  string及其他大多数标准库类型都定义了几种配套的类型，这些配套类型体现了标准库类型与机器无关的特性

- 比较操作：

  对每个字符按ASCII序列进行比较大小，若前面都相同，则较短的字符串比较长的小

- 赋值：允许将一个对象的值拷贝给另一个对象

- 相加：两个string对象相加即串接起来，string对象和字面值相加会将字面值隐式转换为string对象，在加号两侧至少有一个string对象不能为两个字符串字面值相加（注意加号是从左到右结合的，所以类似string + "" + "" 是正确的）

- 因为历史遗留问题和与C兼容，C++字符串字面值不是标准库类型string对象

- 获取对应字符：使用下标运算符、迭代器或at()成员函数

  下标运算符接受的参数为string::size_type类型，返回该位置字符的引用

**cctype头文件函数**

| 函数（参数为int型） | 返回值（int型）                                              |
| ------------------- | ------------------------------------------------------------ |
| isalnum(c)          | 当c是字母或数字返回true                                      |
| isalpha(c)          | 当c是字母时返回true                                          |
| iscntrl(c)          | 当c是控制字符时返回true                                      |
| isdigit(c)          | 当c是数字时返回true                                          |
| isgraph(c)          | 当c不是空格但可以打印时返回true                              |
| islower(c)          | 当c是小写字母时返回true                                      |
| isprint(c)          | 当c是可打印字符时返回true（空格或 具有可视形式）             |
| ispunct(c)          | 当c是标点符号返回true（不是控制字符、数字、字母、可打印空白中的一种） |
| isspace(c)          | 当c是空白时返回true（制表符、空格、回车符、换行符、进纸符）  |
| isupper(c)          | 当c是大写字符时返回true                                      |
| isxdigit(c)         | 当c是十六进制数字时返回true                                  |
| tolower(c)          | 返回对应的小写字母                                           |
| toupper(c)          | 返回对应的大写字母                                           |

**范围for语句（C11）**

- 语法：for(declaration : expression) statement;
- 若想使用范围for语句改变序列的值，则需将变量设置为引用
- 范围for语句时根据begin函数、end函数或begin成员函数、end成员函数来读取对应的元素

### 3.3 标准库类型vector

简介：vector是一个类模板，其本身不是类，存放指定对象的集合，C++标准要求vector应该能在运行时高效快速的添加元素。老式的模板的嵌套声明时要在两个>>间加一个空格以免被编译器误认为右移运算符

- 初始化方式

  - vector\<T\> v1			          //是一个空的类型为T的vector，执行默认初始化

  - vector\<T\>v2(v1)                //拷贝v1所有元素至v2

  - vector\<T\>v2 = v1              //等价上一种方式

  - vector\<T\>v3(n, val)            //初始化为包含n个重复的val值

  - vector\<T\>v4(n)                   //包含n个默认初始化的值

  - vector\<T\>v5{a,b,c...}           //包含了初始值个数的元素，每个元素被赋予列表中相应的值

  - vector\<T\>v5={a,b,c...}          //等价上一种方式

  - 通常情况下，可以只提供vector对象容纳的数量而不设置初始值，此时库会创建一个值初始化的元素初值，并赋给容器中所有元素，初值由具体类型决定。

    使用时有些类必须明确提供初始值，若vector对象中元素的类型不支持默认初始化就必须提供初始值

    若只提供了元素的数量而没有设定初始值，只能使用直接初始化而不能使用拷贝初始化

  - 列表初始化时会尽可能的将花括号内的值当作元素初始值的列表来处理（能隐式转换的都转化），若不能则尝试使用其他构造的方式（如 vector\<string\> str {5,"h"} 初始化5个 h）

**vector操作**

- pushback()：添加元素

  将一个参数添加至vector对象的末尾，在使用范围for循环的时候不能增减元素

- empty()：检查vector对象是否包含元素，返回一个布尔值

- size()：返回vector中的元素，类型为vector\<T\>::size_type

- 比较操作：对象能比较只能在元素类型可以比较的前提下才行

  两个vector对象相等当且仅当所含的元素个数相同，且对应位置的元素值也相同。

  当前面元素全都相等时，元素个数少的小

  当存在元素不同的时候，对应元素小的小

- 获取对应元素：使用下标运算符、迭代器或者at()成员函数

  下标运算符接受的参数为vector\<T\>::size_type类型，返回该位置字符的引用，下标运算符只能访问存在的元素，添加新元素得使用push_back

### 3.4 迭代器

- 迭代器分有效和无效：

  有效迭代器指向某个元素或者尾元素的下一位置，其他情况都是无效

- 有迭代器的类型都拥有begin和end成员函数

  begin返回指向第一个元素的迭代器

  end返回指向尾元素下一个位置，因此有称为尾后迭代器

  当容器为空时，begin和end返回同一个迭代器

- 只要使用了迭代器的循环体都不要更改迭代器所指向的容器添加和删除元素，这会使迭代器失效

**操作**

- *iter：返回迭代器iter所指向元素的引用

  iter->mem：解引用iter并获取该元素的mem成员

  执行解引用操作的迭代器必须合法并明确指向某个元素

- ++iter：指向当前元素的下一个元素

  --iter：指向当前元素的上一个元素

  因为end返回的迭代器并不实际指向某个元素，所以不能对其进行递增操作和解引用操作

- iter + n：得到向前移动n个元素的迭代器

  iter - n：得到向后移动n个元素的迭代器

  iter1 - iter2：得到两迭代器之间的距离，两迭代器必须指向同一个容器。返回值类型为difference_type类型（有符号整型）

- 比较运算（>、<、>=、<=、==）：比较两个指向同一个容器的迭代器，一个迭代器指向的位置在另一个迭代器之前，则小于另一个迭代器。若两个迭代器指向同一个容器的同一个元素，则相等

**迭代器类型**

- 分为iterator和const_iterator类型，其中const_iterator和常量指针相似，能读取但不能修改所指向的元素值。若对象是一个常量，则只能使用const_iterator，若不是常量则两者都可以使用

  begin和end返回的具体类型由对象是否是常量决定，若是常量则返回const_iterator，若不是则返回iterator

  cbegin和cend（C11）不管对象是否为常量都返回const_ierator

### 3.5 数组

简介：数组是一种复合类型，包括数组的标识符和数组的维度，其中，数组的维度也属于数组类型的一部分，所以在编译时应该是已知的，即维度必须是一个常量表达式 

**初始化**

- 和内置变量相同，若在函数内部定义了某种内置类型的数组，则默认初始化令数组含有未定义的值

- 定义数组时必须制定数组的类型，不能使用auto关键字由初始值的列表推断类型，且数组的元素应为对象，所以不存在引用的数组

- 可对数组的元素进行列表初始化，此时可以允许忽略数组的维度

  若未指定维度，则会根据初始值的数量计算维度的大小

  若指定维度，则初始化元素的数量不能超过维度大小，若小于维度大小则会使用对应类型的默认值初始化数组后面的元素

- 字符数组拥有额外的初始化方式，可以通过字符串字面值对其进行初始化，其存储的内容会在字符串最后加上一个空字符（'\\0'）

- 数组对象之间不能互相拷贝和赋值，一些编译器扩展支持数组之间的赋值，但一般来说避免使用 非标准特性

- 对于复杂的数组声明，好的方式是从内向外读，如int \*ptrs[10]（ptrs是含有10个int型指针的数组），int (\*ptrs)[10]（ptrs是一个指向含有10个int数组的指针）

**访问**

- 数组可以通过该范围for语句或下标运算符来访问
- 通常使用size_t定义数组下标的类型，其是一个机器相关的无符号类型，被设置的足够大以便能保存内存中的任意对象，定义在cstddef头文件中。且该类型是C++语言直接定义的，而之前使用的vector\<T\>::size_type是库模板vector定义的

**指针与数组**

简介：C++中，使用数组的时候编译器一般会将其转换为指针。在很多用数组名的地方，编译器都会将其自动替换为一个指向数组首元素的指针

- 在使用auto关键字来推测数组名的类型时，得到的类型是指针类型，而使用decltype关键字时，不会发生这种转换

- 指针也可作为迭代器使用，只需获取数组的首地址和尾地址即可，获取尾地址直接取arr[len]的地址（len是数组的长度）

  begin和end函数（C11）使用数组作为参数，分别返回数组的首尾地址的指针，定义在iterator头文件中

- 只要指针指向的是数组中的元素，就可以进行下标运算。内置数组的下标运算不要求下标是无符号类型，而标准库要求为无符号类型。

  例：int *p = &arr[2];		int num = p[-2];			//相当于num = arr[0]

**指针运算**

- ptr + n：得到指向该元素之后第n个数的指针

  ptr - n：得到指向该元素之前第n个数的指针

  ptr1 - ptr2：得到两指针之间的距离，类型为ptrdiff_t的机器相关的带符号标准库类型，定义在cstddef头文件中

- 比较运算：只要两个指针指向同一个数组的元素就可以进行该运算

- 上述指针运算同样适用于空指针，可以给其加上或减去值为0的整型常量表达式，两个空指针也可以相减，结果为0

  也适用于所指对象不是数组的指针，两个指针必须指向同一个对象或者该对象的下一个位置

**C风格字符串**

简介：字符串字面值是一种通用结构的实例，这个结构就是C++由C继承而来的C风格字符串，其以空字符结束（'\\0')

- cstring头文件中包括操作C风格字符串的函数
  - strlen(p)：返回p的长度，空字符不计算在内
  - strcmp(p1, p2)：比较p1和p2的相等性，若相等返回0，前者大于后者返回正值，前者小于后者返回负值
  - strcat(p1, p2)：将p2附加到p1后，返回p1
  - strcpy(p1, p2)：将p2拷贝给p1，返回p1
  - 传入此类函数的指针必须指向以空字符结尾的数组
- 尽管C++支持C风格字符串，但在C++程序中最好还是不要使用他们，因为C风格字符串使用不方便还易引起程序漏洞

**与旧代码的接口**

- 可以使用字符串字面值初始化string对象

- 任何出现字符串字面值的地方都可以用以空字符结尾的字符数组来替代

  - 允许使用以空字符结束的字符数组初始化string对象和为string对象赋值
  - 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象
  - 在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象

- 若一个程序需要使用C风格字符串，不能使用string对象来替代

- string的c_str()成员函数返回一个C风格字符串，其为一个const char* 类型，

- 可以使用两个指针指定范围来初始化vector对象

  例：vector\<int\> vec(begin(arr), end(arr)) ;			//用arr的所有元素初始化vec

### 3.6 多维数组

简介：严格说C++中没有多维数组，其实际上是数组的数组

**初始化**

- 允许使用花括号括起来的一组值初始化多维数组，包裹中的第一层每个花括号代表第一个维度的数字

  例：int arr\[2\]\[2\] = {{1}, {3}};						//初始化arr为1，0，3，0

  其中内层嵌套的花括号非必须，但是含义不同

  例：int arr\[2\]\[2\] = arr{1, 3};						//初始化arr为1，3，0，0

**访问**

- 可以通过对每个维度给定下标访问对应元素

- 在使用范围for访问多维数组时，除了最内层的循环，外层循环的控制变量都要声明为引用，不加引用数组会转换为指针类型，对指针类型的范围for循环会初始化控制变量为相同类型指针

  例：for(auto &row : arr) for(auto col : row) cout << col << endl;				//输出二维数组中的所有元素

- 使用auto推测数组类型时，得到的是指向整形数组的指针，使用decltype推断时得到多维数组的类型