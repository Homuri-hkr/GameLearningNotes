### 4.1 基础

- 函数调用也是一个特殊的运算符，其对运算对象的数量没有限制
- 当运算符作用于类类型的运算对象时，用户可以自行定义其含义，这成为重载运算符。但是运算符的优先级、运算对象个数、结合律都是无法更改的

**左值和右值**

- 左值：L-value中L代表Location，指可寻址。可以位于赋值语句的左侧，拥有一个名字作为标识，是一个内存空间，可以被检查和存储

  右值：R-value中R代表Read，指可读。只能位于赋值语句的右侧，是位于内存中的一个数据，除了使用内存地址选定位置以外，没有名字做为标识

- 当一个对象被用作右值的时候，用的是对象的值

  当一个对象被用作左值的时候，用的是对象在内存中的位置

- 在需要右值的地方可以用左值来替代，但是不能把右值作为左值来使用

- 使用左值的运算符：

  - 赋值运算符需要一个非常量的左值作为其左侧运算对象，得到的结果也是一个左值
  - 取地址运算符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值
  - 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符的求值结果为左值
  - 内置类型和迭代器的递增递减运算符作用域左值运算对象，前置版本所得的结果为左值

- decltype作用于计算结果为左值的表达式（不是变量）时，得到一个引用类型。作用于结果为右值的表达式时，得到的是一个指向指针的指针

**优先级与结合律**

- 算术运算符满足左结合律，意味着如果运算符的优先级相同，按照从左向右的顺序结合
- 表达式中括号括起来的部分被当成一个单元来求值，再与其他部分一起按照优先级组合

**求值顺序**

- 优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。对于那些没有指定执行顺序的运算符，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义行为。

  例：cout << i << ++i << endl;		//未定义

- 有4种运算符明确规定了求值顺序：

  - 逻辑与（&&），规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。
  - 逻辑或（||），规定先求左侧运算对象的值，只有当左侧运算对象的值为假时才继续求右侧运算对象的值。
  - 条件运算符（?:），规定先求？左边的表达式的值，如果为真，则求中间表达式的值，如果为假，则求右边表达式的值。
  - 逗号运算符（,）,先求逗号左边的值，然后将求值结果丢弃，再求右边的值，返回右边表达式的值。
  
- 在不清楚具体运算顺序时，应使用括号让表达式的组合关系复合程序逻辑的要求

- 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。但是当改变运算对象的子表达式本身就是另一个子表达式的运算对象时，该规则无效。例如*++iter

### 4.2 算术运算符

简介：包括+（一元正号）、-（一元负号）、+（加法）、-（减法）、*（乘法）、/（除法）、%（求余）

- 除非另做特殊说明，算术运算符都能作用于任何算术类型以及任意能转换为算术类型的类型。
- 算术运算符运算对象和求值结果都是右值
- 一元正号运算符，加法运算符，减法运算符都能作用于指针
- 一元正号运算符作用于一个指针或者算术值时，返回运算对象值的一个提升后的副本。
- 一元负号运算符对运算对象值取负之后，返回其提升后的副本
- 布尔值不应该参与运算，对于大多数运算符来说，布尔类型的运算对象将被提升为int型，所以，若 b = true，-b也会为true
- 参与取余运算的运算对象必须是整数类型
- C++语言的早期版本允许结果为负值的商向上或者向下取整，C++11规定商一律向0取整
- 如果m%n不等于0，则它的符号和m相同。C++语言的早期版本允许m%n的符号匹配n的符号，而且商向负无穷一侧取整，这一方式在新版本中已经禁止使用。

### 4.3 逻辑和关系运算符

简介：包括!（逻辑非）、<（小于）、<=（小于等于）、>（大于）、>=（大于等于）、==（相等）、!=（不相等）、&&（逻辑与）、||（逻辑或）

- 逻辑运算符和关系运算符的返回值都是布尔类型，对于这两类运算符来说，运算对象和求值结果都是右值
- 关系运算符求值结果都是布尔值，所以将几个关系运算符连在一起会使后面进行关系运算的对象有一边是布尔值。
- 进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象

### 4.4 赋值运算符

简介：=（等于）

- 赋值运算的结果是他左侧运算对象，并且是一个左值，结果的类型就是左侧运算对象的类型。如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型
- C++11允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象
- 对于多重赋值语句中的每一个对象，其类型要么和右边的对象的类型相同，要么可由右边对象爱干净的类型转换得到
- C++允许使用赋值运算作为条件，但这一特性经常会引起错误
- 复合运算（例如+=）与普通运算符的唯一区别是左侧运算对象的求值次数，复合运算符只求值一次，使用普通的运算符求值两次。

### 4.5 递增递减运算符

简介：++（前置\后置自增）、--（前置\后置自减）

- 这两种运算符必须使用 左值运算对象，前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回
- 除非必须，否则不用递增递减运算符的后置版本，后置版本会需要将原始值存储下来以便返回未修改的值。对于整数和指针类型，编译器可能对这种额外的工作进行一定的优化，但对于相对复杂的迭代器类型，额外工作消耗比较大。
- 因为大多数运算符都没有规定求值顺序，尽量不要在复合式子中改变其中某个对象的值再使用，所以要小心自增、自减两个运算符

### 4.6 成员访问运算符

简介：.（点运算符），->（箭头运算符）

- 箭头运算符作用与一个指针类型的运算对象，结果是一个左值。

- 点预算符分为两种情况：

  若成员所属的对象是左值，结果是左值

  若成员所属的对象是右值，结果是右值。

### 4.7 条件运算符

简介：condition ? expr1 : expr2;

- 当条件运算符符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值，否则运算结果是右值

### 4.8 位运算符

简介：~（位求反）、<<（左移）、>>（右移）、&（位与）、^（位异或）、|（位或）

- 位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。
- 位运算符提供检查和设置二进制位的功能
- 如果运算对象是“小整型”，则它的值会被自动提升为较大的整数类型（int类型）
- 关于符号位在左移右移时如何处理没有明确定的规定，所以建议仅将位运算符用于处理无符号类型

### 4.9 sizeof运算符

- sizeof运算符返回一条表达式或者一个类型名字所占的字节数，返回值为size_t类型的常量表达式

- sizeof运算对象有两种形式：

  sizeof(type) 

  sizeof expr，这种形式中，返回结果是表达式结果类型的大小，其不会计算表达式

- 由于sizeof 和 * 运算符的优先级相同，且sizeof是右结合，所以对于sizeof *p 是求的指针的类型大小

- C++11允许使用作用域运算符来获取类成员的大小。通常情况下只能通过类的对象才能访问类的成员，但sizeof无须提供一个具体的对象

- sizeof运算符的结果部分的依赖于其作用的类型：

  - 对char或类型为char的表达式执行sizeof计算，结果得1
  - 对引用类型执行sizeof运算得到被引用对象所占空间的大小
  - 对指针执行sizeof运算得到指针本身所占空间的大小
  - 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效
  - 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。sizeof对象不会将数组对象转换成指针来处理
  - 对string对象或者vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间

### 4.10 类型转换

**隐式转换**

- 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型
- 在条件中，非布尔值转换成布尔类型
- 初始化过程中，初始值转换成变量的类型，在复制语句中，右侧运算对象转换成左侧运算对象的类型
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一类型
- 函数调用时也会发生类型转换

**算术转换**

- 算术转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型

- 整数提升，负责把小整数类型转换成较大的整数类型：

  - 对于bool、char、signed char、unsigned char、short和unsigned short等类型来说，只要范围内所有的值都能存在int中，则提升为int类型，否则提升为unsigned int类型
  - 对于wchar_t、char16_t、char32_t等较大的char类型，提升为int、unsigned int、long、unsigned long、long long和unsigned long long中能容纳所有值的最小的一种类型

- 若一个运算对象是无符号类型，另一个运算对象是有符号类型，而且无符号类型字节数不小于有符号类型，那么有符号的运算对象转换成无符号的

  若有符号类型字节数大于无符号类型，此时转换结果依赖于机器。如果无符号类型的所有值都能存在有符号类型中，则无符号类型对象转换成有符号独享，若不能则有符号转换成无符号类型

**其他隐式类型转换**

- 数组转换成指针：在大多数数组的表达式中，数组自动转换成指向数组首元素的指针。当用在decltype、取地址符(&)、sizeof以及typeid等运算符时，转换不会发生
- 指针转换：常量整数值0或者字面值nullptr能转换成任意指针类型，指向任意非常亮的指针能转换成void\*，指向任意对象的指针能转换成const void\*
- 转换成布尔类型：如果指针或算术类型的值为0，转换结果是false，否则为true
- 转换成常量：允许将指向非常量类型的指针转换成指向相应常量类型的指针，对于引用同理
- 类类型定义的转换：类类型能定义有编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换，若果同时提出多个转换请求，则拒绝请求

**显示转换**

- dynamic_cast支持运行时类型识别
- static_cast任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。其对于将一个较大算术类型赋值给较小数据类型时，对于编译器无法自动执行的类型转换非常有用
- const_cast只能改变运算对象的底层const且只有它能改变底层const，其将常量对象转换为非常量类型。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为，然而对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。
- reinterpret_cast通常为运算对象的位模式提供较低较低层次上的重新解释，本质上依赖机器，其可以在除了const以外随意进行转换，是非常危险的强转类型。一般用于以下场景：
  - 从指针类型到足够大的整数类型
  - 从整数或枚举类型到指针类型
  - 从一个函数指针到另一个不同类的函数指针
  - 从一个对象指针到另一个指向不同类型的对象指针
  - 从一个类数据/函数成员到另一个类数据/函数成员
- 在早期版本的C++语言中，显示强转使用type (expr)和(type) expr两种形式，根据实际情况，相当于除了dynamic_cast以外的所有强转的功能。

### 4.11 运算符优先级表

| 结合律 | 运算符                             | 功能               | 用法                    |
| ------ | ---------------------------------- | ------------------ | ----------------------- |
| 左     | ::                                 | 全局作用域         | ::name                  |
| 左     | ::                                 | 类作用域           | class::name             |
| 左     | ::                                 | 命名空间作用域     | namespace::name         |
|        |                                    |                    |                         |
| 左     | .                                  | 成员选择           | object.member           |
| 左     | ->                                 | 成员选择           | pointer->member         |
| 左     | []                                 | 下标               | expr[expr]              |
| 左     | ()                                 | 函数调用           | name(expr_list)         |
| 左     | ()                                 | 类型构造           | type(expr_list)         |
|        |                                    |                    |                         |
| 右     | ++                                 | 后置递增           | lvalue++                |
| 右     | --                                 | 后置递增           | lvalue--                |
| 右     | typeid                             | 类型ID             | typeid(type)            |
| 右     | typeid                             | 运行时类型ID       | typeid(expr)            |
| 右     | explicit cast                      | 类型转换           | cast_name\<type\>(expr) |
|        |                                    |                    |                         |
| 右     | ++                                 | 前置递增运算       | ++lvalue                |
| 右     | --                                 | 前置递减运算       | --lvalue                |
| 右     | ~                                  | 位求反             | ~expr                   |
| 右     | !                                  | 逻辑非             | !expr                   |
| 右     | -                                  | 一元负号           | -expr                   |
| 右     | +                                  | 一元正号           | +expr                   |
| 右     | *                                  | 解引用             | *expr                   |
| 右     | &                                  | 取地址             | &lvalue                 |
| 右     | ()                                 | 类型转换           | (type)expr              |
| 右     | sizeof                             | 对象的大小         | sizeof expr             |
| 右     | sizeof                             | 类型的大小         | sizeof(type)            |
| 右     | Sizeof...                          | 参数包的大小       | sizeof...(name)         |
| 右     | new                                | 创建对象           | new type                |
| 右     | new[]                              | 创建数组           | new type[size]          |
| 右     | delete                             | 释放对象           | delete expr             |
| 右     | delete[]                           | 释放数组           | delete[] expr           |
| 右     | noexcept                           | 能否抛出异常       | noexcept(expr)          |
|        |                                    |                    |                         |
| 左     | ->*                                | 指向成员选择的指针 | ptr->*ptr_to_member     |
| 左     | .*                                 | 指向成员选择的指针 | obj.*ptr_to_member      |
|        |                                    |                    |                         |
| 左     | *                                  | 乘法               | expr * expr             |
| 左     | /                                  | 除法               | expr / expr             |
| 左     | %                                  | 求余               | expr % expr             |
|        |                                    |                    |                         |
| 左     | +                                  | 加法               | expr + expr             |
| 左     | -                                  | 减法               | expr - expr             |
|        |                                    |                    |                         |
| 左     | <<                                 | 左移               | expr <<expr             |
| 左     | >>                                 | 右移               | expr >>expr             |
|        |                                    |                    |                         |
| 左     | <                                  | 小于               | expr <= expr            |
| 左     | <=                                 | 小于等于           | expr > expr             |
| 左     | >                                  | 大于               | expr  expr              |
| 左     | >=                                 | 大于等于           | expr >= expr            |
|        |                                    |                    |                         |
| 左     | ==                                 | 相等               | expr == expr            |
| 左     | !=                                 | 不相等             | expr != expr            |
|        |                                    |                    |                         |
| 左     | &                                  | 位与               | expr % expr             |
|        |                                    |                    |                         |
| 左     | ^                                  | 位异或             | expr ^ expr             |
|        |                                    |                    |                         |
| 左     | \|                                 | 位或               | expr \| expr            |
|        |                                    |                    |                         |
| 左     | &&                                 | 逻辑与             | expr && expr            |
|        |                                    |                    |                         |
| 左     | \|\|                               | 逻辑或             | expr \|\| expr          |
|        |                                    |                    |                         |
| 右     | ?:                                 | 条件               | expr ? expr : expr      |
|        |                                    |                    |                         |
| 右     | =                                  | 赋值               | lvalur = expr           |
|        |                                    |                    |                         |
| 右     | *=,/=,%=,+=,-=，<<=,>>=，&=,\|=,^= | 复合赋值           | lvalur += expr          |
|        |                                    |                    |                         |
| 右     | throw                              | 抛出异常           | throw expr              |
|        |                                    |                    |                         |
| 左     | ，                                 | 逗号               | expr, expr              |