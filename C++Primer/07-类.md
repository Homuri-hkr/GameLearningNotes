### 7.1 定义抽象数据类型

- 定义在类内部的函数是隐式的inline函数

- 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象，当我们当用一个成员函数时，用请求该函数的对象地址初始化this对象

- this形参是隐式定义的，任何自定义名为this的参数或者变量的行为都是非法的

- this是一个常量指针，不允许改变this中保存的地址

- 默认情况下，this的类型是指向类类型非常量版本的常量指针，尽管this是隐式的，但它仍然需要遵循初始化规则，意味着在默认情况下我们不能把this绑定到一个常量对象上，这一情况也就使得我们不能在一个常量对象上调用普通的成员函数

- C++语言允许把const关键字放在成员函数的参数列表之后，表示将this声明为指向常量的常量指针，这样的成员函数被称为常量成员函数，常量对象以及常量对象的引用和指针只能调用常量成员函数

- 编译器分两步处理类：

  1. 首先编译成员的声明
  2. 再编译成员函数体（如果存在）

  所以成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序

- 在类外部定义成员函数时，成员函数的定义必须与他的声明匹配，返回类型、参数列表、函数名都得与类内部的声明保持一致，如果成员被声明成成员函数，那么它的定义也必须在参数列表后明确指定const属性

- 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该和类在同一个头文件中

**构造函数**

- 构造函数不能被声明为const的，当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性，因此，构造函数在const对象的构造过程中可以向其写值
- 类通过默认构造函数来控制默认初始化过程，它无需任何实参，如果没有为类显式的定义构造函数，则编译器就会隐式定义一个默认构造函数
- 编译器创建的默认构造函数又称为合成的默认构造函数，对于大多数类来说，这个函数按照如下规则初始化类的数据成员：
  - 如果存在类的类内初始值，则用它来初始化成员
  - 否则，默认初始化该成员
- 编译器只有在发现类不包含任何构造函数的情况下才会生成一个默认的构造函数，如果有定义其他构造函数，除非再定义一个默认的构造函数，否则类将没有默认构造函数
- 如果类包含有内置类型或者复合类型（数组和指针）的成员，只有当这些成员全都被赋予了类内的初始值时，这个类才适用于使用合成的默认构造函数。因为具有局部作用域的内置类型和复合类型对象，不会进行初始化，是未定义的
- 如果类包含了其他类的成员，且该类没有默认的构造函数，则编译器无法初始化该成员，也无法使用合成的默认构造函数
- 在C++11中，如果需要默认的行为，可以通过在参数列表后面写上=default来要求编译器生成构造函数。如果=default在类的内部，则默认构造函数是内联的，如果在外部则该成员默认情况下不是内联的
- 在构造函数的形参列表后和函数提前加上：以及其后的一部分称为构造函数初始值列表，它负责为新创建的对象的一个或者几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的或者在花括号内的成员初始值，不同成员的初始化通过逗号分隔开
- 当某个数据成员被构造函数初始化值列表忽略时，它将以合成默认构造函数相同的方式隐式初始化
- 构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同，如果不能使用类内初始值，则所有构造函数都应该显式的初始化每个内置类型的成员

**拷贝、赋值、析构**

- 出了定义类的对象如何初始化，还需控制拷贝、赋值和销毁对象时发生的行为。如果不主动定义这些行为，则编译器将合成这些操作
- 对于某些类来说，合成的版本无法正常工作，特别是当类需要分配类对象之外的资源时，合成的版本常常会失效
- 很多需要动态内存的类能使用vector对象和string对象管理必要的存储空间，能避免分配和释放内存带来的复杂性

### 7.2 访问控制与封装

- 在C++中，使用访问说明符加强类的封装性：
  - 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口
  - 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private封装了类的实现细节
- 每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止
- class和struct的唯一区别是默认访问权限不同，class的默认访问权限为private，struct默认访问权限为public
- 使用访问控制权限的好处：
  - 只要接口不变，即public部分不改变，用户级别的代码不用重新编译，但改变了private部分，该类的源文件需要重新编译
  - 可以防止用户代码破坏封装对象的状态

**友元**

- 如果一个类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可
- 友元声明只能出现在类定义的内部，但是类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束，一般来说，最好在类开始或者结束前的位置集中声明友元
- 友元的声明仅仅指定了关于该类访问的权限，而非一个通常意义上的函数声明，如果希望类的用户能够调用某个友元函数，那么必须在友元声明之外再专门对函数进行一次声明，为了使友元对类的用户可见，通常把友元函数的再次声明与类本身放置在同一个头文件中，且处于类的外部
- 许多编译器并未强制限定友元函数必须在使用之前在类的外部声明

### 7.3 类的其他特性

**类成员**

- 用来定义类型的成员必须先定义后使用，类型成员通常出现在类开始的地方。如定义类型别名
- 定义在类内部的成员函数是自定inline的，可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义。尽管无须在声明和定义额地方同时说明inline，但这么做是合法的，最好只在类外部定义的地方说明inline，这样可以使类更容易理解
- inline成员函数也应该与相应的类定义在同一个头文件中
- 可以在变量的声明中加入mutable关键字使该成员成员可变数据成员
- 一个可变数据成员永远不会是const，即使是const对象的成员，因此一个const成员函数可以改变一个可变成员的值
- 类内初始值必须使用=的初始化形式或者花括号括起来的直接初始化形式

**返回*this的成员函数**

-  可以通过返回*this返回当前调用该函数的对象

**类类型**

- 可以把类名作为类型的名字使用，从而直接指向类类型，或者可以把类名跟在关键字class或者struct后面，他们两是等价的，后者是从C语言继承而来
- 可以仅仅声明类型而暂时不定义，这种声明有时称为前向声明，在声明之后定义之前是一个不完全类型
- 不完全类型只能在非常有限的情景下使用：可以定义指向该类型的指针或者引用，可以声明以不完全类型作为参数或者返回值类型的函数（但不能定义）
- 对于一个类来说，在创建它的对象之前必须被定义过，而不能仅仅被声明，否则编译器就无法了解这样的对象需要多少存储空间。类似的，类必须被定义才能用引用或者指针访问其成员

**友元**

- 如果一个类指定了友元类，则该友元类的成员函数可以访问此类包括非公有成员在内的所有成员
- 友元关系不存在传递性
- 可以将其他类中的成员函数声明为友元，必须用作用域运算符明确指出该成员函数属于哪个类
- 要在B类中声明A类中一个成员函数为友元：
  1. 首先定义A类，其中声明函数，但不能定义它
  2. 接下来定义B类，并在B类中声明友元函数
  3. 最后再定义友元函数
- 尽管重载函数的函数名相同，但仍是不同的函数，要想将一组重载函数声明为友元，则函数中每一个都分别声明为友元
- 类和非成员函数的声明不是必须在他们的友元声明之前，当一个名字第一次出现在一个友元声明中，隐式的假定该名字在当前作用域是可见的，甚至就算在类的内部定义该函数，也必须在类的外部提供相应的声明从而使函数可见，但是使用友元函数必须在定义该函数之后才能使用（有些编译器并不强制执行这些规则，vs的编译器执行该规则）

### 7.4 类的作用域

- 如果使用类中定义的类型作为返回类型，在类外定义时也需使用作用域运算符指出包含它的类。

**名字查找与类的作用域**

- 名字查找：
  1. 首先，在名字所在的块中寻找其声明语句，只考虑在名字使用之前出现的声明
  2. 若没找到，继续查找外层作用域
  3. 若最终没有找到匹配的声明，则程序报错
- 在类中，如果成员使用了外层作用域的某个名字，而该名字代表一种类型，则类不能在类中重新定义该名字。尽管重新定义类型名字是一种错误的行为，但是编译器并不为此负责，一些编译器仍将顺利通过这些代码，包括vs
- 成员函数中使用的名字按照如下方式解析：
  1. 首先，在成员函数内查找该名字的声明，只有在使用之前出现的声明才考虑
  2. 若没找到，则在类中继续查找，类中所有的成员都被考虑
  3. 若没找到则在成员函数定义之前的作用域内继续查找

### 7.5 构造函数再探

**构造函数初始值列表**

- 如果成员是const或者引用的话，必须将其初始化，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化
- 初始化和赋值的区别和底层效率有关，前者直接初始化数据成员，后者先初始化再赋值
- 构造函数初始值列表值说明用于初始化成员的值，而不限定初始化的具体执行顺序。成员的初始化顺序和他们在类定义中出现的顺序一致，构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序
- 最好令构造函数初始值的顺序与成员声明的顺序保持一致，而且如果可能的话，尽量避免使用某些成员初始化其他成员

**委托构造函数**

- 委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些或者全部职责委托给了其他构造函数 
- 一个委托构造函数也有一个成员初始值列表和一个函数体，其中成员初始化列表只有一个唯一的入口，就是通过调用其他构造函数。
- 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体依次执行，然后再将控制权还给委托者的函数体

**默认构造函数的作用**

- 默认初始化以下情况下发生：
  - 当在块作用域内不使用任何初始值定义一个非静态变量或者数组时
  - 当一个类本身含有类类型的成员且使用合成的默认构造函数时
  - 当类类型的成员没有在构造函数初始值列表中显式的初始化时
- 值初始化在以下情况下发生：
  - 在数组初始化的过程中提供的初始值数量少于数组的大小时
  - 当不使用初始值定义一个局部静态变量时
  - 当通过书写形如T()的表达式显式的请求值初始化时，其中T是类型名

**隐式的类类型转换**

- 如果构造函数只接受一个实参，则它实际上定义了为此类类型的隐式转换机制，有时将这种构造函数称为转换构造函数
- 编译器只会自动进行一次类型转换
- 通过将构造函数声明为explicit可以阻止隐式转换
- 关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit的。
- 只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复
- 尽管编译器不会将explicit的构造函数用于隐式转换过程，但是可以使用这样的构造函数显式的强制转换

**聚合类**

- 聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式
- 当一个类满足如下条件，它是聚合的：
  - 所有成员都是public
  - 没有定义任何构造函数
  - 没有类内初始值
  - 没有基类，也没有virtual函数
- 可以提供一个花括号括起来的成员初始值列表初始化聚合类的数据成员。例：T t={0, "", 1.2f}。初始值的顺序必须与类中声明的顺序一致。如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化，初始值列表的个数绝对不能超过类的成员数量
- 显式地初始化类的对象的成员存在三个明显的缺点：
  - 要求类的所有成员都是public的
  - 将正确初始化每个对象的每个成员的重任交给了类的用户，而用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，这样的初始化过程荣昌乏味且容易出错
  - 添加或删除一个成员之后，所有的初始化语句都需要更新

**字面值常量类**

- 数据成员都是字面值类型的聚合类是字面值常量类。如果不是聚合类但符合如下要求也是字面值常量类：
  - 数据成员都必须是字面值类型
  - 类必须至少含有一个constexpr构造函数
  - 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式，或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数
  - 类必须使用析构函数的默认定义，该成员负责销毁类的对象
- constexpr构造函数可以声明成=default的形式或者是删除函数的形式。否则constexpr构造函数就必须既符合构造函数的要求（不能包含返回语句），又符合constexpr函数的要求（拥有的唯一可执行语句就是返回语句），综合两点可知，constexpr构造函数体为空
- constexpr构造函数必须初始化所有数据成员，初始值要么使用constexpr构造函数，要么是一条常量表达式
- constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或者返回类型

### 7.6 类的静态成员

- 通过在成员的声明之前加上关键字static使得其与类关联在一起，类型可以是常量、引用、指针、类类型等
- 类的静态成员存在于任何对象之外，对象中不包含任何与今天数据成员有关的数据。也不和任何对象绑定在一起，它们不包含this指针，所以静态成员函数不能被声明为const的，且不能在其函数体内使用this指针
- 可以使用类名加作用域运算符直接访问静态成员，也可以使用类对象、引用、指针访问。成员函数可以不通过作用域运算符就能直接使用静态成员
- 可以在类的内部也可以在外部定义静态成员，当在外部定义静态成员时不能重复static关键字，该关键字只能出现在类内部的声明语句
- 因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义，意味着它们不是由类的构造函数初始化。一般来说，不能在类的内部初始化静态成员，必须在类的外部定义和初始化每个静态成员，一个静态成员只能定义一次
- 类似于全局函数，静态成员一旦被定义，就将存在于程序的整个生命周期中
- 可以为静态成员提供const整数类型的类内初始值，要求静态成员必须是字面值常量类型的constexpr
- 静态成员和非静态成员的区别：
  - 静态成员的类型可以就是它所属的类类型，而非静态数据成员则收到限制，只能声明成它所属类的指针或引用
  - 可以使用静态成员作为该类成员函数的默认实参，而非静态成员不能

