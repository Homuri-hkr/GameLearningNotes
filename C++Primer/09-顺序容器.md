### 9.1 顺序容器概述

- | 顺序容器类型 | 描述                                                         |
  | ------------ | ------------------------------------------------------------ |
  | vector       | 可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢 |
  | deque        | 双端队列，支持快速随机访问，在头尾位置插入/删除速度很快      |
  | list         | 双向链表，只支持双向顺序访问，在列表任何位置进行插入/删除操作速度都很快 |
  | forward_list | 单向链表，只支持单向顺序访问，在链表任何位置进行插入/删除操作速度都很快 |
  | array        | 固定大小数组，支持快速随机访问，不能添加或者删除元素         |
  | string       | 与vector相似的容器，但专门用于保存字符。随机访问快，在尾部插入/删除速度快 |

- string和vector将元素保存在连续的内存空间中，由元素下标来计算其地址是非常快速的，但在这两种容器的中间位置添加或删除元素就会非常耗时

- list和forward_list两个容器的设计目的是令容器任何位置的添加和删除操作都很快速，这两种容器不支持元素随机访问。forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能，其没有size操作，因为保存或计算其大小就会比手写链表多出额外开销

- deque支持快速随机访问，在中间位置添加或删除元素的代价可能很高，但在两段添加或删除元素都是很快的，与list和forward_list的速度相当

- 与内置数组相比，array是一种更安全，更容易使用的数组类型，其大小是固定的

- 选择容器的基本原则：

  - 除非有更好的理由选择其他容器，否则应使用vector

  - 如果程序由很多小的元素，且空间的额外开销很重要，则不要使用list和forward_list

  - 如果程序要求随机访问元素，应使用vector和deque

  - 如果程序要求在容器的中间插入或删除元素，应使用list和forward_list

  - 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则应使用deque

  - 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素

    首先，确定是否真的需要在容器中间位置添加元素，档处理输入数据时，通常可以很容易的向vector追加数据，然后再调用标准库的sort函数来重排容器中的元素，从而避免在中间位置添加元素

    如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中

### 9.2 容器库概览

- 容器操作

  | 操作                                                   | 描述                                                        |
  | ------------------------------------------------------ | ----------------------------------------------------------- |
  | **类型别名**                                           |                                                             |
  | iterator                                               | 此容器类型的迭代器类型                                      |
  | const_iterator                                         | 可以读取元素，但不能修改元素的迭代器类型                    |
  | size_type                                              | 无符号整数类型，足够保存此种容器类型最大可能的容器大小      |
  | difference_type                                        | 带符号整数类型，足够保存两个迭代器之间的距离                |
  | value_type                                             | 元素类型                                                    |
  | reference                                              | 元素的左值类型，与value_type&含义相同                       |
  | const_reference                                        | 元素的const做只类型，即与const value_type&含义相同          |
  | **构造函数**                                           |                                                             |
  | C c;                                                   | 默认构造函数，构造空容器                                    |
  | C c(c1);                                               | 构造c1的拷贝至c                                             |
  | C c(b, e);                                             | 构造c，将迭代器b和e指定的范围内的元素拷贝到c中。array不支持 |
  | C c{a, b...}                                           | 列表初始化c                                                 |
  | **赋值与swap**                                         |                                                             |
  | c=c1                                                   | 将c中的元素替换成c1                                         |
  | c={a, b...}                                            | 将从中的元素替换成列表中的元素。array不支持                 |
  | c.swap(c1)                                             | 交换c和c1的元素                                             |
  | swap(c, c1)                                            | 交换c和c1的元素                                             |
  | **大小**                                               |                                                             |
  | c.size()                                               | c中元素的数目。不支持forward_list                           |
  | c.max_size()                                           | c可以保存的最大元素数目                                     |
  | c.empty()                                              | 若c中存储了元素，返回false，否则返回true                    |
  | **添加/删除元素（不适用于array）**在不同容器中接口不同 |                                                             |
  | c.insert(args)                                         | 将args中的元素拷贝进c                                       |
  | c.emplace(inits)                                       | 使用inits构造c中的一个元素                                  |
  | c.erase(args)                                          | 删除args指定的元素                                          |
  | c.clear()                                              | 删除c中的所有元素，返回void                                 |
  | ==, !=                                                 | 所有容器都支持相等和不等运算符                              |
  | <, <=, > , >=                                          | 无序关联容器不支持大于小于运算符                            |
  | **获取迭代器**                                         |                                                             |
  | c.begin(), c.end()                                     | 返回指向c的首元素和尾元素之后位置的迭代器                   |
  | c.cbegin(), c.cend()                                   | 返回指向c的首元素和尾元素之后位置的const迭代器              |
  | **反向容器的额外成员（不支持forward_list）**           |                                                             |
  | reverse_iterator                                       | 按逆序寻址元素的迭代器                                      |
  | const_reverse_iterator                                 | 不能修改元素的逆序迭代器                                    |
  | c.rbegin(), c.rend()                                   | 返回指向c的尾元素和首元素之前位置的迭代器                   |
  | c.crbegin(), c.crend()                                 | 返回指向c的尾元素和首元素之前位置的const迭代器              |

**迭代器**

- 迭代器有着公共的接口，如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的，其中有一个例外，forward_list迭代器不支持递减运算符
- 标准库使用左闭合的迭代器范围由三种方便的性质，假定begin和end构成一个合法的迭代器范围：
  - 如果begin和end相等，则范围为空
  - 如果begin和end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素
  - 可以对begin递增若干次，使得begin==end

**容器类型成员**

- 反向迭代器就是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的意义也发生了颠倒，对一个反向迭代器执行++操作会得到上一个元素**begin和end成员**

- 不以c开头的函数都是被重载过的，例如实际上有两个begin成员，一个是常量，一个非常量，具体获得的迭代器类型依赖于容器
- 以c开头的版本是C++11引入的，用以支持auto与begin和end函数结合使用

**容器的定义和初始化**

- 只有顺序容器（不包括array）的构造函数才能接受大小参数，关联容器不支持
- 为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配，不过当传递迭代器参数来拷贝一个范围时，不要求容器类型相同
- 对于除了array之外的容器类型，初始化列表还隐含的指定了容器的大小：容器将包含与初始值一样多的元素
- 与内置数组一样，标准库array的大小也是类型的一部分，当定义一个array时，除了指定元素类型，还要指定元素大小
- 一个默认构造的array是非空的，它包含了与其大小一样多的元素，这些元素都被默认初始化，若对array进行列表初始化，初始值的数目必须小于或等于array的大小
- 不能对内置数组进行拷贝或对象赋值操作，但可以对array进行

**赋值和swap**

- 与内置数组不同，标准库array类型允许赋值，赋值号左右两边的运算对象必须具有相同的类型
- 顺序容器（array除外）还定义了一个名为assign的成员，允许我们从一个不同但是相容的类型赋值，或者从容器的一个子序列赋值
- 由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器
- assign的第二个版本接受一个整型值和元素值，它用指定数目且具有相同给定值的元素替换容器中原有的元素
- swap操作交换两个相同类型容器的内容，除了array外，交换两个容器内容的操作保证会很快，因为元素本身并未交换，swap只是交换了两个容器的内部数据结构，而array会对元素真正进行交换
- 元素不会被移动意味着，除了string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效，它们仍指向swap操作之前所指向的那些元素。对一个string调用swap可能会导致迭代器、引用和指针失效（网上的答案是C++会对短字符进行优化SSO）
- 在新标准中，容器既提供成员函数版本的swap又提供非成员版本的swap，非成员版本的swap在泛型编程中很重要，统一使用非成员版本的swap是好习惯

**关系运算符**

- 只有当容器中的元素类型也定义了相应的比较运算符时，才可以使用关系运算符来比较两个容器，容器的相等运算符实际上是使用元素的==运算符实现的，其他关系运算符是使用元素的<运算符

### 9.3 顺序容器操作

**插入元素**

- 除了array以外，所有标准库容器都提供灵活的内存管理，在运行时可以动态的添加或删除元素来改变容器大小

  | 操作                  | 描述                                                         |
  | --------------------- | ------------------------------------------------------------ |
  | c.push_back(t)        | 在c的尾部创建一个值为t的元素，返回void。forward_list不支持   |
  | c.emplace_back(args)  | 在c的尾部创建由args创建的元素，返回void。forward_list不支持  |
  | c.push_front(t)       | 在c的头部创建一个值为t的元素，返回void。vector和string不支持 |
  | c.emplace_front(args) | 在c的头部创建由args创建的元素，返回void。vector和string不支持 |
  | c.insert(p,t)         | 在迭代器p指向的元素之前创建一个值为t的元素，返回指向新添加元素的迭代器 |
  | c.emplace(p, args)    | 在迭代器p指向的元素之前创由args创建的元素，返回指向新添加元素的迭代器 |
  | c.insert(p, n, t)     | 在迭代器p指向的元素之前插入n个值为t的元素，返回指向新添加的第一个元素的迭代器，若n为0，返回p |
  | c.insert(p, b, e)     | 将迭代器b和e指定的范围内的元素插入到迭代器p指向的元素之前，b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器。若范围为空则返回p |
  | c.insert(p il)        | il是一个花括号包围的元素值列表，将这些给定值插入到迭代器p指向的元素之前，返回指向新添加元素的第一个元素的迭代器，若列表为空，则返回p |

  forward_list有自己专有的insert和emplace

  向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用、指针失效

- vector和string尾部之外的位置，或者deque首尾之外的位置添加元素都需要移动元素，且向vector或string添加元素可能引起整个对象存储空间的重新分配

- 当用一个对象来初始化容器或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身

- 新标准引用三个新成员：emplace_front，emplace_back，emplace，这些操作构造而不是拷贝元素，传递给这些函数的参数必须与元素类型的构造函数相匹配

**访问元素**

- | 操作      | 描述                                                         |
  | --------- | ------------------------------------------------------------ |
  | c.back()  | 返回c中尾元素的引用，若c为空，函数行为未定义。不适用于forward_list |
  | c.front() | 返回c中首元素的引用，若c为空，函数行为未定义。               |
  | c[n]      | 返回c中下标为n的元素的引用，若n>=c.size()，则函数行为未定义  |
  | c.at(n)   | 返回小标为n的元素的引用，如果下标越界，则抛出out_of_range异常 |

  下标和at操作值适用于string、vector、deque和array

**删除元素**

- | 操作          | 描述                                                         |
  | ------------- | ------------------------------------------------------------ |
  | c.pop_back()  | 删除c中的尾元素，若c为空，则函数行为未定义，返回void。forward_list不支持 |
  | c.pop_front() | 删除c中的首元素，若c为空，则函数行为未定义，返回void。vector和string不支持 |
  | c.erase(p)    | 删除迭代器p所指定的元素，返回一个指向被删元素之后元素的迭代器，若p指向尾元素，则返回尾后迭代器。若p是尾后迭代器则函数行为未定义 |
  | c.erase(b,e)  | 删除迭代器b和e所指定范围内的元素，返回一个指向最后一个被删除元素之后的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器 |
  | c.clear()     | 删除c中所有元素，返回void                                    |

  这些操作会改变容器大小，所以不适用于array

  forward_list有特殊版本的erase

**特殊的forward_list操作**

- 在链表中，插入和删除操作都需要改变前驱的连接状态，但单向链表forward_list中没有一个简单的方法来访问其前驱，所以就通过特殊的函数来进行相应的插入和删除操作

- | 操作                      | 描述                                                         |
  | ------------------------- | ------------------------------------------------------------ |
  | lst.before_begin()        | 返回指向链表首元素之前不存在的元素的迭代器，迭代器不能解引用 |
  | lst.cbefore_begin()       | 返回指向首元素之前元素的const迭代器                          |
  | lst.insert_after(p,t)     | 在迭代器p后的位置插入元素t。返回指向插入元素的迭代器，如果范围为空，则返回p。若p是尾后迭代器，则函数行为未定义 |
  | lst.insert_after(p, n, t) | 在迭代器p后的位置插入n个元素t。返回指向最后一个插入元素的迭代器，如果范围为空，则返回p。若p是尾后迭代器，则函数行为未定义 |
  | lst.insert_after(p, b, e) | 在迭代器p后的位置范围b到e的元素，b和e不能指向lst本身。返回指向插入元素的迭代器，如果范围为空，则返回p。若p是尾后迭代器，则函数行为未定义 |
  | lst.insert_after(p, il)   | 在迭代器p后的位置插入列表il中的元素。返回指向插入元素的迭代器，如果范围为空，则返回p。若p是尾后迭代器，则函数行为未定义 |
  | emplace_after(p, args)    | 使用args在p指定的位置之后创建一个元素，返回一个指向新元素的迭代器，若p为尾后迭代器，则函数行为未定义 |
  | lst.erase_after(p)        | 删除p指向的位置之后的元素。返回一个指向被删元素之后元素的迭代器，若不存在这样的元素则返回尾后迭代器，如果p指向lst的尾元素或者尾后迭代器，则函数行为未定义 |
  | lst.erase_after(b, e)     | 删除b之后直到e的元素（不包含b）。返回一个指向被删元素之后元素的迭代器，若不存在这样的元素则返回尾后迭代器，如果p指向lst的尾元素或者尾后迭代器，则函数行为未定义 |

**改变容器大小**

- 可以使用resize来增加或缩小容器，array不支持。如果当前大小大于所要求的大小，容器后部的元素会被删除，如果当前大小小于新大小，将新元素添加到容器后部

**容器操作可能使迭代器失效**

- 向容器添加元素后：
  - 对于vector和string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。若存储空间未重新分配，指向插入位置之前的元素迭代器、指针和引用仍有效，之后的失效
  - 对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效
  - 对于list和forward_list，指向容器的迭代器、指针、引用仍然有效
- 删除容器中的元素后：
  - 对于vector和string，指向被删元素之前元素的迭代器、指针和引用仍有效，之后的无效
  - 对于deque，如果在首尾之外的任何位置删除元素，那指向被删除元素外其他元素的迭代器、引用和指针会失效。如果删除尾元素，则尾后迭代器会失效，其他迭代器、引用和指针有效。如果删除首元素，都不受影响
  - 对于list和forward_list，指向容器其他位置的迭代器、引用和指针有效
- 因为增加和删除操作可能使容器迭代器等失效，所以要使用相应函数返回的迭代器实时更新之前的迭代器。对于尾后迭代器也不能保存起来一直用，而应每次都调用end()实时更新

### 9.4 vector对象是如何增长的

- 当不得不获取新的内存空间时，vector和string和实现通常会分配比新的空间需求更大的内存空间，容器预留这些空间作为备用，可用来保存更多的新元素

- | 操作              | 描述                                                         |
  | ----------------- | ------------------------------------------------------------ |
  | c.shrink_to_fit() | 将capacity减少为size大小相同。只适用于vector、string、deque  |
  | c.capacity()      | 返回不重新分配内存，c可以保存多少元素。只适用于vector、string |
  | c.reserve(n)      | 分配至少能容纳那个元素的内存空间。只适用于vector、string     |

  只有当需要的内存空间超过当前容量时，reserve的调用才会改变容量，否则什么也不做。如果需求大于当前容量，reserve至少分配和需求一样的大小。

  调用shrink_to_fit并不保证一定退回内存空间

### 9.5 额外的string操作

**构造string的其他方法**

- | 操作                     | 描述                                                         |
  | ------------------------ | ------------------------------------------------------------ |
  | string s(cp, n)          | s是cp指向的数组中前n个字符的拷贝，此数组至少应该包含n个字符  |
  | string s(s2, pos2)       | s是s2从下标pos2开始的字符的拷贝。若pos2>s2.size()，构造函数的行为未定义 |
  | string s(s2, pos2, len2) | s是s2从下表pos2开始len2个字符的拷贝。若pos2>s2.size()，构造函数的行为未定义。不管len2的值为多少，构造函数之多拷贝s2.size()-pos2个字符 |

- 通常从一个const char*创建string时，指针指向的数组必须以空字符结尾，拷贝操作遇上空字符时停止，如果还传递给构造函数一个计数值，则不必以空字符结尾

**substr操作**

- | 操作             | 描述                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | s.substr(pos, n) | 返回一个string，包含s中从pos开始的n个字符的拷贝，pos的默认值为0，n的默认值为s.size()-pos |

- 如果开始位置超过了string的大小，则substr函数抛出out_of_range异常。如果开始位置加上计数值大于string大小，则substr会调整整数值，只拷贝到string的末尾

**改变string的其他方法**

- | 操作                   | 描述                                                         |
  | ---------------------- | ------------------------------------------------------------ |
  | s.insert(pos,args)     | 在pos之前插入args指定的字符，pos可以是一个下标或迭代器。接受下标八本返回一个指向s的引用，接受迭代器版本的返回指向第一个插入字符的迭代器 |
  | s.erase(pos, len)      | 删除从位置破势开始的len个字符，如果len被忽略，则删除从pos开始直至s末尾的所有字符，返回一个指向s的引用 |
  | s.assign(args)         | 将s中的字符替换成args指定的字符。返回一个指向s的引用         |
  | s.append(args)         | 将args追加到s，返回一个指向s的引用                           |
  | s.replace(range, args) | 删除s中范围range内的字符，替换为args指定的字符，range要么是一个下标和一个长度，要么是一对指向s的迭代器，返回一个指向s的引用 |

  insert和append拥有接受C风格字符串的版本

  append操作是在string末尾进行插入操作的一种简写形式

  replace操作是调用erase和insert的一种简写形式

**string搜索操作**

- | 操作                      | 描述                                          |
  | ------------------------- | --------------------------------------------- |
  | s.find(args)              | 查找s中args第一次出现的位置                   |
  | s.rfind(args)             | 查找s中args最后一次出现的位置                 |
  | s.find_first_of(args)     | 在s中查找args中任何一个字符第一次出现的位置   |
  | s.frind_last_of(args)     | 在s中查找args中任何一个字符最后一次出现的位置 |
  | s.find_first_not_of(args) | 在s中查找第一个不在args中字符的位置           |
  | s.frind_last_not_of(args) | 在s中查找最后一个不在args中字符的位置         |

  | args       | 描述                                                         |
  | ---------- | ------------------------------------------------------------ |
  | c, pos     | 从s中位置pos开始查找字符c，pos默认为0                        |
  | s2, pos    | 从s中位置pos开始查找字符串s2，pos默认为0                     |
  | cp, pos    | 从s中位置pos开始查找指针cp指向的以空字符结尾的C风格字符串，pos默认为0 |
  | cp, pos, n | 从s中位置pos开始查找指针cp指向的数组的前n个字符，pos和n无默认值 |

  每个搜索操作都返回一个string::size_type值，表示匹配发生位置的下标，如果搜索失败则返回一个名为string::npos的static成员，标准库将npos定义为一个const string::size_type类型并初始化为-1，因为npos是unsigned的，代表npos等于任何string最大的可能大小

**compare函数**

- | 操作                              | 描述                                                        |
  | --------------------------------- | ----------------------------------------------------------- |
  | s.compare(s2)                     | 比较s和s2                                                   |
  | s.compare(pos1, n1, s2)           | 将s中从pos1开始的n1个字符与s2进行比较                       |
  | s.compare(pos1, n1, s2, pos2, n2) | 将s中从pos1开始的n1个字符与s2中从pos开始的n2个字符进行比较  |
  | s.compare(cp)                     | 比较s与cp指向的C风格字符串                                  |
  | s.compare(pos1, n1, cp)           | 将s中从pos1开始的n1个字符与cp指向C风格字符串进行比较        |
  | s.compare(pos1, n1, cp, n2)       | 将s中从pos1开始的n1个字符与cp指向地址开始的n2个字符进行比较 |

  根据s大于、小于或等于给定的字符串，函数返回正数、负数或0

**数值转换**

- | 操作            | 描述                                                         |
  | --------------- | ------------------------------------------------------------ |
  | to_string(val)  | 一组重载函数，返回数值val的string表示。val可以是任意算术类型。其中小整型会被晋升 |
  | stoi(s, p, b)   | 返回s的起始子串的数值，返回类型为int。                       |
  | stol(s, p, b)   | 返回s的起始子串的数值，返回类型为long。                      |
  | stoul(s, p, b)  | 返回s的起始子串的数值，返回类型为unsigned long。             |
  | stoll(s, p, b)  | 返回s的起始子串的数值，返回类型为long long。                 |
  | stoull(s, p, b) | 返回s的起始子串的数值，返回类型为unsigned long long。        |
  | stof(s, p)      | 返回s的起始子串的数值，返回类型为float。                     |
  | stod(s, p)      | 返回s的起始子串的数值，返回类型为double。                    |
  | stold(s, p)     | 返回s的起始子串的数值，返回类型为long double。               |

  b表示转换所用的基数，默认为10。p是size_t指针，保存s中第一个非数值字符的下标，默认为0

  要转换为数值的string中第一个非空白符必须是数字中可能出现的字符串，+、-或数字，也可以是0x、0X、小数点开头、用e或E表示的指数部分

  sto读取参数，处理其中的字符，直到遇到不可能是数字的一部分为止

### 9.6 容器适配器

- 所有容器适配器都支持的操作和类型

  | 操作和类型     | 描述                                                         |
  | -------------- | ------------------------------------------------------------ |
  | size_type      | 一种主义保存当前类型最大对象的大小                           |
  | value_type     | 元素类型                                                     |
  | container_type | 实现适配器的底层容器类型                                     |
  | A a            | 创建一个名为a的空适配器                                      |
  | A a(c)         | 创建一个名为a的适配器，带有容器c的一个拷贝                   |
  | 关系运算符     | 每个适配器都支持所有关系运算符，这些运算符返回底层容器的比较结果 |
  | a.empty()      | 若a包含任何元素，返回false，否则返回true                     |
  | a.size()       | 返回a中的元素数目                                            |
  | swap(a, b)     | 交换a，b的内容，a和b必须有相同类型，包括底层容器类型也必须相同 |
  | a.swap(b)      | 同上                                                         |

- 标准库定义了三个顺序容器适配器：stack、queue和priority_queue。

- 适配器是标准库中一个通用的概念，容器、迭代器和函数都有适配器，本质上适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样

- 默认情况下stack和queue是基于deque实现的，priority_queue是在vector之上实现的

- 可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数来重载默认容器类型。例如stack<string, vector\<string\>> str_stk;

- 所有适配器都要求容器具有添加和删除元素的能力，所以适配器不能构造在array上。

  所有适配器都要求容器具有添加、删除以及访问尾元素的能力，所以适配器不能构造在forward_list上

- stack只要求push_back、pop_back和back操作，因此可以使用出了array和forward_list以外的任何容器类型来构造

  queue适配器要求back、push_back、front和push_front，因此他可以构造于list和deque上

  priority_queue除了front、push_back和pop_back操作之外还要求随机访问能力，因此可以构造于vector和deque上

- 每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作，只可以使用适配器的操作，而不能使用底层容器类型的操作

**栈适配器**

- | 操作            | 描述                                                 |
  | --------------- | ---------------------------------------------------- |
  | s.pop()         | 删除栈顶元素，但不返回该元素值                       |
  | s.push(item)    | 创建一个新元素压入栈顶，该元素通过拷贝、移动item而来 |
  | s.emplace(args) | 创建一个新元素压入栈顶，该元素通过args创建           |
  | s.top()         | 返回栈顶元素，但不将元素弹出栈                       |

**队列适配器**

- | 操作            | 描述                                                         |
  | --------------- | ------------------------------------------------------------ |
  | q.pop()         | 删除queue首元素或者priority_queue的最高优先级的元素。但不返回此元素 |
  | q.front()       | 返回首元素，但不删除此元素。只适用于queue                    |
  | q.back()        | 返回尾元素，但不删除此元素。只适用于queue                    |
  | q.top()         | 返回最高优先级元素，但不删除该元素。只适用于priority_queue   |
  | q.push(item)    | 在queue的末尾或priority_queue中恰当的位置创建一个元素，值为item |
  | q.emplace(args) | 在queue的末尾或priority_queue中恰当的位置创建一个元素，值由args构造 |

  