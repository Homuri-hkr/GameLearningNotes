### 10.1 概述

- 大多数算法都定义在头文件algorithm中，标准库还在头文件numeric中定义了一组数值泛型算法
- 一般情况下，**算法并不直接操作容器**，而是遍历由两个迭代器指定的一个元素范围来进行操作，因此算法不依赖与容器的类型，但很多算法依赖于元素类型能进行的操作

### 10.2 初识泛型算法

**只读算法**

- 算法只会读取其输入范围内的元素，而从不改变元素

- | 算法       | 头文件    | 功能                                                         |
  | ---------- | --------- | ------------------------------------------------------------ |
  | find       | algorithm | 将范围中每个元素与给定值进行比较，返回指向第一个等于给定值的元素的迭代器，如果范围中无匹配元素，则find返回第二个参数来表示搜索失败。该函数通过元素类型的==运算符完成每个元素和给定值的比较 |
  | count      | algorithm | 接受一对迭代器和一个值作为参数，返回给定值在序列中出现的次数 |
  | accumulate | numeric   | 接受一对迭代器和和的初值，返回求和结果，第三个参数决定了加法运算符和返回值的类型，因此范围中元素的类型必须与第三个参数匹配或者能转化为第三个参数的类型 |
  | equal      |           | 接受一个序列的范围和第二个序列开始比较位置的迭代器，如果两个序列对应元素都相等则返回true，否则返回false |

- 对于只读取而不改变元素的算法，通常最好使用cbegin和cend
- 只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长，如果第二个序列比第一个短则会出现错误

**写容器元素算法**

- 算法将新值赋予序列中的元素，使用这类算法，必须确保序列原大小至少不小于要求算法写入的元素数目。算法不会执行容器操作，所以不能改变容器大小

- 一些算法向输入范围写入元素，本质上并不危险，最多写入与给定序列一样多的元素

  | 算法 | 头文件 | 功能                                             |
  | ---- | ------ | ------------------------------------------------ |
  | fill |        | 接受一对迭代器和一个值，将值赋予范围中的每个元素 |

- 一些算法接受一个迭代器来指出一个单独的目的位置，将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始

  | 算法   | 头文件 | 功能                                                         |
  | ------ | ------ | ------------------------------------------------------------ |
  | fill_n |        | 接受一个单迭代器、一个计数值和一个值，将给定值赋予迭代器指向的元素开始的指定个元素 |
  | copy   |        | 接受一个范围和目的序列的起始位置。将给定范围的元素拷贝到目的序列中。可以用于内置数组的拷贝 |

- 向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写的元素

- 保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器，它是一种向容器中添加元素的迭代器

- back_inserter定义在头原件iterator中，接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器，通过次迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中

- 常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用

- 多个算法提供“拷贝”版本。这些算法计算新元素的值，但不会将他们放置在输入序列的末尾，而是创建一个新序列保存这些结果

  | 算法         | 头文件 | 功能                                                         |
  | ------------ | ------ | ------------------------------------------------------------ |
  | replace      |        | 接受输入序列的范围，一个被替换的值，一个新值。将序列中所有等于给定值的元素都改为另一个值 |
  | replace_copy |        | 接受一个额外的第三个参数，为调整后序列保存起始位置，可以使原序列不变 |

**重排容器元素的算法**

- 算法会重排容器元素的顺序

- | 算法        | 头文件 | 功能                                                         |
  | ----------- | ------ | ------------------------------------------------------------ |
  | sort        |        | 给定序列的范围，利用元素类型的<符号完成排序                  |
  | unique      |        | 给定序列的范围，覆盖相邻的的重复元素，使不重复的出现在范围前面，返回一个指向不重复范围后一个位置的元素的迭代器，此位置之后的迭代器不能确定 |
  | stable_sort |        | 给定序列的范围，稳定排序算法，在排序时维持相等元素的原有顺序 |

### 10.3 定制操作

- | 算法      | 头文件 | 功能                                                         |
  | --------- | ------ | ------------------------------------------------------------ |
  | find_if   |        | 接受一个范围和一个谓词，对输出序列中的每个元素调用给定的谓词，返回第一个使谓词返回非0的元素，如果不存在返回尾后迭代器 |
  | for_each  |        | 接受一个范围和一个可调用对象，对序列中的每个元素都执行可调用对象 |
  | transform |        | 接受一个范围、目的地址和一个可调用对象，对序列中的每个元素都执行可调用对象并将结果写到目的位置 |

**向算法传递函数**

- 对于使用元素类型的<或==运算符完成比较的算法，标准库还提供了额外版本，允许自定义操作来代替元素类型默认的比较
- 谓词是一个可调用的表达式，其返回结果是一个能用作条件的值，标准库算法所使用的谓词分两类：一元谓词（只接受单一参数）和二元谓词（接受两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词，因此，元素类型必须能转换成谓词的参数类型

**Lambda表达式**

- 可调用对象是对于一个对象或者表达式可以使用调用运算符，包括：函数、函数指针、重载函数运算符的类、Lambda表达式

- Lambda表达式的形式：

  [capture list] (parameter list) -> return type {function body}

  caputure list（捕获列表）是一个Lambda所在函数中定义的局部变量的列表（通常为空）；return type、parameter list、function body分别表示返回类型、参数列表和函数体。Lambda必须使用尾置返回来指定返回类型

  可以忽略参数列表和返回类型，但必须包含捕获列表和函数体

- Lambda的调用方式和普通函数的调用方式相同，都是使用调用运算符

- 在Lambda中忽略括号和参数列表等价于指定一个空参数列表，如果忽略返回类型，Lambda根据函数体中的代码推断出返回类型，如果包含单一return语句之外的内容，且未返回指定类型，则返回void（在vs上还是推测成功了，所以应该和编译器相关）

- Lambda不能有默认参数，调用的实参数目永远和形参数目相等

- Lambda要使用函数中的局部非static变量，必须在捕获列表中明确指明，捕获列表指引Lambda在其内部包含访问局部变量所需的信息，不捕获则不能使用。但可以直接使用定义在当前函数之外的名字和局部static变量

**Lambda的捕获和返回**

- 当定义一个Lambda时，编译器生成一个与Lambda对应的新的未命名的类类型。当向一个函数传递一个Lambda时，同时定义了一个新类型和该类型的一个对象，传递的参数就是此编译器生成的类类型的未命名的对象。当使用auto定义一个用Lambda初始化的变量时，定义了一个从Lambda生成的类型的对象

- 默认情况下，从Lambda生成的类都包含一个对应该Lambda所捕获的变量的数据成员，Lambda的数据成员也在Lambda对象创建时初始化

- 变量的捕获方式可以是值或引用。

  若采用值捕获，前提是变量可以拷贝，被捕获的变量的值在Lambda创建时拷贝而不是调用时拷贝，随后对被捕获的变量进行修改也不会影响被捕获的值。

  若采用引用捕获只需在捕获列表中对应对象名前加上引用运算符或者使用指针、迭代器等，但使用引用捕获必须保证在Lambda执行时，该引用变量没有被销毁，仍然存在

- 除了显示列出希望使用的来自所在函数的变量外，还可以让编译器根据Lambda体中的代码来推断要使用的变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。&告诉编译器采用引用捕获方式，=表示采用值捕获方式。

- 如果希望对一部分变量采用值捕获，其他采用引用捕获，可以混用显式和隐式捕获，通给给定一个隐式捕获来确定默认使用该方式捕获，然后显式指定其他捕获方式的变量，该方式不能和隐式捕获的相同

- 对于一个值被拷贝的变量，Lambda不能改变其值，但引用捕获的非const值可以。如果希望改变一个被值捕获变量的值，必须在参数列表后加上关键字mutable（不会改变原有变量的值，只能改变拷贝的值），因此可变Lambda能省略参数列表

**参数绑定**

- bind是一个定义在头文件functional中的标准库函数，可以看做一个通用的函数适配器，接受可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表

- bind的一般形式为：auto newCallable = bind(callable, arg_list)

  newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应着callable的callable的参数，当调用newCallable时，会调用callable并传递给arg_list中的参数。

  arg_list中可能有形如_n的"占位符"，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”，\_1是newCallable的第一个参数，也可以用占位符让旧函数的形参顺序交换

  例：void f1(string a, int b)

  auto f2 = bind(f1, _1, 6);			//f2有一个对应f1第一个形参的形参，也就是string类													//型，调用f2相当于调用void f1(string a,  6);这个函数

  auto f3 = bind(f1, _2, _1)		//调用f3给定的形参和f1正好相反

- 名字_n定义在placeholders的命名空间中，该命名空间被定义在std命名空间中，所以要使用这些名字需引用这个命名空间

- 默认情况下，bind的不属于占位符的参数被拷贝到bind返回的可调用对象中，所以不能使用不支持拷贝的对象。如果想传递给bind一个引用，则使用标准库函数ref，其接受一个对象，返回一个引用，该引用是可以拷贝的，还有个cref，返回const引用，他们也定义在头文件functional中

- 旧版本C++提供了bind1st和bind2nd函数分别只能绑定一个或第二个参数，在C++11中已经被弃用

### 10.4 再探迭代器

- 标准库在头文件iterator中还定义了额外几种迭代器：

  插入迭代器：这些迭代器被绑定到一个容器上，用来向容器插入元素

  流迭代器：这些迭代器被绑定到输入或输出流，可用来遍历所有关联的IO流

  反向迭代器：这些迭代器想后面而不是向前移动，出了forward_list之外的标准库容器都有反向迭代器

  移动迭代器：这些专用的迭代器不是拷贝其中的元素，而是移动它们

**插入迭代器**

- | 操作            | 描述                      |
  | --------------- | ------------------------- |
  | it = t          | 在it指定的当前位置插入值t |
  | *it, ++it, it++ | 都返回it，不会做任何事情  |

- 插入迭代器有三种类型：

  back_inserter：创建一个使用push_back的迭代器

  front_inserter：创建一个使用push_front的迭代器

  inserter：创建一个使用insert的迭代器。当调用inserter(c, iter)时，得到一个迭代器，在使用它时，会将元素插入到iter之前的位置

**iostream迭代器**

- istream_iterator读取输入流，ostream_iterator向一个输出流写数据，这些迭代器将它们对应的流当作一个特定类型元素序列来处理

- 当创建一个流迭代器时，必须指定迭代器将要读写的对象类型

- 一个istream_iterator使用>>来读取流，因此对应的类型必须定义了输入运算符。也可以默认初始化迭代器，创建了一个可以当做尾后值使用的迭代器

- 对于一个绑定到流的迭代器，一旦关联的流遇到文件尾和IO错误，迭代器的值就与尾后迭代器相等。流迭代器就是一个一个的读，读到和类型不同的就是IO错误就停止了

- istream_iterator操作

  | 操作                          | 描述                                                         |
  | ----------------------------- | ------------------------------------------------------------ |
  | istream_iterator\<T\> in(is); | in从输入流is中读取类型为T的值                                |
  | istream_iterator\<T\> end;    | 读取类型为T的值的尾后迭代器                                  |
  | in1 == in2                    | in1和in2必须读取相同类型，若它们都是尾后迭代器或者绑定到相同的输入两者相同 |
  | in1 != in2                    | 读取相同类型，未绑定到相同输入，                             |
  | *in                           | 返回从流中读取的值                                           |
  | in->mem                       | 与(*in).mem的含义相同                                        |
  | ++in, in++                    | 使用元素类型所定义的>>运算符从输入流中读取下一个值。前置版本先递增再返回，后置版本先返回再递增 |

- 当将一个istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据，具体实现可以推迟从流中读取数据，直到使用迭代器时才真正读取，标准库所保证的是，在第一次解引用迭代器，从流中读取数据的操作

- 可以对任何具有输出运算符（<<运算符）的类型定义ostream_iterator，当创建一个ostream_iterator时，可以提供可选的第二参数，它是一个字符串，在输出每个元素后都会打印此字符串，字符串必须是一个C风格字符串。必须将ostream_iterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator

- ostream_iterator操作

  | 操作                             | 描述                                                         |
  | -------------------------------- | ------------------------------------------------------------ |
  | ostream_iterator\<T\> out(os)    | out将类型为T的值写到输出流os中                               |
  | ostream_iterator\<T\> out(os, d) | out将类型为T的值写到输出流os中，每个值后面都输出一个d        |
  | out = val                        | 用<<运算符将val写入到out所绑定的ostream中，val的类型必须与out可写的类型兼容 |
  | *out, ++out, out++               | 这些运算符时存在的，但不对out做任何事情，每个运算符都返回out |

  虽然*out这些实际上没有任何意义，但为了在修改为其他迭代器的时候方便，最好还是加上

**反向迭代器**

- 只能从同时支持++和--的迭代器定义迭代器，forward_list和流迭代器不支持递减运算，所以不能从这两个创建反向迭代器
- 可以调用reverse_iterator的base成员返回对应元素的普通迭代器，因为迭代器是具有左闭合的性质，所以直接用反向迭代器给一般迭代器赋值，或者反过来赋值都是会出问题的，指向的是相邻的元素而不是相同的元素（编译器也不支持两者之间赋值）

### 10.5 泛型算法结构

**五类迭代器**

- 算法最基本的特性是它要求迭代器提供哪些操作，这些操作可以分为5种迭代器类别

  | 类别           | 描述                                 |
  | -------------- | ------------------------------------ |
  | 输入迭代器     | 只读，不写，单遍扫描，只能递增       |
  | 输出迭代器     | 只写，不读，单遍扫描，只能递增       |
  | 前向迭代器     | 可读写，多遍扫描，只能递增           |
  | 双向迭代器     | 可读写，多遍扫描，可递增递减         |
  | 随机访问迭代器 | 可读写，多遍扫描，支持全部迭代器运算 |

- 迭代器定义了一组公共操作，一些操作所有迭代器都支持，另一些只有特定类别的迭代器才支持。迭代器按照所提供的操作来分类，这种分类形成了一种层次，出了输出迭代器之外，一个高层类别的迭代器支持底层类别迭代器的所有操作

- C++标准指明了泛型和数值算法的每个迭代器参数的最小类别，向一个算法传递错误类别的迭代器很多编译器不会给出任何警告

- 5类迭代器：

  - 输入迭代器：可以读取序列中的元素，一个输入迭代器必须支持

    - 用于比较两个迭代器的相等和不相等运算符
    - 用于推进迭代器前置和后置递增运算符
    - 用于读取元素的解引用运算符，解引用只出现在赋值运算符的右侧
    - 箭头运算符

    输入迭代器只用于顺序访问，对于一个输入迭代器，*it++保证是有效的，但递增它可能导致所有指向其他流的迭代器失效，不能保证输入迭代器的状态可以保存下来并用来访问元素，所以只能用于单遍扫描算法。istream_iterator属于输入迭代器

  - 输出迭代器：可以看做输入迭代器的补集，一个输出迭代器必须支持

    - 用于推进迭代器的前置和后置递增运算符
    - 解引用运算符，解引用只出现在赋值运算符的左侧

    只能向一个输出迭代器赋值一次，类似于输入迭代器，只能用于单边扫描算法。用作目的位置的迭代器通常是输出迭代器。ostream_iterator属于输出迭代器

  - 前向迭代器：可以读写元素，只能在序列中沿一个方向移动，一个前向迭代器支持所有输入和输出迭代器的操作，可以多次读写同一个元素。因此可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。forward_list上的迭代器都是前向迭代器

  - 双向迭代器：可以正向/反向读取序列中的元素，除了支持所有前向迭代器的操作，还支持前置和后置递减运算符，除了forward_list外，其他标准库都提供符合双向迭代器要求的迭代器

  - 随机访问迭代器：提供在常量时间内访问序列中任意元素的能力，此类迭代器支持双向迭代器的所有功能，还支持：

    - 用于比较两个迭代器相对位置的关系运算符（<、<=、>、>=）
    - 迭代器和一个整数值的加减运算，计算结果为迭代器在序列中前进或后退给定整数个元素后的位置
    - 用于两个迭代器上的减法运算，得到两个迭代器的距离
    - 下标运算符（iter[n]和*(iter[n])等价）

    array、deque、string和vector的迭代器都是随机访问迭代器，访问内置数组元素的指针也是

**算法形参模式**

- 大多数算法具有如下4种形式之一：

  - alg(beg, end, other args);

  - alg(beg, end, dest, other args);
  - alg(beg, end, beg2, other args);
  - alg(beg, end, beg2, end2, other args);

  alg表示算法名，beg和end表示输入范围，几乎所有算法都接受一个输入范围，dest表示目的位置，beg2和end2指定第二个范围

- dest参数是一个表示算法可以写入的目的位置的迭代器，基本上是输出迭代器，其假定目标空间足够容纳写入的数据

- 接受单独beg2作为第二个输入范围的手元素也假定开始范围与beg和end表示的范围至少一样大

**算法命名规范**

- 接受谓词参数来代替<或==的算法以及不接受额外参数的算法通常是重载函数，一个版本使用类型默认的比较运算符，另一个版本使用谓词
- 接受一个元素值的算法通常有一个不同名的版本，该版本接受一个谓词来代替元素值，这种算法后面多一个_if后缀
- 对元素进行重排的算法提供将改变后的元素写到另一个序列的不同名算法，该算法会多一个目的位置的参数，算法名后多一个_copy
- 一些算法同时提供\_copy和\_if，后缀为_copy\_if，这些函数比原版多一个目的位置和谓词参数

### 10.6 特定容器算法

- 链表类型list和forward_list定义了几个成员函数形式的算法，定义了独有的sort、merge、remove、reverse。通用版本的算法可以用于链表，但代价太高，他们需要真正交换链表中的元素

- 链表类型特有成员函数版本算法

  | 算法                  | 描述                                                         |
  | --------------------- | ------------------------------------------------------------ |
  | lst.merge(lst2)       | 将lst2的元素合并到lst，两个序列都必须是有序的，元素将从lst2中删除。 |
  | lst.merge(lst2, comp) | 同上，但是使用给定的比较操作进行比较                         |
  | lst.remove(val)       | 调用erase删除掉与给定值相等的每个元素                        |
  | lst.remove_if(pred)   | 调用erase删除掉使一元谓词返回正数的每个元素                  |
  | lst.reverse()         | 反转lst中的元素的顺序                                        |
  | lst.sort()            | 使用<比较操作排序元素                                        |
  | lst.sort(comp)        | 使用给定的比较操作排序元素                                   |
  | lst.unique()          | 调用erase删除同一个值的连续拷贝                              |
  | lst.unique(pred)      | 调用erase删除使二元谓词返回正数的值的连续拷贝                |

  这些算法都返回void

  链表特有版本和通用版本的区别是前者会改变底层的容器，会真正的删除元素，而通用版本不能操作底层容器

- 链表类型定义了特有的splice算法：

  | 形参列表        | 描述                                                         |
  | --------------- | ------------------------------------------------------------ |
  | (p, lst2)       | p是指向lst中元素的迭代器或指向flst的首前迭代器，函数将lst2的所有元素移动到lst中p之前的或者flst中p之后的位置，lst2的类型必须和lst相同，且不能是同一个链表 |
  | (p, lst2, p2)   | p2是一个指向lst2中位置的有效爹地阿奇，将p2指向的元素移动到lst中，或将p2之后的元素一用到flst中，lst2可以是lst相同的链表 |
  | (p, lst2, b, e) | b和e必须表示lst2中的合法范围，将给定范围中的元素从lst2移动到lst中p之前或flst中p之后的位置，lst2和lst可以是相同的链表，但p不能指向b和e范围中的元素 |