- 关联容器支持高效的关键词查找和访问，两个主要的关联容器是map和set

- 类型map和multimap定义在头文件map中，set和multiset定义在头文件set中，无序容器则定义在头文件unordered_map和unordered_set中

- | 类型                         | 描述                           |
  | ---------------------------- | ------------------------------ |
  | **按关键字有序排序保存元素** |                                |
  | map                          | 关联数组，保存键值对           |
  | set                          | 关键字即值，只保存关键字的容器 |
  | multimap                     | 关键字可重复出现的map          |
  | multiset                     | 关键字可重复出现的set          |
  | **无序集合**                 |                                |
  | unordered_map                | 用哈希函数组织的map            |
  | unordered_set                | 用哈希函数组织的set            |
  | unordered_multimap           | 用哈希函数组织的multimap       |
  | unordered_multiset           | 用哈希函数组织的multiset       |

### 11.1 使用关联容器

- map类型通常被称为关联数组，与一般的数组类似，只是下标可以通过关键字而不是位置来查找值。map使用pair模板的first成员保存关键字，使用second成员保存值

  set类型就是关键字的集合

- 关联容器也是模板，定义一个关联容器必须指定其类型，且可以对其进行列表初始化

### 11.2 关联容器概述

- 关联容器都支持普通容器操作，不支持顺序容器的位置相关的操作，因为关联容器中的元素是根据关键字存储的，这些操作对关联容器没有意义。也不支持构造函数和插入函数中接受一个元素值和一个数量值的操作
- 关联容器的迭代器都是双向的

**定义关联容器**

- 每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器所需的类型
- 容器map和set中的关键字必须是唯一的，multimap和multiset没有这个限制

**关键字类型的要求**

- 对于有序容器，关键字类型必须定义元素的比较方法，默认情况下使用的是关键字类型的<运算符来的进行比较

- 可以用自己定义的操作替代关键字的<运算符，所提供的操作必须在关键字上是严格弱序，也就是"<"。这个比较函数必须具备以下基本性质：

  - 两个关键字不能同时"小于"对方
  - 如果k1<k2，k2<3，那么必须k1<k3
  - 如果存在两个关键字，两个都不“小于”另外一个，那么这两个关键字是“等价”的，如果k1==k2，k2==k3，那么必须k1==k3

  自定义操作要写在尖括号中的类型后面

**pair类型**

- pair是定义在头文件utility中的标准库容器，他是一个模板

- pair上的操作

  | 操作                       | 描述                                                         |
  | -------------------------- | ------------------------------------------------------------ |
  | pair<T1, T2> p;            | p是一个pair，两个类型分别是T1和T2的成员进行了值初始化        |
  | pair<T1, T2> p(v1, v2);    | p是一个pair，两个类型分别是T1和T2的成员分别初始化为v1，v2    |
  | pair<T1, T2> p = {v1, v2}; | 同上                                                         |
  | make_pair(v1, v2)          | 返回一个用v1和v2初始化的pair，其类型通过v1和v2推断           |
  | p.first                    | 返回p的first公有数据成员                                     |
  | p.second                   | 返回p的second公有数据成员                                    |
  | p1 relop p2                | 关系运算符（<、<=、>、>=），先比较first成员，如果first成员相等再比较second。其利用元素的<实现 |
  | p1 == p2                   | 当first和second都相等时，两个pair相等                        |
  | p1 != p2                   | 当first和second有一个不等时，两个pair不等                    |

### 11.3 关联容器操作

- 除了容器基本提供的类型，关联容器额外的类型别名

  | 类型        | 描述                                                         |
  | ----------- | ------------------------------------------------------------ |
  | key_type    | 此容器类型的关键字类型                                       |
  | mapped_type | 每个关键字                                                   |
  | value_type  | 对于set，与key_type相同。对于map，为pair<const key_type, mapped_type> |

- 不能改变map中键的值，但能改变值的值

- 虽然set类型同时定义了iterator和const_iterator类型，但两种类型都只允许只读访问set中的元素

- 通常不对关联容器使用泛型算法，关键字是const意味着不能将关联容器传递给修改或重排元素的算法，因为这类算法需要向元素写入值

- 关联容器可用于只读元素的算法，但是很多这类的算法都要搜索序列，由于关联容器中的元素不能通过他们的关键字进行快速查找（我认为是不能快速顺序查找），因此对其使用泛型搜索算法几乎总是个坏主意。

- 关联容器定义了一个名为find的成员，通过关键字直接获取元素

- 在实际编程中，要对关联容器使用算法，要么将它当作一个原序列，要么当作一个目的位置

**添加元素**

- 由于map和set以及对应的无序类型包含不重复的关键字，因此插入一个已有的元素对容器没有任何影响

- 关联容器的插入操作

  | 操作               | 描述                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | c.insert(v)        | v是value_type类型对象，对于map和set，当元素关键字不在c中时才根据v构造一个元素，函数返回一个pair，包含一个迭代器指向具有指定关键字的元素以及bool值表示插入是否成功。对于multimap和multiset，总会根据v构造一个元素，返回一个指向新元素的迭代器 |
  | c.emplace(args)    | 对于map和set，当元素关键字不在c中时才根据args构造一个元素，函数返回一个pair，包含一个迭代器指向具有指定关键字的元素以及bool值表示插入是否成功。对于multimap和multiset，总会根据args构造一个元素，返回一个指向新元素的迭代器 |
  | c.insert(b, e)     | 给定一个c::value_type类型值的范围b、e，将值插入到c中，是否插入和单个一样，函数返回void |
  | c.insert(il)       | 给定一个c::value_type类型值的列表il，将值插入到c中，是否插入和单个一样，函数返回void |
  | c.insert(p, v)     | 类似insert(v)，从迭代器p开始搜索新元素的存储位置，返回一个迭代器，指向具有给定关键字的元素 |
  | c.emplace(p, args) | 类似emplace(args)，从迭代器p开始搜索新元素的存储位置，返回一个迭代器，指向具有给定关键字的元素 |

**删除元素**

- 关联容器有三个版本的erase

  第一个版本接受一个迭代器删除一个元素

  第二个版本接受一个范围，删除范围中的元素

  第三个版本接受一个key_type的参数，删除所有匹配关键字的元素，返回实际删除的元素数量，对于保存不重复关键字的容器，erase的返回值总是0和1

**map的下标操作**

- map和unordered_map提供了下标运算符和对应的at函数，set类型和multimap相关类型不支持。
- 如果关键字不在map中，会为该关键字创建一个值插入到map中，并进行值初始化。由于下标操作可能插入一个新元素，所以只能对非const的值进行下标操作
- at函数对应的关键字不在容器中则会抛出out_of_range异常

- 当对一个map对象进行下标操作时，会获得一个mapped_type对象，而对map迭代器解引用会获得value_type对象，两者不同，但其他容器解引用和下标操作获得的类型相

**访问元素**

- 关联容器查找元素的操作

  | 操作             | 描述                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | c.find(k)        | 返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，返回尾后迭代器 |
  | c.count(k)       | 返回关键字等于k的元素的数量，对于不允许重复的容器返回值永远是0或1 |
  | c.lower_bound(k) | 返回一个迭代器，指向第一个关键字大于等于k的元素，若k不存在，返回尾后迭代器 |
  | c.upper_bound(k) | 返回一个迭代器，指向最后一个关键字大于等于k之后的元素，若k不存在，返回尾后迭代器 |
  | c.equal_range(k) | 返回一个迭代器pair，表示关键字等于k的元素范围，若k不存在，pair的两个成员均等于大于k元素之前位置的迭代器 |

- 对于不允许重复关键字的容器，find和count的区别不大，对于允许重复关键字的容器，count会做更多的工作，如果不需要技术，最好使用find

- 仅想知道一个给定关键字是否在容器中，使用find而非下标运算符

- 当lower_bound和upper_bound返回同一个迭代器，则关键字不在容器中 

### 10.4 无序容器

- C++11定义了4个无序关联容器，这些容器使用哈希函数和关键字类型的==运算符

- 除了哈希管理操作之外，无序容器提供了与有序容器相同的操作，因此通常可以将两者替换成对应的容器

- 无序容器在存储上组织为一组桶，每个桶保存0个或多个元素，使用哈希函数将元素映射到桶，当访问一个元素时，首先计算元素的哈希值，指出应搜索哪个桶

- 对于相同的参数，哈希函数必须总是产生相同的结果，理想情况下，哈希函数能将每个特定的值映射到唯一的桶，但是将不同关键字的元素映射到相同的桶也是允许的，当一个桶保存多个元素时，需要顺序搜索来找到目标元素。通常情况下，计算哈希值和在桶中搜索很快，但一个桶保存了很多元素，查找一个特定元素就需要大量比较操作

- 无序容器的管理操作

  | 操作                   | 描述                                                         |
  | ---------------------- | ------------------------------------------------------------ |
  | **桶接口**             |                                                              |
  | c.bucket_count()       | 正在使用的桶的数目                                           |
  | c.max_bucket_count()   | 容器能容纳的最多的桶的数量                                   |
  | c.bucket_size(n)       | 第n个桶中有多少个元素                                        |
  | c.bucket(k)            | 关键字为k的元素在哪个桶中                                    |
  | **桶迭代**             |                                                              |
  | local_iterator         | 可以用来访问桶中元素的迭代器类型                             |
  | const_local_iterator   | 桶迭代器的const版本                                          |
  | c.begin(n)，c.end(n)   | 桶n的首元素迭代器和尾后迭代器                                |
  | c.cbegin(n)，c.cend(n) | 桶n的const首元素迭代器和尾后迭代器                           |
  | **哈希策略**           |                                                              |
  | c.load_factor()        | 每个桶的平均元素数量，返回float                              |
  | c.max_load_factor()    | 容器试图维护的平均桶的大小，返回float值。容器会在需要时添加新桶，使得load_factor<=max_load_factor |
  | c.rehash(n)            | 重组存储，使得bucket_count>=n且bucket_count>size/max_load_factor，即桶的数目要大于n又要满足桶按平均桶的大小能存下所有元素 |
  | c.reserve(n)           | 重组存储，使得容器可以保存n个元素且不必rehash                |

- 无序容器使用一个hash<key_type>类型的对象为每个元素生成hash值。
- 标准库为内置类型包括指针提供了hash模板，还为一些标准库类型，包括string和只能指针类型定义了hash，所以可以直接定义关键字是内置类型、string和智能指针的无序容器
- 不能直接定义关键字类型为自定义类型的无序容器，也不能直接使用hash模板，必须提供自己的hash模板版本