- C++内存空间

  - 静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量

  - 栈内存用来保存定义在函数内的非static对象。在一个进程中，位于用户虚拟地址空间顶部是用户站， 编译器用来实现函数调用

  - 每个程序都拥有一个内存池，被称为自由空间或堆，程序用堆来存储动态分配的对象，当动态对象不再使用时，必须显式的销毁他们

  - 文字常量区用来存储常量字符串，程序结束后由系统释放
  - 程序代码区存放函数体的二进制代码

  分配在静态或栈内存中的对象由编译器自动创建和销毁，堆中的对象由程序员管理

- 堆和栈的区别：

  - 栈由编译器自动管理，堆由程序员控制
  - 在堆中频繁的创建释放会造成内存空间的不连续，从而造成大量碎片，使程序效率降低。对栈来说不会
  - 对堆来说生长方向向上，内存地址增加，栈相反向下
  - 栈是计算机系统提供的数据结构，操作系统在底层对栈提供支持，分配专门寄存器存放栈的地址，压栈出栈有专门指令执行，而堆是由C/C++函数库提供，栈的效率更高

- 堆和自由存储区的区别：

  - 自由存储区是C++特有的概念，C中没有，是通过new分配内存的抽象概念，在自由存储区分配对象可以在不立即初始化的情况下分配内存，在不立即释放内存的情况下销毁，在对象生存期外，可以通过void *访问和操作，但原对象的非静态成员或成员函数不能访问和操作。自由存储区在使用默认的new是在堆上，但可以自己分配一个内存池来实现
  - 堆是一个操作系统划分的区域，C语言中的内存分配放在堆上

### 12.1 动态内存与智能指针

- new在动态内存中为对象分配空间并返回一个指向该对象的指针，可以选择对对象进行初始化

- delete接受一个动态对象的指针，销毁该对象，并释放与之关联的内存

- C++11提供了两种智能指针和一个伴随类，三者都定义在头文件memory中：

  shared_ptr允许多个指针指向同一个对象

  unique_ptr“独占”所指向的对象

  weak_ptr是一种弱引用，指向shared_ptr所管理的对象

- 智能指针也是模板

- 两个智能指针都支持的操作：

  | 操作               | 描述                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | shared_ptr\<T\> sp | 空智能指针，可以指向类型T的对象                              |
  | unique_ptr<T\>up   | 空智能指针，可以指向类型T的对象                              |
  | p                  | 将p作为条件判断，若指向一个对象则返回true                    |
  | *p                 | 解引用p                                                      |
  | p->mem             | 解引用调用mem                                                |
  | p.get()            | 返回p中保存的指针，若指针释放了对象，返回的指针指向的对象也消失了 |
  | swap(p, q)         | 交换p和q的指针                                               |
  | p.swap(q)          | 交换p和q的指针                                               |

**shared_ptr类**

- shared_ptr独有的操作：

  | 操作                  | 描述                                                         |
  | --------------------- | ------------------------------------------------------------ |
  | make_shared<T\>(args) | 返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化对象，其调用类型的构造函数来构造。定义在memory中 |
  | shared_ptr<T\>p(q)    | p是一个shared_ptr q的拷贝，此操作会递增q的计数器，q的指着您必须能转换为T* |
  | p = q                 | p和q都是shared_ptr，所保存的指针必须能相互转换，次操作会递减p的引用计数，递增q的引用计数 |
  | p.unique()            | 若p.use_count()为1，返回true，否则返回false                  |
  | p.use_count()         | 返回与p共享对象的智能指针数量，主要用于调试，可能很慢        |

- 当进行拷贝和赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同对象，其有一个关联的计数器，称为引用计数

- shared_ptr自身的析构函数会递减所指向对象的引用计数，当计数变为0，shared_ptr就会调用对象的析构函数，并且释放占用的内存

- 程序使用动态内存有三种原因：

  - 程序不知道自己需要使用多少对象
  - 程序不知道所需对象的准确类型
  - 程序需要在多个对象间共享数据

**直接管理内存**

- 在自由存储空间分配的内存时无名的，因此new无法为其分配对象名，而是返回一个指向对象的指针。

- 默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值是未定义的，而类类型对象将用默认构造函数进行初始化

- 可以使用直接初始化方式、构造方式和列表初始化来初始化一个动态分配的对象。也可以在类型名后面加上空括号进行值初始化。例int *ptr = new int();

  对于类类型来说，值初始化时没有意义的，在这情况下还是进行的默认初始化

- 若提供给了一个圆括号包围的初始化器，可以使用auto来推断想要分配的对象类型，但圆括号中只能有单一初始化器。auto ptr = new auto(obj);

- 一个动态分配的const对象必须进行初始化，对于拥有默认构造函数的类类型，可以隐式进行初始化，其他类型必须显式初始化

- 一旦一个程序用光了所有它可用的内存，new表达式就会失败，默认情况下，若new不能分配所要求的内存空间，会抛出一个bad_alloc类型的异常，在头文件new中

- 定位new表达式允许向new传递额外参数

- 若将nothrow传递给new，就是让new不抛出异常，若这个new不能分配内存，则会返回一个空指针，nothrow在头文件new中

  例：int *ptr = new (nothrow) int;

- delete执行两个动作：调用指向对象的析构函数，释放对应内存

- delete一个并非new分配的内存，或者将相同的指针释放多次行为是未定义的

- 通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象，也不能分辨一个指针指向内存是否被释放，对于这些delete表达式，大多数编译器都会通过，尽管是错误的

- 虽然一个const对象的值不能被改变，但它本身是可以被销毁的

- 在delete之后，指针就变成了空悬指针，指向一块曾经保存数据对象但现在已经无效的内存的指针

- 如果需要保留指针可以在delete之后将nullptr赋值给它，但对于其他指向该对象的指针也就变成了空悬指针

**shared_ptr和new结合使用**

- 可以使用new返回的指针初始化智能指针，接受指针参数的智能指针的构造函数是explicit的

- 默认情况下一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放关联对象，若要使用不指向动态内存的指针，必须提供自定义的操作代替delete

- 定义和改变shared_ptr的其他方法

  | 操作                    | 描述                                                         |
  | ----------------------- | ------------------------------------------------------------ |
  | shared_ptr<T\> p(q)     | p管理内置指针q指向的对象，q必须能转换成T*                    |
  | shared_ptr<T\> p(u)     | p从unique_ptr u接管了对象的所有权，u会置为空                 |
  | shared_ptr<T\> p(q, d)  | p接管了内置指针q所指向的对象的所有权，q必须能转换成T*类型，p将可调用对象d替换delete |
  | shared_ptr<T\> p(p2, d) | p是shared_ptr p2的拷贝，使用可调用对象d替换delete            |
  | p.reset()               | 若p是唯一指向对象的shared_ptr，reset会释放此对象             |
  | p.reset(q)              | 若p是唯一指向对象的shared_ptr，reset会将p指向q               |
  | p.reset(q, d)           | 若p是唯一指向对象的shared_ptr，reset会将p指向q，且使用可调用对象d替换delete |

- shared_ptr可以协调对象的析构，但仅限于shared_ptr类型的拷贝，所以推荐使用make_shared而不是new

- 当将一个通过内置指针临时构造的局部智能指针，块结束会释放掉智能指针，计数变成0，将会释放对应内存，那么内置指针就变成了空悬指针，get()返回的也是内置指针

**智能指针和异常**

- 若使用智能指针，即使程序块过早结束，也能保证在内存不需要时将其释放。而直接管理的内存是不会自动释放的
- 为了正确使用智能指针，必须坚持一些基本规范：
  - 不使用相同的内置指针初始化或reset多个智能指针
  - 不delete get()返回的指针
  - 不使用get()初始化或reset另一个智能指针
  - 若使用get()返回的指针，牢记当最后一个智能指针被销毁后内置指针就变为无效了
  - 如果使用智能指针管理的资源不是new分配的内存，要传递给它一个删除器

**unique_ptr**

- 定义一个unique_ptr时，要将其绑定到一个new返回的指针上，初始化unique_ptr必须采用直接初始化方式

- 由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝和赋值操作

- unique_ptr特有的操作

  | 操作                   | 描述                                                         |
  | ---------------------- | ------------------------------------------------------------ |
  | unique_ptr<T\> u       | 空unique_ptr，可以指向类型为T的对象，使用delete释放指针      |
  | unique_ptr<T, D\> u    | 空unique_ptr，可以指向类型为T的对象，使用类型为D的可调用对象释放指针 |
  | unique_ptr<T, D\> u(d) | 空unique_ptr，可以指向类型为T的对象，使用类型为D的可调用对象d释放指针 |
  | u = nullptr            | 释放u指向的对象，将u置为空                                   |
  | u.release()            | u放弃对指针的控制权，返回指针，并将u置空                     |
  | u.reset()              | 释放u指向的对象                                              |
  | u.reset(q)             | 令u指向内置指针q，释放u原指向的对象                          |
  | u.reset(nullptr)       | 将u置空，释放u原指向的对象                                   |

- 如果不用另一个智能指针来保存release返回的指针，程序就要负责资源的释放，不能直接调用release而不管

- 可以拷贝或赋值一个将要销毁的unique_ptr，例如从函数返回一个局部的unique_ptr

- 标准库的较早版本包含了一个名为auto_ptr的类，含有unique_ptr的部分特性，它不能在容器中保存auto_ptr也不能从函数返回，但标准库仍包含auto_ptr

**weak_ptr**

- weak_ptr是一种不控制所指向对象生存周期的只能指针，它指向由一个shared_ptr管理的对象，将一个weak_ptr绑定到一个shared_ptr对象不会改变其引用计数，一旦引用计数为0，就算weak_ptr指向该对象仍然会被释放

- weak_ptr的操作

  | 操作               | 描述                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | weak_ptr<T\> w     | 空weak_ptr，可以指向类型T的对象                              |
  | weak_ptr<T\> w(sp) | 与shared_ptr sp指向相同对象，T必须能转换成sp所指向的类型     |
  | w = p              | p可以是个shared_ptr或weak_ptr，赋值后p和w共享对象            |
  | w.reset()          | 将w置空                                                      |
  | w.use_count()      | 与w共享对象的shared_ptr的数量                                |
  | w.expired()        | 若w.use_count()为0返回true，否则返回false                    |
  | w.lock()           | 若expired为true，返回一个空shared_ptr，否则返回一个指向w的对象的shared_ptr |

- 由于weak_ptr所指向的对象可能不存在，所以不能直接通过weak_ptr访问对象，必须通过调用lock成员

### 12.2 动态数组

- C++提供两种一次分配一个对象数组的方法：

  - 第一种是通过另一种new表达式语法，new typename[]，分配并初始化一个对象数组
  - 另一种是标准库中allocator类，允许将分配和初始化分离，使用allocator比上一种通常会提供更好的性能和更灵活的内存管理能力

  大多数引用应该使用标准库容器而非动态分配的数组

**new和数组**

- 当使用new分配数组时，方括号内必须是整型，但不必是常量

- 使用new分配数组，得到的是一个数组元素类型的指针，而非一个数组类型的对象。所以不能对其使用begin、end以及范围for

- 对于new分配的数组也可以通过在之后在上圆括号进行值初始化，但不能在括号中给出初始化器，这意味着不能使用auto分配数组。

- 在C++11中也可以以使用列表初始化动态分配的数组，若列表中的数小于分配的大小，则对剩下的元素进行值初始化，若大于分配的大小，则抛出bad_array_new_length异常，定义在头文件new中

- 虽然不能创建大小为0的静态数组对象，但能创建大小为0的动态数组，该new表达式返回合法的非空指针，该指针相当于一个指向数组大小为0的尾后指针

- 释放动态数组需要在delete后面加上方括号，它指示编译器次指针指向对象数组的第一个元素。未使用方括号来释放动态数组时未定义的

- 标准库提供了一个可以管理new分配的数组的unique_ptr版本，为了使用unique_ptr管理动态数组，必须在方括号中的对象类型后面加上空方括号

- 当一个unique_ptr指向一个数组时，不能使用点和箭头成员运算符，可以使用下标来访问数组中的元素

- 指向数组的unique_ptr操作：

  | 操作                  | 描述                                                  |
  | --------------------- | ----------------------------------------------------- |
  | unique_ptr<T[]\> u    | u可以指向一个动态分配的数组，元素类型为T              |
  | unique_ptr<T[]\> u(p) | u指向内置指针p所指向的动态分配的数组，p必须能转换成T* |
  | u[i]                  | 返回u拥有的数组中位置i处的对象                        |

- shared_ptr不直接支持管理动态数组，若希望使用其管理，必须提供自己定义的删除器，且不会提供下标运算符，需要使用get()获取指针进而得到内置数组的元素

**allocator类**

- new将内存分配和对象构造组合在一起，delete将对象析构和内存释放组合到一起，这有时会造成不必要的浪费

- allocator类定义在头文件memory中，是一种模板，它提供一种类型感知的内存分配方法，分配的内存时原始的、未构造的

- allocator操作：

  | 操作                 | 描述                                                         |
  | -------------------- | ------------------------------------------------------------ |
  | allocator<T\> a      | 定义了一个名为a的allocator对象，可以为类型为T的对象分配内存  |
  | a.allocate(n)        | 分配一段原始的、未构造的内存，保存n个类型为T的对象           |
  | a.deallocate(p, n)   | 释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象。p必须是一个之前由allocate返回的指针，且n必须是p创建时所要求的大小，在调用此函数前，必须对每个在这块内存中创建的对象调用destory |
  | a,construct(p, args) | p必须是一个类型T*的指针，指向一块原始内存，args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象 |
  | a.destroy(p)         | p为T*类型的指针，对P指向的对象执行析构函数                   |

- 在早期版本中，construct只接受两个参数：指向创建对象位置的指针和一个元素类型的值，因此只能将一个元素拷贝到未构造空间中

- allocator算法，定义在memory中：

  | 算法                          | 描述                                                         |
  | ----------------------------- | ------------------------------------------------------------ |
  | unintialized_copy(b, e, b2)   | 从迭代器b和e指出的输入范围中拷贝元素到b2指定的未构造的原始内存中，b2指向的内存必须足够大。返回递增后的目的位置迭代器 |
  | unintialized_copy_n(b, n, b2) | 从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中         |
  | unintialized_fill(b, e, t)    | 在迭代器b和e指定的原始内存范围中创建对象，对象的值均为t      |
  | unintialized_fill_n(b, n, t)  | 从迭代器b指向的内存地址开始创建n个对象，b必须指向足够大的未构造的原始内存 |

  

