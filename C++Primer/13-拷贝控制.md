- 一个类通过定义五种特殊的成员函数来控制对象的拷贝、移动、赋值、销毁：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数。

  这些操作统称为拷贝控制操作

### 13.1 拷贝、赋值与销毁

**拷贝构造函数**

- 如果一个拷贝构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，这个构造函数是拷贝构造函数

- 虽然可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const引用。拷贝构造函数在几种情况下都会被隐式的使用，因此通常不应该是explicit的

- 合成拷贝构造函数用来阻止拷贝该类类型对象，一般情况下，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中

- 每个成员的类型决定了其如何拷贝，对类类型的成员，会使用其拷贝构造函数来拷贝，内置类型直接拷贝

- 当使用直接初始化时，实际上是要求编译器使用普通的函数匹配来选择提供的参数最匹配的构造函数

  拷贝初始化要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换

- 拷贝初始化通常使用拷贝构造函数完成，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成

- 拷贝初始化再如下情况发生：

  - 使用=定义变量
  - 将一个对象作为实参传递给一个非引用类型的形参
  - 从一个返回类型为非引用类型的函数返回一个对象
  - 从花括号列表初始化一个数组中的元素或是聚合类中的成员
  - 某些类类型还会对所分配的对象使用拷贝初始化，如初始化标准库容器或是调用其insert或push成员

- 拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型，避免陷入为了调用拷贝构造函数要拷贝实参，要拷贝实参又要调用拷贝构造函数的死循环

- 在拷贝初始化过程中，编译器可以跳过拷贝/移动构造函数，直接创建对象，但即使编译器略过了，在这个程序点上，拷贝/移动构造函数必须是存在且可以访问的。因为这是编译器的一个优化，可以少拷贝一遍，但如果不存在拷贝/移动构造函数则编译器不会对此进行优化

**拷贝赋值运算符**

- 重载运算符的本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成
- 拷贝赋值运算符接受一个与其所在类型相同类型的参数，并为了和运算符的含义不发生变化，会返回一个指向左侧运算对象的引用。要使用容器存储的类型必须返回左侧对象的引用
- 如果一个类未定义拷贝赋值运算符，编译器为生成合成拷贝赋值运算符，对于某些类，合成拷贝运算符用来禁止该类型对象的复制，如果不是出于此目的，会将右侧运算对象的每个非static成员逐个赋予左侧对象的对应成员

**析构函数**

- 析构函数释放对象使用的资源，并销毁对象的非static数据成员。它是类的一个成员函数，名字由波浪号接类名构成，没有返回值，也不接受参数，所以其不能被重载，一个类只能有一个析构函数

- 在析构函数中，首先执行函数体，然后按初始化顺序逆序销毁成员，这部分是析构阶段，隐式调用的，对于类类型调用其析构函数，对于内置类型，由于不存在析构函数，所以什么也不需要做

- 与普通指针不同，智能指针是类类型，所以具有析构函数

- 无论何时一个对象被销毁都会调用析构函数：

  - 变量在离开作用域被销毁
  - 当一个对象被销毁其成员被销毁
  - 容器被销毁时其元素被销毁
  - 对于动态分配的对象，当对指向它的应用delete运算符时被销毁
  - 对于临时对象，当创建其完整的表达式结束被销毁

  由于析构函数自动运行，所以无需担心何时分配资源

- 当指向一个对象的引用或指针离开作用域时，析构函数不会执行

- 当一个类未定义自己的析构函数时，编译器会定义一个合成的析构函数，对某些类，合成析构函数被用来阻止该类型对象被销毁，如果不是这种情况，其函数体为空

**三/五法则**

- 在C++11中，一个类可以定义一个移动构造函数和一个移动赋值运算符

- 原则：

  - 决定一个类是否要定义自定义版本你的拷贝控制成员时，首先确定这个类是否需要一个析构函数，若需要，则几乎肯定也会需要一个拷贝构造函数和拷贝赋值运算符。

    例如需要析构函数delete一个成员函数，但是若使用默认的拷贝构造函数，他们简单拷贝一个指针，使多个对象指向相同内存，当一个对象被析构，其他对象所指向的内存将变为无效，使用和析构这些拥有无效内存的对象将会出错

  - 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符，反之亦然。但需要拷贝构造函数和拷贝赋值运算符的不一定需要析构函数

**使用=default**

- 可以对具有合成版本的成员使用=deault要求编译器生成合成版本的成员，当用其修饰时，合成的函数将隐式声明为内联的，如果不希望合成的成员是内联函数，应该只对成员的类外定义使用=default

**阻止拷贝**

- 可以通过将拷贝构造函数和拷贝赋值函数定义为删除的函数来阻止拷贝，意味着虽然声明了他们，但不能以任何形式使用。通过在参数列表后加上=delete指出希望将其定义为删除的

- =delete必须出现在函数第一次声明的时候，一个默认的成员只影响为这个成员而生成的代码，因此=default直到斌一起生成代码时才需要，而编译器需要知道一个函数是删除的，以便禁止试图使用它的操作

- 虽然语法上允许将析构函数定义为删除的，但实际上不能这样做

  - 对于删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类型的临时变量
  - 如果一个类有某个成员的类型删除了析构函数，则不能定义该类型的变量或临时变量
  - 可以动态分配这种类型的对象，但是不能释放这些对象

- 对于某些类来说，编译器会将这些合成的成员定义为删除的：

  - 若类的某个成员的析构函数是删除的或不可访问的，则类的合成析构函数被定义为删除的
  - 若类的某个成员的拷贝构造函数或析构函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的
  - 若类的某个拷贝赋值运算符时删除的或不可访问的，或是类有一个const的以及引用成员，则类的合成拷贝复合运算符被定义为删除的
  - 若类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员且没有类内初始化器，或是类有一个const成员且没有类内初始化器，其类型未显示定义默认构造函数，则该类的默认苟傲函数被定义为删除的

  这些规则的含义是：若一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的

- 在C++11之前，类通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝，为了阻止友元和成员函数调用，将对其只声明不定义

  声明但不定义一个成员函数是合法的，对此只有一个例外。试图访问一个未定义的成员将导致链接时错误，通过这种方法，可以预先阻止任何拷贝该类型对象的企图

- 最好使用=delete而不应该声明为private的

### 13.2 拷贝控制和资源管理

- 通常，管理类外资源的类必须定义拷贝控制成员，因为这种类需要析构函数来释放资源
- 可以将拷贝操作定义为两种，使类的行为看起来想一个值或者像一个指针
- 对于一个复制运算符来说，一个好的方法是在销毁左侧运算对象资源前拷贝右侧运算符，以免右侧对象资源不存在发生错误
- 令一个类展现类似指针的行为的最好方法是使用shared_ptr管理类中的资源，如果希望直接管理资源，则不使用shared_ptr，设计自己的引用计数
- 引用计数的工作方式：
  - 出了初始化对象外，每个构造函数（拷贝构造函数出外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态
  - 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器，并且递增共享的计数器
  - 析构函数递减计数器，当计数器变为0，则析构函数释放状态
  - 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器
- 可以将计数器保存在动态内存中，当创建一个对象时，分配一个新的计数器，当拷贝或赋值对象时，拷贝指向计数器的指针

### 13.3 交换操作

- 如果类定义了自己的swap，则算法使用类自定义版本，否则使用标准库定义的swap。但一个类有自定义版本时，调用std::swap还是使用的标准库版本
- swap对于一个类并不是必要的，但对于分配了资源的类，定义swap是一个很重要的优化手段，使用指针来避免不必要的拷贝
- 对于每个swap的调用都应该是不加作用域限定的，在这种情况下，如果存在类型特定的swap版本，其匹配程度会由于std中定义的版本
- 定义swap的类通常用swap来定义赋值运算符，这是一种名为拷贝并交换技术，将左侧运算对象与赋值运算符函数的形参进行交换，即赋值运算符右侧的值会存入左侧对象，形参的值会保存在左侧运算对象的指针中，当函数执行完毕会自动销毁形参，这种代码是安全的

### 13.4 动态内存管理类

- 某些类需要在运行时分配可变空间带下，这种类通常可以使用标准库容器来保存其数据，但这个策略并不是对每个类都适用，某些类需要自己进行内存分配，这些类一般来说必须定义自己的拷贝烤制成员来管理所分配的内存

### 13.5 对象移动

- 在某些情况下，对象拷贝后立即就销毁了，使用移动而非拷贝对象会大幅度提升性能
- 标准库容器、string、shared_ptr类既支持移动也支持拷贝，IO类和unique_ptr类可以移动但不能拷贝

**右值引用**

- 为了支持移动操作，新标准引入了右值引用，其必须绑定到右值，也就是只能绑定到将要销毁的对象，使用&&来获得右值引用
- 右值引用也是某个对象的别名，可以将右值引用绑定到要求转换的表达式、字面常量或是返回值的表达式，但不能绑定到一个左值上，但左值引用不能绑定到这些将要销毁的对象上。
- 右值引用只能绑定要销毁的对象，且对象没有其他用户意味着使用右值引用的代码可以自由的接管所引用的对象的资源
- 返回非引用类型的函数，连同算术、关系、位以及后置递增/递减都生成右值
- 变量是左值，因此不能将一个右值引用直接绑定到一个变量上，即使这个变量是一个右值引用
- 可以通过C++11中的move函数来获得绑定到左值上的右值引用，该函数定义在头文件utility中。调用move相当于承诺除了对作为参数的对象进行赋值或销毁外，不再使用它，因为一个移动后的源对象是具有不确定状态的，可能导致严重错误
- 调用move的代码应使用std::move而不是move，这样可以避免潜在名字冲突

**移动构造函数和移动赋值运算符**

- 移动构造函数的第一个参数是该类类型的右值引用，任何额外的参数都必须有默认实参。其就是将静态内存的直接拷贝，而动态内存上的直接接管，再释放源对象对动态内存的控制（即赋值为nullptr，浅层拷贝），如果是堆上拷贝则会先分配内存，然后再将元素一个个复制过来（深层拷贝）

  左值引用会在函数结束后析构，会使指向的动态内存释放，所以需要使用右值引用

- 移动构造函数不分配任何新内存，所以移动操作通常不抛出异常。通过在参数列表后初始化列表开始的冒号前加上noexcept通知标准库不抛出任何异常，减少为了处理抛出异常的可能性而做的额外工作。必须在声明和定义中都指定noexcept。

  标准库容器能对异常发生时其自身的行为提供保障，如果想在容器中使用移动而不是拷贝，就得告诉容器移动过程中不会抛出异常

- 移动赋值运算符执行与析构函数和移动构造函数相同的工作，如果不抛出异常，应该标记为noexcept。先应检查是否是move返回自身的右值导致自赋值，然后释放已有的元素，再将右值引用中的元素移动过来

- 从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此在写移动操作时，必须保证移动后源对象进入一个可析构的状态

- 移动操作还必须保证对象仍然是有效的。一般来说对象有效就是指可以安全的为其赋予新值或者可以安全的使用而不依赖其当前值。另一方面，移动操作对移动后的源对象中留下的值没有任何要求，无法保证取其值有什么效果，因此程序不应该依赖于移动后的源对象

- 如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器不会为其合成移动构造函数和移动赋值运算符

- 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会合成移动构造函数或移动赋值运算符，编译器可以移动内置类型成员，如果一个成员是类类型，且该类具有对应的移动操作，编译器也能移动该成员

- 移动构造函数的删除：

  - 移动操作永远不会隐式定义为删除的函数，若显式的要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的

  - 移动构造函数被定义为删除的函数的条件是有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或未定义拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符情况类似
  - 若有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数被定义为删除的
  - 若有类成员是const的或是引用，则类的移动赋值运算符被定义为删除的

- 若类定义了一个移动构造函数或/和移动赋值运算符，则类的合成拷贝构造函数和拷贝赋值运算符被定义为删除的

- 若一个类既有拷贝构造函数又有移动构造函数，则使用普通的函数匹配原则来确定使用哪个构造函数，赋值操作情况类似

- 如果不存在移动构造函数，对于右值而言拷贝构造函数仍然对其进行拷贝，但用拷贝构造函数代替移动构造函数几乎肯定是安全的，赋值情况类似，因为拷贝操作连源对象的值都不会改变

**移动迭代器**

- C++11定义了移动迭代适配器，其通过改变给定迭代器的解引用运算符的行为来适配此迭代器，且其解引用运算符生成的是一个右值引用
- 标准库的make_move_iterator的函数，接受一个迭代器参数，返回一个移动迭代器
- 移动迭代器支持正常的迭代操作，可以将一对移动迭代器传递给算法，但标准库不保证哪些算法适用移动迭代器，且移动一个对象可能销毁掉源对象，所以只要在确信算法在为一个元素赋值或者将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法

**右值引用和成员函数**

- 可以为一个成员函数同时提供拷贝和移动版本，一个版本指向const的左值引用，一个指向非const的右值引用，这是区分拷贝和移动的重载函数的方法，因为移动函数会窃取数据，不能定义为const的

- 通常可以在一个对象上调用成员函数，不管左值还是右值，甚至可以在右值上赋值。在旧标准中，没有方法阻止该使用方式，为了向后兼容，C++11仍然允许向右值赋值，若希望强制要求左侧运算对象是左值还是右值，可以在参数列表后面加一个引用限定符（类似于限定this是不是const），&和&&分别指出this可以指向一个左值或者右值。引用限定符必须同时出现在函数的声明和定义中。一个函数可以同时用const和引用限定，此情况下引用限定符必须跟在const后面

- 引用限定符也可以区分重载版本，可以综合引用限定符和const来区分一个成员函数的重载版本

- 如果定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符或者都不加

  例：int test()&&;		int test() const;		//错误，一个加了引用限定一个没加

