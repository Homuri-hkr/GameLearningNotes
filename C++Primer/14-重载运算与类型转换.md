### 14.1 基本概念

- 重载的运算符是具有特殊名字的函数：名字由关键字operator和其后要定义的运算符号共同组成，和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体
- 重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。对于又有一元又有二元的运算符来说，可以通过参数数量推断定义的是哪个运算符
- 对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递第二个参数
- 除了重载的函数调用运算符operator()之外，其他重载运算符不能有默认实参
- 如果一个运算符函数是成员函数，则它的第一个左侧运算对象绑定到隐式的this指针上，因此，成员运算符函数的显式参数数量比运算对象总是少一个
- 对于一个运算符函数来说，要么是类的成员要么至少含有一个类类型的参数。这一规定意味着当运算符作用域内置类型的运算对象时，无法改变该运算对象的含义
- 除了::、.*、.、?:运算符，其他运算符都可以重载
- 只能重载已有的运算符，无权发明新的运算符
- 对于一个重载的运算符来说，其优先级和结合律与对相应的内置运算符保持一致
- 可以使用运算符间接调用重载的运算符参数，也能直接使用operator加上运算符像调用普通成员那么显式调用
- 某些运算符指定了运算对象的求值的顺序，而重载的运算符本质上是一次函数的调用，所以求值顺序的规则无法应用到重载的运算符上，而且短路求值的属性也无法保留，所以比建议重载规定求值顺序的运算符
- 一般补充在逗号运算符和取地址运算符，因为C++语言已经定义了这两种运算符用于类类型对象时的特殊含义
- 若某些操作在逻辑上运算符相关，则适合定义为重载的运算符：
  - 若类执行IO操作，则定义移位运算符使其与内置类型的IO保持一致
  - 若类的某个操作检查相等性，则定义==运算符，若有了==运算符，则通常也有!=运算符
  - 若类包含一个内在的单序比较操作，则定义<，若定义了<运算符，则应该含有其他关系操作
  - 重载运算符的返回类型通常情况下应与其内置版本的返回类型兼容，逻辑运算符和关系运算符返回bool，算术运算符返回一个类类型的值，赋值运算符和复合赋值运算符返回左侧对象的引用
- 只有当操作的含义对于用户来说清晰明了时才使用运算符，若用户对运算符可能有几种不同的理解时不要定义
- 定义成员函数和普通的非成员函数的准则：
  - =、[]、()和->必须是成员
  - 复合赋值运算符一般来说是成员，但非必须
  - 改变对象状态的运算符或与给定类型密切相关的运算符，如++、--、解引用通常应该是成员
  - 具有对称性的运算符可能转换任意一端的运算对象，即可能在类类型可能在左侧可能在右侧，如算术、相等、关系和位运算符，通常是普通的非成员函数

### 14.2 输入输出运算符

- 与iostream标准库兼容的输入输出运算符必须是普通的非成员函数，否则运算符的左侧运算对象将是类成员

**重载输出运算符<<**

- 通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用，非常量是引用要向流中写东西，引用是因为IO对象不允许拷贝。第二个参数一般是一个类类型的常量引用。且为了保持一致，需要返回ostream形参引用
- 通常输出运算符应主要负责打印对象的内容而非控制格式，特别是换行符，这样可以使用户有权控制输出的细节

**重载输入运算符>>**

- 通常情况下，输入运算符的第一个形参时运算符将要读取的流的引用，第二个是将要被读入的非常量对象的引用，非常量是因为要将流中数据读到该对象中。返回istream形参引用

- 输入运算符必须处理输入可能失败的情况，而输出运算符不需要

- 执行输入运算符时可能发生的错误：

  - 当流含有错误类型的数据时读取操作可能失败
  - 当读取操作到达文件末尾或遇到输入流的其他错误时也会失败

  当读取操作发生错误时，输入运算符应负责从错误中恢复，应将对象置为可用状态（比如进行默认初始化），

- 一些输入运算符需要做更多数据验证工作，此时应由IO标准库自己来标识错误

### 14.3 算术和关系运算符

- 通常情况下，算术和关系运算定义成非成员函数以允许对左侧和右侧的运算对象进行转换，因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量引用。操作完成后返回运算后的副本作为结果
- 若类定义了算术运算符，则一般也会定义一个复合赋值运算符
- 若类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应使用复合赋值实现算术运算符

**相等运算符**

- 设计准则：
  - 若一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成operator==而非一个普通的函数
  - 若类定义了==，则该运算符应该能判断一组给定对象中是否含有重复的数据
  - 通常情况下，相等运算符应具有传递性
  - 若类定义了==，则也应该定义!=
  - ==和!=运算符中的一个应该把工作委托给另外一个

**关系运算符**

- 定义了相等运算符的类也常常包含关系运算符，特别是关联容器和一些算法要使用<运算符，所以定义operator<会非常有用

- 通常关系运算符需要定义一个顺序关系，而且类中若含有==运算符，则需定义一种关系使其与==保持一致，比如两者不相等，则其中一个要小于另外一个

### 14.4 赋值运算符

- 可以对赋值运算符定义列表初始化，operator=(initializer_list<T\> il)。这种初始化不用检查对象向自身赋值，因为该形参类型确保il和this所指的不是同一个对象

### 14.5 下标运算符

- 下标运算符通常以所访问元素的引用做返回值，这样下标运算可以出现在赋值运算符的任意一端。
- 最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保不会给返回的对象赋值

### 14.6 递增和递减运算符

- 定义递增和递减运算符的类应该同时定义前置版本和后置版本，且同传给你应该被定义成类的成员
- 为了和内置版本保持一致，前置运算符应该返回递增或递减后对象的引用
- 因为前置和后置版本使用的是同一个符号，为了解决这个问题，后置版本接受一个额外的不被使用的int型参数，当使用后置运算符时，编译器为这个形参提供一个值为0的实参。从语法上来说可以使用这个形参，但实际过程中不会这么做，这是形参的唯一作用是区分前置版本和后置版本
- 后置运算符应该返回对象的原值，返回的形式是一个值而非引用
- 若我们想通过函数调用的方式调用后置版本，则必须为它传递一个整型值

### 14.7 成员访问运算符

- obj->mem的执行过程：

  1. 若obj是指针，则应用内置的->运算符，解引用再获取指定成员
  2. 若obj是定义了->的类的对象，则使用obj.operator->()的结果获取mem，如果结果是一个指针，则执行第一步，如果结果含有operator->则重复该步骤，直到返回了一个指针或报错

  重载的箭头运算符不许返回类的指针或者自定了箭头运算符的某个类的对象

### 14.8 函数调用运算符

- 若类定义了调用运算符，则该类的对象成为函数对象

- 函数对象类除了operator()之外也可以包含其他成员，函数对象类通常含有一些数据成员，用于定制调用运算符中的操作

- Lambda是函数对象，当编写一个Lambda后，编译器将其翻译成一个未命名类的未命名对象

  默认情况下Lambda不能改变它捕获的变量，因此类中的函数调用调用运算符是一个const成员函数，若声明为可变的，则不是const的

  当使用引用捕获时，该类中不会存储该数据成员，若是值捕获，则为每个值捕获变量建立对应数据成员

  Lambda表达式产生的类不含默认构造函数、赋值运算符以及默认析构函数，是否含有默认的拷贝/移动构造函数则要视捕获的数据成员类型而定

**标准库定义的函数对象**

- 标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符

- 标准库函数对象：

  | 算术               | 关系                  | 逻辑                |
  | ------------------ | --------------------- | ------------------- |
  | plus\<type\>       | equal_to\<type\>      | logical_and\<type\> |
  | minus\<type\>      | not_equal_to\<type\>  | logical_or\<type\>  |
  | multiplies\<type\> | greater\<type\>       | logical_not\<type\> |
  | divides\<type\>    | greater_equal\<type\> |                     |
  | modulus\<type\>    | less\<type\>          |                     |
  | negate\<type\>     | less_equal\<type\>    |                     |

  都定义在functional头文件中

- 表示运算符的函数对象常用来替换算法中的默认运算符

- 标准库规定其函数对象对于指针也同样适用

**可调用对象与function**

- C++几种可调用对象：函数、函数指针、Lambda表达式、bind创建的对象以及重载了函数调用运算符的类

- 可调用的对象同样具有类型，且两个不同类型的可调用对象可能共享同一种调用形式。调用形式是指形参类型和返回类型

- 有时需要定义一个函数表用于存储指向这些可调用对象的“指针”，当程序需要执行某个特定操作时，从该表查找调用的函数。

- 虽然可以使用map来实现函数表，将一个函数指针作为值类型，但是类似于Lambda表达式这类具有自己的类型，不能使用具体类型的函数指针来表示

- C++11定义了function模板，在functional头文件中，用来解决函数形式相同但类型不同导致不能存在一起的问题

- function操作：

  | 操作                     | 描述                                                         |
  | ------------------------ | ------------------------------------------------------------ |
  | function<T\> f;          | 创建一个用来存储可调用对象的空function，可调用对象应于T的形式(retuType(argsType))相同 |
  | function<T\> f(nullptr); | 显式构造一个空function                                       |
  | function<T\> f(obj);     | 创建并构造一个调用对象obj的副本                              |
  | f                        | 当f含有可调用对象时为真，否则为假                            |
  | f(args)                  | 调用f中的对象                                                |
  | **类型**                 |                                                              |
  | result_type              | 在function类型的可调用对象返回的类型                         |
  | argument_type            | 当T有一个实参时定义的类型                                    |
  | first_argument_type      | 当T有两个参数时，第一个参数的类型                            |
  | second_argument_typeg    | 当T有两个参数时，第二个参数的类型                            |

- 使用function模板就可以将函数变为统一类型的可调用对象然后使用map建表

- 不能直接把重载函数的名字存入function类型的对象中，会造成二义性问题，可以用存储函数指针或使用一个Lambda来解决该问题

- function和以前的unary_function、binary_function没有关联，后两者已被更通用的bind取代

### 14.9 重载、类型转换与运算符

- 转换构造函数和类型转换运算符共同定义了类类型转换，有时称为用户定义的类型转换

**类型转换运算符**

- 类型转换运算符是类的一种特殊成员函数，负责将一个类类型转换成其他类型，形式为：operator type() const;

- 类型转换运算符可以面向的任意类型进行定义，只要该类型能作为函数的返回类型（除void外），因此不允许转换成数组和函数类型，但允许转换成指针或引用类型

- 类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数

- 类型转换运算符通常不应该改变待转换对象的内容，因此一般定义为const的

- 尽管编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以在其之前或之后，两者可以一起被使用

- 由于类型转换运算符是隐式执行的，所以无法给这些函数传递实参，也就不能在类型转换运算符的定义中使用任何形参

- 尽管类型转换函数不负责指定返回类型，但每个类型转换函数都会返回一个目标类型的值

- 类很少提供类型转换运算符，在大多数情况下，如果类型转换自动发生，用户可能会感觉以外而不是觉得帮助。但对于类来说，定义转换向bool类型的转换是比较常见的现象

- 在早期版本中，向bool类型的转换可能会引发意想不到的后果，例：int i=42; cin << i; 	//将cin转换成了bool值然后进行左移运算

  为了防止这种异常的发生，C++11引入了显式的类型转换运算符即在前面加入explicit。当类型转换运算符是显式时，必须通过显式的强制类型转换。该规定有一个例外，即表达式被用作条件，则编译器会将显式的类型转换自动应用于它。即出现以下情况时会这么使用：

  - if、while以及do语句条件部分
  - for语句的条件表达式
  - 逻辑非、逻辑或、逻辑与
  - 条件运算符的条件表达式

  向bool的类型转换通常用在条件部分，因此operator bool一般定义成explicit的

**避免有二义性的类型转换**

- 如果类中包含一个或多个类型转换，必须确保在类类型中和目标类型之间只存在唯一一种转换方式，否则编写的代码具有二义性。两种情况下可能会产生多重转换路径：

  - 两种类型互相提供了对方的类型转换。例如：A和B定义了互相的转换，void f(A)，此时调用f(B)，则无法判断调用f(A::operator B())还是f(B::operator A())，此时只能通过显式调用类型转换运算符函数才行，不能通过强制类型转换
  - 类定义了多种转换规则，但一些转换规则可以通过另一些转换规则的目标类型转换而来。最典型的例子是算术类型，定义了转换成int和double的转换，函数的形参时long double，产生二义性。或者A和B都能转换成int，然后有两个重载函数分别接受A和B类型的，传入参数时传入一个int，两个函数都能匹配，产生二义性。

  通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或是转换目标是算术类型的转换

- 如果在调用重载函数时需要使用构造函数或者强制类型转换来改变实参的类型，这通常意味着程序设计存在不足

**函数匹配与重载运算符**

- 重载的运算符也是重载的函数，因此通用的函数匹配规则同样适用于判断给定的表达式中到底应该使用内置运算符还是重载的运算符
- 当调用一个命名的函数时，具有该名字的成员函数和非成员函数不会彼此重载，因为调用命名函数的语法形式对于成员函数和非成员函数是不同的，当通过类类型的对象、引用和指针调用成员函数时，只考虑该类的成员函数。如果使用重载的运算符，无法判断使用的是成员还是非成员，因此两者都在候选函数集的范围内
- 若对一个类既提供了算术类型的类型转换，又提供了重载的运算符，则在使用重载运算符时出现二义性问题

