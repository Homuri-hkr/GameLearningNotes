### 15.1 OOP概述

- OOP的核心思想是数据抽象、继承和动态绑定。

  通过数据抽象可以实现接口与实现分离

  通过继承可以定义相似的类型并对其相似关系建模

  通过动态绑定，可以在一定程度上和忽略相似类型的区别，以统一方式使用它们的对象

- 派生类必须通过类派生列表明确指出是从哪个或哪些基类派生而来。派生列表形式是：:  访问说明符 基类[, 访问说明符 基类 ...]

- 派生类必须在其内部对所有重新定义的虚函数进行生命，可以在这样的函数之前加上virtual关键字，但不是非必须。C++11允许派生类显式的注明它将使用哪个成员函数改写基类的虚函数，在函数的形参类表后加上override关键字即可

- 在C++中，使用基类的引用或指针调用一个虚函数时将发生动态绑定

### 15.2 定义基类和派生类

**定义基类**

- 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作
- 基类必须将两种成员函数区分开：一种是基类希望派生类进行覆盖的函数，另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类通常定义为虚函数，任何构造函数之外的非静态版本都可以是虚函数。当使用指针或引用调用虚函数时，该调用将被动态绑定，根据绑定的对象类型的不同，该调用可能执行基类的版本或某个派生类的版本。
- 关键字virtual只能出现在类内部的声明语句之前，不能用于类外部的函数定义，如果基类把一个函数声明为虚函数，则该函数在派生类中也是隐式的虚函数
- 成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而非运行时

**定义派生类**

- 派生类经常覆盖它继承的虚函数，如果没有覆盖某个虚函数，则虚函数继承基类的版本
- 可以将基类的指针或引用绑定到派生类的对象的基类部分上，这种转换通常称为派生类到基类的类型转换，编译器会隐式执行此类转换
- 每个派生类控制自己部分的成员初始化过程，也必须使用基类的构造函数初始化基类部分
- 派生类默认初始化时时首先初始化基类部分，然后按照声明顺序依次初始化派生类成员
- 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义
- 声明派生类时不能包含派生列表，只用声明其类名即可
- 若想使用某个类作为基类，则该类必须已经定义而非仅仅是声明。这个规定防止了一个类从自身派生
- C++11使用在类名后加final关键字防止该类被继承

**类型转换与继承**

- 和内置指针一样，只能指针类也支持派生类向基类的类型转换
- 表达式的静态类型在编译时总是已知的，是变量声明时的类型或表达式生成的类型。动态类型则是变量或表达式表示内存中的对象类型，在运行时才可知
- 如果表达式不是引用和指针，则其动态类型永远与静态类型一致。比如一个基类的引用给其赋值一个子类对象，则其静态类型是基类引用，动态类型是子类
- 不存在基类向派生类的自动转换，即使一个基类指针或引用绑定到一个派生类对象上，也不能执行从基类像派生类的转换
- 编译器在编译时无法确定某个特定你的转换在运行时是否安全，因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法，如果在基类中含有一个或多个虚函数，可以使用dynamic_cast请求一个类型转换，该转换的安全检查将在运行时执行。若已知某个基类向派生类的转换是安全的，则可以使用static_cast
- 派生类想基类的自动类型转换只针对指针或引用类型有效，在派生类类型和基类类型之间不存在这种转换
- 类类型在赋值和初始化时都是调用的函数，当用一个派生类对象初始化或赋值一个父类对象时，基类部分会被拷贝、移动或赋值，派生类部分将会忽略。

### 15.3 虚函数

- 使用基类的引用或指针调用一个虚成员函数会执行动态绑定，直到运行时才知道用了哪个版本的虚函数，所以所有虚函数都必须有定义
- 通过一个非指针非引用类型的表达式调用虚函数时，在编译时就会将调用的版本确定下来
- 当在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字，但这么做并非必须
- 一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致，返回类型也必须匹配。但如果返回的是类本身的指针或引用时，可以使用派生类的类型
- 如果派生类定义了一个函数与基类中的虚函数的名字相同，但形参列表不同，编译器将认为新定义的函数与基类的函数是相互独立的，并没有覆盖掉基类版本
- C++11中可以使用override关键字来说明派生类中的虚函数
- 可以将函数指定为final，之后尝试覆盖该函数的操作将引发错误
- 虚函数也可以拥有默认实参，如果某次函数调用中使用了默认实参则该实参值由本次调用的静态类型决定
- 若希望对虚函数的调用不进行动态绑定，而是强迫其执行虚函数的某个特定版本，通过在调用时函数名前加上作用域即可实现。通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来会币虚函数的机制

### 15.4 抽象基类

- 一个纯虚函数无须定义，通过在函数体的位置书写=0即可将一个虚函数说明为纯虚函数，其中=0只能出现在类内部的虚函数声明语句处
- 可以为一个纯虚函数提供定义，定义必须在类的外部
- 含有或者未经覆盖直接继承纯虚函数的类是抽象基类，抽象基类负责定义接口，后续的其他类可以覆盖该接口，不能直接创建一个抽象基类的对象
- 重构负责重新设计类的体系以便将操作或数据从一个类移动到另一个类中，对于面向对象的应用程序来说 ，重构是一种普遍现象

### 15.5 访问控制与继承

- 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中的受保护成员没有任何访问特权

- 假定B继承自A：

  - 只有当B公共继承A时，用户代码才能使用派生类向基类的转换，否则不能转换
  - 不论B以什么方式继承A，B的成员函数和友元都能使用派生类向基类的转换
  - 如果B继承A的方式是公有或受保护的，则B的派生类的成员和友元可以使用B向A的转换，否则不能使用

- 友元关系不能被继承，当一个类将另一个类声明为友元时，友元关系只对做出声明的类有效，对于原来那个类来说，其友元的基类或者派生类不具有特殊访问能力

- 当需要改变派生类继承的某个成员的访问级别时，在派生类对应访问说明符范围内使用using声明加上对应成员名

  例如：class B : private A{public: using A::funname;}

  派生类只能为能访问的名字提供using声明

### 15.6 继承中的类作用域

- 派生类的作用域嵌套在其基类的作用域之内，若一个名字在派生域中无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义
- 一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的，即使静态类型与动态类型可能不一致。
- 派生类也能重定义再其直接基类或间接基类的名字，此时定义在派生类（内层作用域）的名字将隐藏定义在基类（外层作用域）的名字
- 可以通过作用域运算符来使用一个被隐藏的基类成员
- 名字查找与继承，调用obj->mem()或obj.mem()的步骤：
  1. 首先确定obj的静态类型，因为在调用成员函数，该类型必须是类类型
  2. 在obj对应的静态类型中查找mem，若找不到一次在直接基类中不断查找直到到达继承链的顶端，若仍找不到则报错
  3. 一旦找到了mem，就进行常规类型检查以确认本次调用是否合法
  4. 若调用合法，且通过引用或指针调用，mem是虚函数，则编译器依据对象的动态类型确定执行的版本。若不是虚函数或者不是使用指针、引用调用则进行常规函数调用
- 定义在派生类的函数不会重载基类中的成员，若与基类的某个成员同名，则在其作用域内隐藏该基类成员，即使派生类成员和基类成员的形参列表不一致
- 成员函数无论是否是虚函数都能被重载， 派生类可以覆盖重载函数的0个或多个实例，如果派生类希望所有的重载版本对它来说都是可见的，则需要覆盖所有版本或一个都不覆盖
- 有时一个类仅需覆盖重载集合中一些而非全部函数，一种好的解决方法是为重载的成员提供一条using声明，其指定名字而不指定形参列表，一条声明就可以搞定

### 15.7 构造函数与拷贝控制

**虚析构函数**

- 基类通常应该定义一个虚析构函数，这样可以动态分配继承体系中的对象
- 一个基类总是需要析构函数，而且能将虚构函数设定为虚函数，无法由此推断该基类是否还需要赋值运算符或构造函数
- 虚析构函数还能让编译器不为该基类和继承类中不合成移动操作

**合成拷贝控制与继承**

- 基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或者析构函数类似，对于类本身的成员依次进行初始化、赋值或销毁操作，合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁。不管是自定义还是合成的都行，唯一的要求是对应的成员可以访问，且不是一个删除的
- 某些定义基类的方式也可能导致有的派生类成员成为被删除的函数：
  - 若基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者是不可访问，则派生类中对应的成员将是被删除的
  - 若在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是删除的
  - 编译器不会合成一个删除掉的移动操作，当使用=default请求一个移动操作时，若基类中的对应操作或析构函数是删除或不可访问的，那么派生类中该函数是被删除的
- 若确实需要执行移动操作时应该首先在基类中定义

**派生类的拷贝控制成员**

- 派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员，派生类赋值运算符也必须为其基类部分和成员赋值
- 析构函数只负责销毁派生类自己分配的资源，基类部分由基类的析构函数销毁
- 派生类的赋值运算符必须显式的为其基类部分赋值
- 若构造函数或析构函数调用了某个虚函数，则应该执行与构造函数或析构函数所属类型相对应的虚函数版本

**继承的构造函数**

- 在C++11中，派生类能够重用其直接基类定义的构造函数
- using声明作用于构造函数时将令编译器产生代码，对于基类的构造函数，编译器都生成一个与之对应的派生类构造函数，该构造函数将基类对应的参数传递给基类的构造函数，若派生类含有自己的成员则进行默认初始化
- 对构造函数的using声明不会改变该构造函数的访问级别
- 一个using声明语句不能指定explicit或constexpr，若类的构造函数时explicit或constexpr的，则继承的构造函数也拥有相同属性
- 当一个基类构造函数含有默认实参，这些实参并不会被继承，派生类将获得多个继承的构造函数，其中每个构造函数分别从一个不省略到依次从左往右省略掉一个含有默认实参的形参，最后全都省略
- 若基类含有几个构造函数，则除了两个例外情况，大多数时派生类会继承所有这些构造函数，例外如下：
  - 派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本，若派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数不会被继承
  - 不能继承默认、拷贝和移动构造函数，若派生类没有直接定义这些函数，编译器将为派生类合成

### 15.8 容器与继承

- 当使用容器存放继承体系中的对象时，通常必须采用间接存储的方式，即存放基类的指针，防止继承类转换成基类把继承类自己的部分舍掉