### 18.1 异常处理

- 在C++语言中，通过抛出一个表达式来引发一个异常，被抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码将被用来处理该异常，被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码
- 当执行一个throw时，跟在throw后面的语句将不再被执行，程序的控制权从throw转移到与之匹配的catch模块
- 当throw出现在一个try语句块内时，检查与该try块关联的catch子句，若找到了匹配的catch，就是用该catch处理异常，若这一步没找到匹配的catch且该try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句，若还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找。这个过程被称为栈展开
- 若没找到匹配的catch子句，程序将调用标准库函数terminate，终止程序的执行过程
- 在栈展开的过程中，位于调用链上的语句块可能会提前退出，编译器将负责确保在这个块中创建的对象能被正常销毁，若局部对象为类类型对象，则该对象的析构函数将被调用。
- 在类的析构函数中，不应该抛出异常，若在析构函数处理可能抛出异常，应该使用try块将其包围起来，并在函数中得到解决，若析构函数没有捕获到一个异常，则程序将被终止
- 异常对象是一种特殊对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化，因此thorw语句中的表达式必须拥有完全类型，而且如果该表达式是类类型的话，则相应的类必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数，若该表达式是数组类型或函数类型，则表达式将被转换成对象的指针类型
- 异常对象位于编译器管理的空间中，编译器确保无论最终调用的是哪个catch字块都能访问该空间，当异常处理完毕后，异常对象被销毁
- 抛出指向局部对象的指针几乎肯定是一种错误行为，从函数中返回指向局部对象的指着也是错误的
- 当抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型，若抛出解引用的基类指针，而该指针指向的实际对象是派生类对象，则抛出的对象将被切掉一部分，只有基类部分被抛出

**捕获异常**

- 声明的类型决定了处理代码所能捕获的异常声明，这个类型必须是完全类型，可以是左值引用，但不能是右值引用

- 当进入一个catch语句后，通过异常对象初始化异常声明中的参数，若catch的参数类型是非引用类型，则该参数是异常对象的一个副本，若是引用类型则是异常对象的一个别名。若catch的参数是基类类型，则可以使用其派生类类型的异常对象对其进行初始化，该情况下，若不是引用类型，则会切掉派生类的那一部分

- 异常对象的静态类型决定catch语句所能执行的操作，若catch的参数是基类类型，则catch无法使用派生类的特有的任何成员

- 在搜寻catch的过程中，追踪找到的catch不一定是最佳匹配，而是第一个与异常匹配的，所以越是专门的catch越应该置于整个catch列表的前端

- 绝大多数的转换在catch的匹配中都不被允许，除了一些极细小的差别之外，要求异常的类型和catch声明的类型是精确匹配的：

  - 允许从非常量向常量的转换
  - 允许从派生类向基类的转换
  - 允许数组和函数向指针的转换

  包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配catch过程中使用

- 一条catch语句通过重新抛出的操作将异常传递给另外一个catch语句，只需要使用单独的throw不用包含其他表达式。

- 空的throw语句只能出现在cathc语句或catch语句直接或间接调用的函数之内，若在处理代码之外的区域遇到了空throw语句，编译器将调用terminate

- 一个重新抛出语句并不指定新的表达式，而是将当前的异常你对象沿着调用链向上传递

- 很多时候catch语句会改变其参数的内容，若在改变了参数内容后catch语句重新抛出异常，则只有是引用类型才会对参数做出的改变保留下来继续传播

- 为了一次性捕获所有异常，使用省略号作为异常声明，这样的处理代码称为驳货所有异常的处理代码，形如catch(...)，一条捕获所有异常的语句可以与任意类型的异常匹配

**函数try语句块与构造函数**

- 构造函数初始值列表抛出异常时，构造函数体内的catch语句还未生效，无法处理其抛出的异常。必须将构造函数写成函数try语句块的形式，也称函数测试块

- 函数try语句块使得一组catch语句既能处理构造函数体或析构函数体，也能处理构造函数的初始化过程或析构函数的析构过程

  例：

  ```C++
  MyClass::MyClass(int data) try:data(data){
  	//空函数体
  }catch(const std::bad_alloc &e){
  	//处理异常
  }
  ```

- 初始化构造函数参数时也可能发生异常，但其不属于函数try语句块的一部分，输入调用表达式的一部分，应在调用处处理

**noexcept异常说明**

- C++11中可以通过提供noexcept说明指定某个函数不会抛出异常，形式是关键字noexcept紧跟在函数的参数列表后面。对于一个函数来说，该声明要么出现在函数所有的声明语句和定义语句中，要么一次不出现
- 编译器并不会在编译时检查noexcept说明，实际上，若一个函数在说明了noexcept的同时又含有throw语句或者调用了可能抛出异常的其他函数，编译器将顺利编译通过，并不会因为这种违反异常说明的情况而报错
- 一旦一个noexcept函数抛出了异常，程序就会调用teminate以确保遵守不在运行时抛出异常的承诺
- 早期的C++版本是设计了一套更加详细的异常说明方案，该方案使得可以指定某个函数可能抛出的异常类型，函数可以指定一个关键字throw在后面跟上括号括起来的异常类型列表，位置与noexcept位置相同，若括号内没有参数，则与noexcept含义相同。该方案已在C++11中取消
- noexcept说明符接受一个可选的实参，该实参必须能转换成bool类型，若实参为true则函数不会抛出异常，若为false则可能抛出异常
- noexcept说明符的实参常常与noexcept运算符混合使用，noexcept运算符是一个一元运算符，返回值是一个bool类型的右值表达式，用于表示给定的表达式是否会抛出异常，noexcept不会求其运算对象的值。当运算对象做了不抛出说明且e本身不含有throw语句时返回true，否则返回false
- 尽管noexcept说明符不属于函数类型的一部分，但函数的异常说明仍然会影响函数的使用。函数指针及该指针所指的函数必须具有一致的异常说明，若为某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。若显式或隐式的说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数
- 若一个虚函数承诺了不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺，与之相反，若机内的虚函数允许抛出异常，则派生类的对应函数既可以允许也可以不允许抛出异常
- 当编译器合成拷贝控制成员时，同时也生成一个异常说明，若对所有成员和基类的所有操作都承诺不会抛出异常，则合成的成员是noexcept的，若合成成员调用的任意一个函数可能抛出异常，则合成的成员是noexcept(false)。若定义了一个析构函数但是没有为它提供异常说明，则编译器合成一个，合成的异常说明将于假设由编译器为类合成析构函数时所得的异常说明一致

**异常类层次**

- ![image-20210115223950155](C:\Users\A\AppData\Roaming\Typora\typora-user-images\image-20210115223950155.png)

- 类型exception仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为what的虚成员。其中what函数返回一个const char*，该指针指向一个以空字符结尾的字符数组，并且确保不会抛出任何异常，其负责返回用初始化异常对象的信息
- 类exception、bad_cast和bad_alloc定义了默认构造函数，但是有一个可以就收C风格字符串或者彼岸准哭string类型实参的构造函数，这些实参负责提供关于错误的更多信息

### 18.2 命名空间

- 多个库将名字放置在全局命名空间汇总将引发命名空间污染
- 命名空间未防止名字冲突提供了更加可控的机制，命名空间分割了全局命名空间，其中每个命名空间是一个作用域，通过在某个命名空间中定义库的名字，库的作者以及用户可以避免全局名字固有的限制

**命名空间的定义**

- 一个命名空间的定义包含两部分，关键字namespace和命名空间的名字，在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类，变量及其初始化操作，函数及其定义，模板和其他命名空间

- 命名空间中的每个名字都必须表示该空间内的唯一实体，因为不同命名空间的作用域不同，所以在不同命名空间内可以有相同的名字

- 命名空间可以定义在几个不同的部分，其可以不连续的特性使得可以将几个独立的接口和实现文件组成一个命名空间:

  - 命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将包含在使用了这些成员的文件中
  - 命名空间成员的定义部分则置于另外的源文件中

  在程序中某些实体只能定义一次，如非内联函数、静态数据成员、变量等，命名空间定义的名字也需要满足这要求

- 通常情况下不将#include放在命名空间内部，否则，其隐含的意思是把该include的头文件中所有的名字定义成该命名空间内的成员

- 可以在命名空间定义的外部定义该命名空间的成员，对于名字的声明必须在作用域内，同时该名字的定义需要明确指出其所属的命名空间。要注意只能定义在所属命名空间的外层空间，不能在一个不相关的作用域中进行定义

- 模板特例化必须定义在原始模板所属的命名空间中，只要在明明空间中声明了特例化，就能在明明空间外部进行定义

- 全局作用域定义的名字也就是定义在全局命名空间中，全局命名空间以隐式的方式声明，并且在所有程序中都存在，全局作用域中定义的名字被隐式的添加到全局命名空间中

- 作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，直接用作用域运算符接上名字就表示全局命名空间中的一个成员

- 嵌套的命名空间指定义在其他命名空间中的命名空间，要在外层命名空间访问内层的名字，必须使用作用域运算符符进行访问

- C++11引入了一种新的嵌套命名空间，称为内联命名空间，内联命名空间中的名字可以被外层命名空间直接访问，定义的方式是在关键字namespace前添加关键字inline

- 未命名的命名空间是指关键字namespace后紧跟花括号括起来的一系列声明语句，未命名的命名空间中定义的变量拥有静态的声明周期，在第一次使用前创建，并且直到程序结束才销毁

- 一个未命名的命名空间可以在某个给定的文件内不连续，但是不能快约多个文件，每个文件定义自己的未命名的命名空间，若两个文件都含有未命名的命名空间，则这两个空间无关

- 未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同，若定义在文件的最外层作用域中，则该命名空间的名字一定要与全局作用域中的名字有所区别，且可以直接访问。若嵌套在另一个命名空间中，则名字可以通过外层命名空间的名字来访问

- 在C++引入命名空间的概念之前，程序需要将名字声明成static的以使得其对于整个文件有效，在文件中进行静态声明的做法是从C语言继承而来，在C语言中，声明为static的全局实体在其所在的文件外不可访问。此做法已经被C++标准取消了

**使用命名空间成员**

- 命名空间的别名使得可以为命名空间的名字设定一个短得多的同义词

- 命名空间的别名声明以关键字namespace开始，格式为：namespace 别名 = 原名;

  不能在命名空间还没有定义前就声明别名，否则将产生错误

- 命名空间的别名也可以指向一个嵌套的命名空间

- 一个命名空间可以有好几个别名，所有别名都与命名空间原来的名字等价

- 一条using声明语句一次只引入命名空间的一个成员

- using声明引入的名字遵守与过去一样的作用域规则：它的有效范围从using声明的地方开始，一直到using声明所在的作用域结束为止，外层作用域的同名实体将被隐藏

- 一条using声明语句可以出现在全局作用域，局部作用域，命名空间作用域以及类的作用域中，在类的作用域中，这样的声明语句只能指向基类成员

- using指示以关键字using开始，后面是关键字namespace以及命名空间的名字，若这里所用的名字不是一个已经定义好的命名空间的名字，则程序将发生错误，using指示可以出现在全局作用域、局部作用域和命名空间作用域中，但不能出现在类作用域中

- using指示使得某个特定的命名空间中所有名字都可见，这样无序再为名字添加任何前缀限定符了

- using声明相当于在当前作用域中创建一个命名空间中的名字的别名，using指示将命名空间成员提升到包含命名空间本身和using指示的最近作用域的能力。这使它们的工作模式有所区别，通常情况下命名空间中会含有一些不能出现在局部作用域中的定义，所以using指示一般被看做是出现在最近的外层作用域中

- 头文件若在其顶层作用域中含有using指示或using声明，则会将名字注入到所有包含了该头文件的文件中，因此头文件最多只能在它的函数或命名空间内使用using指示或using声明

**类、命名空间与作用域**

- 对命名空间内部名字的查找遵循常规的查找规则，即由内向外依次查找每个外层作用域。外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间查找过程终止

- 命名空间中名字隐藏规则来说有一个重要的例外，当给函数传递一个类类型对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间，这对于传递类的引用或指针的调用同样有效。该例外允许概念上作为类接口一部分的非成员函数无须单独的using声明就能被程序使用

- 当一个类声明了一个友元时，该友元声明并没有使得友元本身可见，但一个而另外的未声明的类或函数如果第一次出现在友元声明中，则认为它是最近的外层命名空间成员，该规则与实参查找规则结合在一起将产生一项不到的结果

  例如：

  ```C++
  class A{
      friend void f1(A a);
      friend void f2();
  }
  int main(){
      A a;
      f1(a);		//因为f1接受类类型实参，所以可以根据实参查找规则找到
      f2();		//因为f2不接受类类型实参，所以无法被找到
      return 0;
  }
  ```

**重载与命名空间**

- using声明或using指示能将某些函数添加到候选函数集
- using声明语句声明的是一个名字，为一个函数名书写using声明时，该函数的所有版本都被引入到当前作用域中，一个using囊括了重载函数的所有版本以确保不违反命名空间的接口
- 一个using声明引入的函数将重载该声明语句所属作用域已有的其他同名函数，若using声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明。若using声明所在的作用域中已经有一个函数与新引入的函数同名且形参类表相同，则该using声明将引发错误，除此之外，using声明将为引入的名字添加额外的重载实例，并最终扩充候选函数集的规模
- 对于using指示来说，引入一个与已有函数形参类表完全相同的函数并不会产生错误，只要指明调用的是命名空间中的函数版本还是当前作用域的版本即可
- 若存在多个using指示，则来自每个命名空间的名字都会成为候选函数集的一部分

### 18.3 多重继承与虚继承

**多重继承**

- 多重继承指从多个直接基类中产生派生类的能力，多重继承的派生类继承了所有父类的属性
- 对于派生类能够继承的基类个数C++没有进行特殊规定，但在某个给定的派生列表中，同一个基类只能出现一次
- 派生类的构造函数初始值列表将实参分别传递给每个直接基类，其中基类的构造顺序与派生列表中基类的出现顺序保持一致，而与派生类构造函数初始值类表中基类的顺序无关
- C++11中允许派生类从它的一个会几个基类中继承构造函数，但如果从多个基类中继承了形参列表完全相同的构造函数则程序产生错误，除非该类为该构造函数定义属于自己的版本

**类型转换与多个基类**

- 多个基类也可以令某个可访问基类的指针或引用直接指向一个派生类对象
- 编译器不会在派生类向几种基类间的转换进行比较和选择，因为在其看来转换到任意一种基类都同样好，这使得其容易造成二义性问题

**多重继承下的类作用域**

- 在多重继承的情况下，查找过程在所有直接基类中同时进行，若一个名字在多个基类中都被找到，则直接使用该名字将产生二义性，要在使用时明确指出其版本

**虚继承**

- 尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类，其可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承一个基类再间接继承它
- 默认情况下，派生类中含有继承连上每个类对应的子部分，若某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象
- 通过虚继承机制解决包含多个子对象问题，虚继承的目的是令某个类做出声明，承诺原意共享它的基类，共享的基类子对象啊ing称为虚基类。在该机制下，不论虚基类再继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象
- 虚继承具有一个不太直观的特征：必须在虚派生的真实需求出现前就已经完成虚派生的操作
- 虚派生只影响从指定了虚基类的派生类中进一步派生出的类，不会影响到派生了本身
- 指定虚基类的方式是在派生列表中访问说明符后添加关键字virtual，其表名了一种愿望，即在后续的派生类当中共享需基类的同一份实例，置于什么样的类能够作为虚基类没有特殊规定
- 因为每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并且不会产生二义性。此外，若虚基类成员只被一条派生路径覆盖，则仍然可以直接访问这个被覆盖的成员，但是若成员被多于一个基类覆盖，即多个直接基类都有该成员，则一般情况下派生类必须为该成员自定义一个新的版本

**构造函数与虚继承**

- 在徐派生中，虚基类是由最低层的派生类初始化的
- 含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序对其一次进行初始化
- 一个类可以有多个虚基类，此时这些虚的子对象按照派生列表中出现的顺序从左向右依次构造，编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类，若有先构造虚基类