### 19.1 控制内存分配

**重载new和delete**

- 当使用一条new表达式时实际执行了三步操作：

  1. new表达式调用一个名为operator new或者operator new[]的标准库函数，该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象或对象的数组
  2. 编译器运行相应的构造函数以构造这些对象，并为其传入初始值
  3. 对象被分配了空间并构造完成，返回一个指向对象的指针

- 当使用一条delete表达式删除一个动态分配的对象时，实际执行了两步操作：

  1. 对指针所指向的对象或者数组中的元素执行对应的析构函数
  2. 编译器调用名为operator delete或operator delete[]的标准库函数释放内存空间

- 当自定义了全局的operator new函数和operator delete函数后，就负担起了控制动态内存分配的职责，这两个函数必须是正确的，它们是程序整个处理过程中至关重要的一部分

- 应用程序可以在全局作用域定义operator new函数和operator delete函数，也可以将它们定义为成员函数，当编译器发现一条new表达式或delete表达式后，将在程序中查找可供调用的operator函数，若被分配或释放的对象是类类型，则编译器首先在类及其基类作用域中查找，若没有找到则在全局作用域查找，若有用户自定义的版本则执行自定义版本，若没有则执行标准库定义的版本

- 标准库定义了operator new函数和operator delete函数的8个重载版本：

  ```C++
  //可能抛出异常的版本
  void *operator new(size_t);
  void *operator new[](size_t);
  void *operator delete(void*) noexcept;
  void *operator delete[](void*) noexcept;
  //承诺不会抛出异常
  void *operator new(size_t, nothrow_t&) noexcept;
  void *operator new[](size_t, nothrow_t&) noexcept;
  void *operator delete(size_t, nothrow_t&) noexcept;
  void *operator delete[](size_t, nothrow_t&) noexcept;
  ```

  类型nothrow_t是定义在new头文件中的一个struct，该类型中不包含任何成员。new头文件还定义了名为nothrow的const对象，用户可以通过该对象请求new的非抛出版本。与析构函数类似，operator delete不允许抛出异常

- 应用程序可以自定义上面函数版本中的任意一个，前提是自定义的版本必须位于全局作用域或者类作用域中，当将上述运算符函数定义成类的成员时，是隐式静态的，无序显示的声明static，当然这么做也不会引发错误。因为operator new函数用在对象构造之前operator delete函数用在对象销毁之后，所以这两个成员必须是静态的，且不能操纵类的任何成员

- 对于operator new函数或operator new[]函数来说，返回类型必须是void*，第一个形参类型必须是size_t且不能含有默认实参

- 若想要自定义operator new函数，则可以为它提供额外形参，此时用这些自定义函数的new表达式必须使用new的定位形式将实参传递给新增形参

- 尽管一般情况下可以自定义具有任何形参的operator new，但void *operator new(size_t, void *)不能被用户重载，只供标准库使用

- 对于operator delete函数或operator delete[]函数，返回类型必须是void，第一个形参的类型必须是void*，执行一条delete表达式将调用相应的operator函数，并用指向待释放内存的指针来初始化void\*形参

- 当将operator delete函数或operator delete[]函数定义为类成员时，函数可以包含另一个类型为size_t的形参，此时该形参的初始值是第一个形参所指对象的字节数，size_t形参可用于删除继承体系中的对象，若基类有一个虚析构函数，则传递给operator delete的字节数将因待删除指针所指对象的动态类型不同而有所区别。且实际运行的operator delete函数版本也由对象的动态类型决定

- 和其他operator函数不同，这两个函数并没有重载new表达式或delete表达式，事实上是无法自定义new表达式或delete表达式的行为。提供新的operator new函数和operator delete函数的目的在于改变内存分配的方式，而不能去改变这两个运算符的含义

- C++从C语言中继承了malloc和free函数，并将其定义在cstdlib头文件中。malloc函数接收一个表示待分配字节数的size_t，返回指向分配空间的指针或者返回0以表示分配失败。free函数接收一个void*，其是malloc返回的指针的副本，free将相关内存返回给系统，调用free(0)没有任何意义

**定位new表达式**

- 在C++早期版本，应用程序若想把内存分配与初始化分离开来的话，需要调用operator new和operator delete。这两个函数的行为与allocator的allocate成员和deallocate成员非常相似，负责分配或释放内存空间能干，但不会构造或销毁对象

- 使用定位new形式来对这块内存构造对象。定位new的形式如下：

  ```C++
  new (place_address) type;
  new (place_address) type (initializers);
  new (place_address) type [size];
  new (place_address) type [size] { braced initializer lsit};
  ```

  其中place_address必须是一个指针，同时在initializers中提供一个可能为空的以逗号分割的初始值类表，该初始值类表将用于构造新分配的对象

- 当仅通过一个地址值调用时，定位new使用operator new(size_t, void*)”分配“内存，该函数不分配任何内存，只是简单的返回指针实参，然后由new表达式负责在指定的地址初始化对象以完成整个工作，事实上定位new允许在一个特定的、预先分配的内存地址上构造对象

- 传给定位new的指针无须指向operator new分配的内存，甚至不需要指向动态的内存

### 19.2 运行时类型识别

- 运行时类型识别(RTTI)的功能由两个运算符实现：

  - typeid运算符，用于返回表达式的类型
  - dynamic_cast运算符，用于将基类的指针或引用安全的转换成派生类的指针或引用

  当着两个运算符作用于某种类型的指针或引用，并且该类型含有虚函数时，运算符将使用指针或引用所绑定对象的动态类型

- 若想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数，一般来说只要有可能应该尽量使用虚函数，当操作被定义成虚函数时，编译器将根据对象的动态类型自动选择正确的函数版本

- 与虚成员函数相比，使用RTTI运算符蕴涵更多潜在的风险：程序员必须清楚的知道转换的目标类型并且必须检查类型转换是否被成功执行

**dynamic_cast运算符**

- dynamic_cast运算符使用形式：

  ```c++
  dynamic_cast<type*\>(e);		//e必须是一个有效指针
  dynamic_cast<type&\>(e);		//e必须是一个左值
  dynamic_cast<type&&\>(e);		//e不能是左值
  ```

  其中type是一个类类型，且通常情况下该类型应该含有虚函数。且在尚明所有形式中，e的类型必须满足其中任意一个：目标type的公有派生类、目标type的公有基类、目标type的类型。若复合，则类型转换可以成功，否则失败

- 若一条dynamic语句的转换目标是指针类型并且失败了，则结果为0，若是引用类型且失败了，则抛出一个bad_cast异常，该异常定义在typeinfo标准库头文件中

- 可以对一个空指针执行dynamic_cast，结果是所需类型的空指针

- 在条件部分执行dynamic_cast操作可以确保类型转换和结果检查在同一表达式中完成

**typeid运算符**

- typeid运算符允许程序向表达式提问：你的对象是什么类型
- typeid表达式的形式是typeid(e)，其中e可以是任意表达式或类型的名字，结果是一个常量对象的引用，该对象的类型是标准库类型type_info或type_info的公有派生类型，type_info定义在头文件typeinfo中
- typeid运算符可以作用于任意类型的表达式，其中顶层const会被忽略。若表达式是一个引用typeid返回该引用所引对象的类型，当typeid作用于数组或函数时，不会执行向指针的标准类型转换
- 当运算对象不属于类类型或者是一个不包含任何虚函数的类时，typeid运算符指示的是运算对象的静态类型，而当运算对象是定义了至少一个虚函数的类的左值时，typeid的结果直到运行时才会求得

**使用RTTI**

- 在某些情况下RTTI非常有用，比如想为具有击沉该关系的类实现相等运算符时

**typeinfo类**

- type_info类的明确定义随着编译器的不同而略有差异，C++标准规定type_info类必须定义在typeinfo头文件中，并且至少提供一下操作

  | 操作          | 描述                                                         |
  | ------------- | ------------------------------------------------------------ |
  | t1 == t2      | 若type_info对象t1和t2表示同一种类型，返回true                |
  | t1 != t2      | 若type_info对象t1和t2表示不同种类型，返回true                |
  | t.name()      | 返回一个C风格字符串，表示类型名字的可打印形式，类型名字的生成方式因系统而异，但要求类型不同返回的字符串必须有所区别 |
  | t1.before(t2) | 返回一个bool值，表示t1是否位于t2之前，其采用的顺序依赖于编译器 |

- 因为type_info类一般是作为一个基类出现，所以还应该提供一个公有虚析构函数，当编译器希望提供额外的类型信息时，通常在type_info的派生类中完成

- type_info类没有默认构造函数，而且其拷贝和移动构造函数以及赋值运算符都被定义为删除的，因此无法定义或拷贝type_info类型的对象，也不能为type_info对象赋值，创建type_info对象的唯一途径是使用typeid运算符

### 19.3 枚举类型

- 枚举属于字面值常量类型

- C++包含两种枚举：限定作用域和不限定作用域

- C++11引入了限定作用域的枚举类型，定义其一般形式：

  enum class/struct 枚举名{枚举成员};

- 定义不限定作用域的枚举类型省略关键字class或struct即可，其枚举类型的名字是可选的。若未命名，则只能在定义该enum时定义它的对象

- 在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类型的作用域外是不可访问的。在不限定作用域的枚举类型中，枚举成员的作用域与枚举类型本身的作用域相同

- 默认情况下，枚举值从0开始依次加1，也可以为一个或几个枚举成员指定专门的值。且枚举值不一定唯一，若没有显示的提供初始值，则当前枚举成员的值等于之前枚举成员值加1

- 枚举成员是const，因此在初始化枚举成员时提供的初始值必须是常量表达式，也可以在任何需要常量表达式的地方使用枚举成员

- 可以将一个enum作为switch语句的表达式，而将枚举值作为case标签，还能将枚举类型作为一个非类型模板实参使用，或在类的定义中初始化枚举类型的静态数据成员

- 要初始化enum对象或者为enum对象赋值，必须使用该类型的一个枚举成员或者该类型的另一个对象

- 一个不限定作用域的枚举类型的对象或枚举成员自动的转换成整型，因此可以在任何需要整型值的地方使用它们。而限定作用域的枚举类型不会进行转换

- C++11中，可以在enum名字后加上冒号以及想在该enum中使用的类型。

  enum name ： type{};

  若没有指定enum的潜在类型，默认情况下限定作用域的enum成员类型是int，对于不限定作用域的枚举类型来说，其枚举成员不存在默认类型。但其默认的潜在类型足够大，能够容纳枚举值，如果指定了枚举成员的潜在类型，则一旦某个枚举成员的值超过了类型所能容纳的返回，则引发错误

- 在C++11中，可以提前声明enum，enum的前置声明必须隐式或显式指定其成员的大小。因为不限定作用域的enum未指定成员默认大小，因此每个声明必须指定成员的大小

- enum的声明和定义必须匹配，意味着该enum的所有声明和定义中成员的大小必须一致

- 即使某个整型值恰好与枚举成员的值相等，也不能作为函数的enum实参使用

### 19.4 类成员指针

- 成员指针是指可以指向类的非静态成员你的指针
- 类的静态成员不属于任何对象，因此无须特殊的指向静态成员的指针，指向静态成员你的指针与普通指针没有什么区别
- 成员指针的类型囊括了类的类型以及成员的类型，当初始化一个这样的指针时，可以令其指向类的某个成员，但是不指定该成员所属的对象，直到使用成员指针时，才提供成员所属的对象

**数据成员指针**

- 成员指针在声明时必须还包含成员所属的类，classname::*name

- 当初始化或者赋值一个成员指针时，需指定它所指向的成员

- 在C++11中声明成员指针最简单的方法是使用auto或decltype

  auto aptr = &A::a

- 常规的访问控制规则对成员指针同样有效

**成员函数指针**

- 若成员存在重载问题，则必须显式的声明函数类型以明确指出想要使用的函数
- 和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则

**将成员函数作为可调用对象**

- 成员指针不是一个可调用对象，这样的指针不支持函数调用运算符
- 从指向成员函数的指针获取可调用对象的一种方法是使用标准库模板function
- 通常情况下执行成员函数的对象将被传给隐式的this形参，当想要使用function为成员函数生成一个可调用对象时，必须首先"翻译"该代码，使隐式的形参变成显式的
- 当定义一个function对象时，必须指定该对象所能表示的函数类型，即可调用对象形式。若可调用对象是一个成员函数，则第一个形参必须表示该成员是在哪个（一般是隐式的）对象上执行的，同时提供给function的形式中还必须指明对象是否以指针或引用的形式传入的
- 通过使用标准库功能mem_fn来让编译器负责推断成员的类型，mem_fn定义在functional头文件中，并且可以从成员指针生成一个可调用对象。mem_fn可以根据成员函数指针的类型推断可调用对象的类型，而无须用户显式指出
- mem_fn生成的对象可以通过对象调用，也可以同通过指针调用。实际上可以认为mem_fn生成的可调用对象含有一对重载的函数调用运算符，一个接受string指针，一个接受string引用
- 可以使用bind从成员函数生成一个可调用对象，当使用bind时，必须将函数中用于表示执行对象的隐式形参转换成显式的，bind生成的可调用对象的第一个实参既可以是string的指针，也可以是string的引用

### 19.5 嵌套类

- 一个类可以定义在另一个类的内部，称为嵌套类或嵌套类型
- 嵌套类是一个独立的类，和外层类基本没什么关系，特别是外层类的对线个嵌套类对象是相互独立的
- 嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见

### 19.6 union：一种节省空间的类

- union是一中特殊的类，一个union可以有多个数据成员吗，但在任意时刻只有一个数据成员可以有值，当给union的某个成员赋值之后，该union的其他成员就变成为定义的状态了
- 分配给一个union对象的存储空间至少要能容纳它的最大的数据成员
- union不能含有引用类型的成员
- 在C++11标准中，含有构造函数或析构函数的类类型也可以作为union的成员类型，union可以为其成员指定public，protected和private等保护标记，默认情况下为public
- 由于union既不能基层自其它类，也不能作为基类使用，所以union中不能含有虚函数
- union的名字是一个类型名，和其他内置类型一样，默认情况下union是未初始化的，可以像显式的初始化聚合类一样使用一堆花括号内的初始值显式的初始化一个union
- 匿名union是一个未命名的union，并且在右花括号和分号之间没有任何声明，一旦定义了一个匿名union，编译器就会自动为该union创建一个未命名的对象
- 在匿名union的定义所在的作用域内该union的成员都是可以直接访问的
- 匿名union不能包含受保护的成员或私有成员，也不能定义成员函数
- C++早期版本规定，在union中能不能含有定义了构造函数或拷贝构造控制成员的类类型成员，C++11取消了这一规则
- 当union包含的是内置类型的成员时，可以使用普通的复制语句改变union保存的值，但对于含有特殊类类型成员的union，必须分别构造该类类型的成员，当将union的值改为类类型成员的对应的值时，必须运行该类型的构造函数，将类类型成员的值改成其他值时，必须运行该类型的析构函数
- 当union包含的是内置类型的成员时，编译器将按照成员的次序依次合成默认构造函数或拷贝控制成员，若union含有类类型的成员，且该类型定义了默认构造函数或拷贝控制成员，则编译器将为union合成对应的版本并将其声明为删除的
- 对于union来说，要想构造或销毁类类型的成员必须执行非常复杂的操作，因此通常把含有类类型成员有关的状态转换
- 为了追踪union中到底存储了什么类型的值，通常会定义一个独立的对象，该对象成为union的判别式，可以使用判别式辨认union存储的值

### 19.7 局部类

- 类可以定义在某个函数的内部，成为局部类，局部类定义的类型只在定义它的作用域类可见，其成员能受到严格限制，局部类的所有成员都必须完整定义在类的内部
- 局部类中不允许声明静态数据成员，因为没法定义这样的成员
- 局部类只能访问外层作用域定义的类型名，静态变量以及枚举成员，若局部类定义在某个函数的内部，则该函数的普通局部变量不能被该局部类使用
- 局部类可以将外层函数声明为友元
- 可以在局部类的内部再嵌套一个类，此时嵌套类的定义可以出现在局部类之外，不过嵌套类必须定义在局部类相同的作用域中

### 19.8 固有的不可移植的特性

- 为了支持底层编程，C++定义了一些固有的不可移植的特性，所谓不可移植的特性是指因机器而异的特性，当将含有不可移植特性的程序从一台机器转移到另一台机器上时，通常需要重新编写该程序
- 位域和volatile限定符是C++从C语言继承而来的另外两种不可移植的特性。链接指示时C++新增的一种不可移植的特性

**位域**

- 类可以将其非静态数据成员定义成位域，在一个位域中含有一定数量的二进制位，当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域
- 位域在内存中的布局是与机器相关的
- 位域的类型必须是整型或枚举类型，因为带符号位域的行为是有具体实现确定的，所以通常情况下使用无符号类型保存一个位域
- 位域的声明形式是在成员的名字之后进个一个冒号以及一个常量表达式，该表达式用于指定成员所占的二进制位数。例unsigned int mode : 2;
- 取地址运算符不能作用于位域，因此任何指针都无法指向类的位域
- 通常使用内置的位运算符操作超过一位的位域
- 若一个类定义了位域成员，则它通常也会定义一组内联的成员函数以检验或设置位域的值

**volatile限定符**

- volatile的确切含义与机器相关，只能通过阅读编译器文档来理解，要想让使用了volatile的程序在移植到新机器或新编译器后仍然有效，通常需要对程序进行改变
- 当对象的值可能在程序的控制或检测之外被改变时，应该将对象声明为volatile，告诉编译器不能对这样的对象进行优化
- volatile限定符的用法和const相似，起到对类型额外修饰的作用
- const和volatile限定符狐仙没有什么影响，某种类型既可能是const也是volatile的，此时具有两者的属性
- 可以将成员函数定义为volatile的，只有volatile成员函数才能被volatile对象调用
- 可以声明volatile指针‘、指向volatile对象的指针以及指向volatile对象的volatile指针
- 只能将一个volatile对象的地址赋值给一个指向volatile的指针，只有当某个引用是volatile时，才能使用volatile对象初始化该引用
- const和volatile的一个重要区别是不能使用合成的拷贝/移动构造函数、赋值运算符初始化volatile对象或从volatile对象赋值，合成的成员接受的形参类型是非volatile常量引用，显然不能把一个非volatile引用绑定到一个volatile对象上

**链接指示：extern"C"**

- C++程序有时需要调用其他语言编写的函数，像所有其他名字一样，其他语言中的函数名字也必须在C++中进行声明，且该声明必须指定返回类型和形参列表

- 对于其他语言编写的函数来说，编译器检查其调用的方式与处理普通C++函数方式相同，但生成的代码有区别，C++使用链接指示指出任意非C++函数所用的语言

- 要想把C++代码和其他语言编写的代码放在一起使用，要求必须有权访问该语言的编译器，并且这个编译器与当前的C++编译器是兼容的

- 链接指示可以有两种形式：单个的或复合的

- 链接指示不能出现在类定义或函数定义的内部

- 同样的链接指示必须在函数的每个声明中都出现

- 单个的链接指示包含一个关键字extern，后接一个字符串字面值常量以及一个普通的函数声明，其中字面值常量指出了编写函数所用的语言：

  extern "C": { }

- 可以令链接指示后面跟上花括号括起来的若干函数的声明，从而一次性建立多个链接，花括号的作用是将适用于该链接指示的多个声明聚合在一起，否则花括号就会被忽略，花括号中声明的函数名字是可见的，就好像在花括外声明的一样

- 多重声明的形式可以应用于整个头文件，当一个#include指示被放置在复合链接指示的花括号中时，头文件中的所有普通函数声明都别认为是由链接指示的语言所编写的

- 链接指示可以嵌套，因此若头文件中包含自带链接指示的函数，则该函数的链接不会受到影响

- 指向其他语言编写的函数的指针必须与函数本身使用相同的链接指示

- 指向C函数的指针与指向C++函数的指针是不一样的类型，一个指向C函数的指针不能用在执行初始化或赋值操作后指向C++函数，反之亦然。有的C++编译器对这种赋值进行了扩展

- 当使用链接指示时，不仅对函数有效，且对作为返回类型或形参类型的函数指针也有效

- 有时需要在C和C++中编译同一个源文件，为实现该目的，在编译C++版本的程序时预处理器定义__cplusplus，利用该变量可以在编译C++程序的时候有条件的包含进一些代码

- 连接指示与重载函数的相互作用依赖于目标语言，若目标语言支持重载函数，则为该语言实现连接指示的编译器很可能也支持重载这些C++的函数。C语言不支持重载