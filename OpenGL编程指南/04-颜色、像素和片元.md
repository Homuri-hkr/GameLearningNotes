### 4.1 基本颜色理论

- 人的眼睛包含了名为视杆细胞和视锥细胞的光敏感结构。前者对光的强度铭感，后者区分光的不同波长。现代研究认为视锥细胞一共有三种，每一种都对光波长的某个波段敏感
- 现代显示设备对于可以显示的颜色有更严格的范围规定，可见光谱当中只有一部分是可用的
- 设备可以显示的颜色范围通常是由它的色域来表示的，OpenGL所支持的绝大多是显示设备都会使用一种组合三原色的方法来构成颜色值，红色、绿色或蓝色，即RGB颜色空间，它们构成了显示设备的整个颜色域，因为这三种颜色非常接近于人眼光锥细胞的响应曲线的中心区域
- OpenGL当中，通常会在RGB颜色空间再添加第四个alpha分量，因此可以称为RGBA颜色空间，作为RGB的一种补充，OpenGL还支持sRGB颜色空间
- 颜色空间的种类还有很多，例如HSV（色调-饱和度-值）、CMYK（青-品红-黄-黑）。若数据保存在不同于RGB的颜色空间中，则需要转换到RGB或sRGB颜色空间中，再使用OpenGL处理
- 对于真实物理世界的光照来说，光的频率和强度都是连续变化的，但计算机的帧缓存只能使用相对变化较小的离散数值来进行表达，其限制了显示的颜色数量
- 每个分量的强度都是使用一定数量的位来保存的，称为像素深度，除alpha之外的每个分量的像素深度的总和决定了颜色缓存的深度，也就决定了可以显示的颜色的总数量
- RGB颜色缓存的一个通常格式是各占8位，因此得到了一个像素深度为24位的颜色缓存，可以显示总共2^24种独立颜色

### 4.2 缓存及其用途

- 帧缓存（通常为屏幕）是由矩形的像素数组组成的，每个像素都可以在图像对应的点上显示一块方形的颜色值

- 经过光栅化阶段，得到了数据还不是真正的像素，只是候选的片元，每个片元都包含与像素位置对应的坐标数据、颜色、深度的存储值

- 颜色缓存只是记录像素信息的多个缓存中的一个，一个像素可能会关联多个颜色缓存，一个显示系统的帧缓存中包含了素有这些缓存类型，可以在自己的应用程序中使用多个帧缓存，除了主颜色缓存之外，通常不需要直接观察其他缓存的内容，而是使用它们来执行一些特定的任务

- OpenGL系统中通常包含以下几种类型的缓存：

  - 一个或多个可用的颜色缓存
  - 深度缓存
  - 模板缓存

  所有这些缓存都是集成到帧缓存单重的

- 当启动应用程序后，使用的是默认的帧缓存，它是与应用程序窗口所关联的帧缓存，默认帧缓存总是会包含一个颜色缓存

- 不同的OpenGL实现会决定自己可用的缓存以及缓存中的每个像素所包含的位数，此外，也可能用到多种视效方式或窗口类型，因此可能需要更多不同的缓存

**颜色缓存**

- 颜色缓存是通常进行绘制的缓存对象，包含RGB或sRGB形式的颜色数据，也可能包含帧缓存中每个像素的alpha值
- 帧缓存中可能包含多个颜色缓存，其中默认帧缓存中的主颜色缓存需要特别对待，其与屏幕的窗口相关联，绘制到其中的图像都会直接显示到屏幕上，而其他的颜色缓存都是与屏幕无关的
- 颜色缓存中的像素，可能是采用每个像素存储单一颜色值的形式，也可能从逻辑上被划分为多个子像素，因此启用了一种名为多重采样的反走样技术形式
- 双重缓冲的实现需要将主颜色缓存划分为两个部分：直接在窗口中显示的前置缓存以及用来渲染新图像的后备缓存。只有默认帧缓存中的主颜色缓存可以使用双重缓冲的特性
- 某些OpenGL的实现还可能支持立体显示，也就是每个颜色缓存（即使是双重缓冲）都会再划分出左颜色缓存和右颜色缓存以展现立体图像

**深度缓存**

- 深度缓存（又称z-buffer）为每个像素保存一个深度值，可以用来判断三维空间中物体的可见性，深度缓存值较大的像素会被深度缓存值较小的像素所覆盖。深度缓存的特性可以通过深度测试的方式来改变

**模板缓存**

- 模板缓存用来限制屏幕特定区域的绘制，在模板区域内的像素将会进行绘制，之外的不能

**缓存的清除**

- 通常在一帧渲染完成之后，常见的图形操作就是清除缓存，每帧都需要至少清除一次缓存，OpenGL提供了一些尽可能最优化的函数来完成这些工作
- 调用glClearBufferfv()并设置buffer参数为CL_COLOR，则关联的一个颜色缓存将被清除。
- 调用glClearBufferfv()并设置buffer参数为GL_DEPTH，则清除深度缓存。
- 模板缓存中保存的是整数数据，可以通过glClearBuffer{iv uiv fi}()函数来进行清除，这些函数也能清除颜色和深度缓存

**缓存的掩码**

- 在OpenGL向颜色、深度或模板缓存写入数据前，可以对数据执行一次掩码操作

### 4.3 颜色与OpenGL

- 片元着色器将负责设置每个片元的颜色值，有多种方式来完成该操作：
  - 片元着色器不借助任何传入片元着色器的数据直接生成片元的颜色值
  - 每个输入的顶点都会提供一个附加的颜色数据，可以在其他着色阶段修改后再传入片元着色器，并且用它来判断颜色值
  - 数据的补充，不只是特定的颜色值，都可以在片元着色器中通过计算来生成颜色值
  - 外部数据，保存在纹理特图中，需要使用纹理映射技术

**颜色的表达与OpenGL**

- 最常见的情况下，OpenGL内部会使用浮点数来表示衣蛾颜色分量，并且负责维护它的精度，直到数据保存到帧缓存为止，即除了另有设置，否则片元着色器的输入总是浮点数类型，为片元颜色设置的数值也不例外，且这些值总是要限制在归一化数值范围，即[0.0, 1.0]。这样的颜色写入帧缓存后，会映射到帧缓存所支持的数值区间内

- 可以使用glVertexAttribPointer()和glVertexAttribB*()系列函数让OpenGL自动将非浮点数类型转换为归一化的浮点数

- 将输入数据转换到归一化的浮点数值

  | OpenGL类型 | OpenGL枚举量      | 最小值      | 映射后的最小值 | 最大值     | 映射后的最大值 |
  | ---------- | ----------------- | ----------- | -------------- | ---------- | -------------- |
  | GLbyte     | GL_BYTE           | -128        | -1.0           | 127        | 1.0            |
  | Glshort    | GL_SHORT          | -32768      | -1.0           | 32767      | 1.0            |
  | GLint      | GL_INT            | -2147483648 | -1.0           | 2147483647 | 1.0            |
  | Glubyte    | GL_UNSIGNED_BYTE  | 0           | 0.0            | 255        | 1.0            |
  | GLushort   | GL_UNSIGNED_SHORT | 0           | 0.0            | 65535      | 1.0            |
  | GLuint     | GL_UNSIGNED_INT   | 0           | 0.0            | 4294967295 | 1.0            |
  | GLfixed    | GL_FIXED          | -32767      | -1.0           | 32767      | 1.0            |

**平滑的数据插值**

- 颜色数据也必须保存到顶点缓存对象中，当数据从顶点着色器传递到片元着色器时，OpenGL会沿着被渲染的图元的每个面对数据进行平滑插值，在片元着色器中使用这些数据来生成颜色时，可以在屏幕上得到平滑着色的效果，即常说的Gouraud着色
- 输出到片元着色器的颜色并不是直接来自之前的着色器阶段，而是光栅化结果

### 4.4 片元的测试与操作

- 片元在进入帧缓存前要经过完整测试过程，若一个片元在某个测试过程中丢弃，则在之后所有的测试或者操作都不会再执行：

  1. 剪切测试
  2. 多重采样的片元操作
  3. 模板测试
  4. 深度测试
  5. 混融
  6. 逻辑操作

  这些测试和操作大部分都可以通过glEnable和glDisable启用和禁止

**剪切测试**

- 将程序窗口中的一个矩形区域称作一个剪切盒，并且将所有的绘制操作都限制在这个区域内，使用glSciisor()命令设置这个剪切盒，且使用glEnbale()设置参数为GL_SCISSOR_TEST开启测试，若片元位于矩形区域内，则将通过剪切测试。使用glIsEnalbed()设置参数为GL_SCISSOR_TEST判断是否开启测试，使用glGetIntegerv()设置参数GL_SCISSOR_BOX获取剪切矩形的参数
- OpenGL实际上有多个剪切矩形，若开启了剪切测试，默认情况下所有的渲染测试都是在第一个矩形上完成的，且glScissor()函数负责设置所有渲染对应的数值，若要访问其他剪切矩形，需要用到几何着色器

**多重采样的片元操作**

- 默认情况下，多重采样在计算片元的覆盖率时不会考虑alpha的影响
- 假设多重采样本身已经开启，且帧缓存已经关联了一个多重采样的缓存数据，使用glEnable()开启一下特定模式，片元的alpha值将会纳入到计算过程中：
  - GL_SAMPLE_ALPHA_TO_CONVERAGE使用片元的alpha值计算最后的采样覆盖率，且该过程与具体硬件实现有关
  - GL_SAMPLE_ALPHA_TO_ONE将片元的alpha值设置为最大的alpha值，然后用该值进行覆盖率的计算，若上一个也被启用的话，则使用替代前的片元alpha值而不是替代值1.0进行运算
  - GL_SAMPLE_CONVERAGE将使用glSampleCoverage()中设置的数据，与覆盖率计算的结果进行与操作，由此生成的样本掩码也可以通过glSampleCoverage()的invert参数进行反转
  - GL_SAMPLE_MASK设置了一个精确的位掩码来计算和表达覆盖率，该掩码与帧缓存中的每个采样值都有一位进行对应，它将与片元的采样覆盖值再次进行与操作，采样掩码是通过glSampleMaski()函数设置的，也可以通过片元着色器的内置gl_SampleMask变量来设置，后者也是一个32为数据的数组

**模板测试**

- 只有在建立窗口的过程中预先请求模板缓存的前提下才能使用模板测试，若没有模板缓存，则该测试总是通过的

- 模板测试过程中会取像素在模板缓存中的值，然后与一个参考值进行比较，根据测试的结果不同，可以对模板缓存中的数据进行更改，可以使用各种特定的比较函数、参考值然后使用glStencilFunc()和glStencilOp()命令来完成修改操作

- 若支持GL_ARB_shader_stencil_export扩展的话，可以从片元着色器中生成或导出ref的数值，可以给不同的片元设置不同的参考值。先开启该扩展，然后写入到内置变量gl_FragStencilRefARB中，在片元着色器中向这个变量写入的逐片元的值将会在glStencilFunc()和glStencilFuncSeparate()中作为ref的值使用

- 通过查询函数glGetIntegerv()以及枚举值，可以获取所有6个与模板相关的参数数值

  | 查询参数                   | 意义                                   |
  | -------------------------- | -------------------------------------- |
  | GL_STENCIL_FUNC            | 模板函数                               |
  | GL_STENCIL_REF             | 模板参考值                             |
  | GL_STENCIL_VALUE_MASK      | 模板掩码                               |
  | GL_STENCIL__FAIL           | 模板测试失败的处理函数                 |
  | GL_STENCIL_PASS_DEPTH_FAIL | 模板测试通过但是深度测试失败的处理函数 |
  | GL_STENCIL_PASS_DEPTH_PASS | 模板测试和深度测试都通过的函数         |

- 模板测试的一些用法：

  - 通过掩码构成一个不规则形状的区域，阻止在其中的绘制
  - 加盖：添加一个常颜色值的表面，作为被切开物体的表面
  - 点画效果

**深度测试**

- 对于屏幕上的每个像素来说，深度缓存都会记录场景中物体与视点在这个像素上的距离信息
- 深度测试用来比较已经存储的数据和新的片元数据，并决定结果的处理方法，若输入的深度值可以通过指定的深度测试环节，则可以替换当前深度缓存中已有的深度值
- 深度缓存的主要用途是隐藏表面的清除
- 初始状态下，深度缓存的值是一个距离视点尽可能远的值，而所有物体的深度值都需要比这个值更靠近观察者
- 要启动深度缓存，想glEnable()传入参数GL_DEPTH_TEST开启测试，且在每帧重绘场景时都要清除深度缓存数据
- 可以使用glDepthFuc()函数设置一个不同的深度测试比较函数

**多边形偏移**

- 若需要将一个实体物体的边缘加亮，可以设置这个物体的多边形模式为GL_FILL绘制一次，然后设置一个不同的颜色，设置多边形默认为GL_LINE，再绘制一次。因为线和填充多边形的光栅化过程并不是完全一致的，所以先和多边形边长的深度值通常也不是一样的，即使两个端点相同。因此加亮的线可能隐没在多边形重叠的区域内，这一现象称为"斑驳"

- 可以通过多边形偏移的方式解决斑驳现象，设置一个恰当的偏移值，让发生重叠的z值强行分离，可以把多边形的边长与加亮的轮廓线分开。模板缓存也可以消除该现象，但多边形偏移的方式更快。多边形偏移还可以消除隐藏线和处理点的绘制

- 启用多边形偏移的方法有三种，分别对应三种不同的多边形光栅化方式，向glEnable()传入GL_POLYGON_OFFSET_FILL（GL_FILL）、GL_POLYGON_OFFSET_LINE（GL_LINE）、GL_POLYGON_OFFSET_POINT（GL_POINT）开启相应的多边形偏移，还需要调用glPolygonMode()设置当前的多边形光栅化方式

- 为了避免视觉上的瑕疵获得更好的边缘加亮的实体渲染效果，可以向这个实体物体添加一个正数偏移值，或给线框设置一个负数偏移值

- 计算一个多边形的最大深度斜率：
  $$
  m = \sqrt{(\frac{\partial{z}}{\partial{x}})^2 + (\frac{\partial{z}}{\partial{y}})^2}
  $$
  或使用近似公式：
  $$
  m = max(\frac{\partial{z}}{\partial{x}}, \frac{\partial{z}}{\partial{y}})
  $$

- 对于与近裁切平面和远裁切平面互相平行的多边形来说，深度斜率的值为0，可以设置一个较小的常数偏移值，即调用glPolygonOffset()函数时设置factor=0.0，units = 1.0

- 对于和裁切平面有较大夹角的多边形，需要一个很大的偏移值，可以设置factor为一个较小的非零值

- 在某些情形下，给factor和units设置一个简单的值并不是一个号主与，若线框的宽度大于1，则应随之增加factor的值，而且由于透视投影条件下深度值并不是线性的变换到窗口坐标中，因此与近裁切平面更接近的多边形需要的偏移值更小，远的需要的偏移值更大

**融混**

- 若一个输入片元通过了所有相关的片元测试，则可以与颜色缓存中的内容通过某种方式合并，默认的方式是直接覆盖
- 可以将帧缓存中已有的颜色与输入的片元颜色混合，也就是融混。大多数情况下，融混与片元的alpha值直接相关
- OpenGL所有颜色都会带有alpha值，无论是否显示设置
- 使用glEnable加上参数GL_BLEND开启融混，或使用一些高级技巧，alpha值才不会被OpenGL管线所忽略
- 若需要在OpenGL中使用alpha值，管线就需要得到更多有关当前图元颜色的信息，并且必须知道帧缓存的当前像素位置已经写入过的颜色值
- 在基本的融混模式下，输入的片元颜色将采用线性的方式与当前像素的颜色进行融混，对于所有线性的混合方式而言，coefficients会控制各个输入量的贡献值，对于OpenGL的融混来说，这样的系数分别叫做源融混参数和目标融混参数。源融混参数对应于片元着色器输出的颜色，目标融混参数对应于帧缓存中已有的颜色值。默认的融混操作是相加操作
- 有两种方式设置源融混参数和目标融混参数：调用GLBlendFunc()或glBlendFuncSeparate()
- 若设置GL_ONE作为参数，GL_ZERO作为目标参数，效果与禁用融混是一样的
- 通过glBlendEquation()或glBlendEquationSeparate()可以使用更多的数学方法完成融混

**逻辑操作**

- 逻辑操作包括：或、异或、反转。作用于输入的片元数据和当前颜色缓存中的数据
- 逻辑操作对于位块传输类型的系统是非常有用的，对这类系统来说，主要的图形操作就是将窗口中的某一处矩形数据拷贝到另一处，或从窗口拷贝到处理机内存，或从内存拷贝到窗口。通常情况下，这一步拷贝操作不会将数据直接写入到内存上，而是允许用户对输入的数据和已有数据之间做一次逻辑操作，然后用操作的结果替换当前已有的数据，该过程的实现代价对硬件来说非常低廉，因此很多系统都允许该做法
- 通过glEnable()传递参数Gl_COLOR_LOGIC_OP开启逻辑操作，并使用glLogicOp()更改默认逻辑操作
- 对于浮点型缓存，sRGB格式的缓存来说，逻辑操作会被自动忽略

**遮挡查询**

- 可以使用遮挡查询的方法判断一系列几何体的可见性，这一步是在逐片元的各种测试后完成的，其是一种合理的性能优化方法，对于复杂的集合物体非常有效

- 遮挡查询不需要渲染一个复杂物体的全部几何信息，而是先渲染它的包围体或其他简化的表达形式，降低了资源的消耗，然后再计算通过了所有测试的片元的数量。若OpenGL将该简化几何体渲染后没有得到任何片元或采样值，则表示这个物体在这一帧是不可见的，可以忽略这个物体的渲染

- 遮挡查询的必要实现步骤：

  1. 每次遮挡查询都要创建一个查询对象，设置类型为GL_SAMPLES_PASSED、GL_ANY_SAMPLES_PASSED或GL_ANY_SAMPLES_PASSED_CONSERVATIVE
  2. 调用glBeginQuery()开始遮挡查询
  3. 渲染几何体，完成遮挡测试
  4. 调用glEndQuery()，完成本次遮挡查询
  5. 获取本次通过深度测试的样本数量

  为了确保遮挡查询的执行过程尽可能的高效，有必要禁止所有的渲染模式，以免造成渲染时间的增加，但对像素的可见性没有影响

- 使用遮挡查询，首先获取查询测试的标识符，glCreateQueries()可以生成指定个数的查询对象，以便后续使用。可以通过glIsQuery()判断某个标识符是否对应一个可用的遮挡查询对象

- 若要指定正当查询过程中用到的几何体，只需要将它的渲染操作放置在glBeginQuery()和glEndQuery()之间即可

- 遮挡查询启用后，除了glCreateQueries()和glDeleteQueries()外（会产生GL_INVALID_OPERATION错误）所有OpenGL操作都是可用的

- 查询对象的机制不仅用在遮挡查询中，在计算顶点数、图元数、时间的时候都会用到不同的查询类型

- 可以通过glGetQueryObjectiv()或glGetQueryObjectuiv()查询结果，其返回片元的数目，若开启多重采样，则返回的是样本数目

- 完成遮挡查询后，可以通过glDeleteQueries()函数释放对象的资源

**条件渲染**

- 遮挡查询存在一个问题：OpenGL需要暂时停止几何体和片元的处理，先计算深度缓存中收到影响的样本数目再将数值返回给应用程序，这可能会造成性能的损失
- 为了避免OpenGL操作因此被暂停，硬件需要通过条件渲染的方式来判断遮挡查询是否得到了有效的片元结果，然后继续渲染后面的命令，根据glGetQuery*()系列的返回结果，条件渲染将有条件的执行后继渲染操作

### 4.5 多重采样

- 多重采样是一种对几何图元边缘进行平滑的技术，即反走样技术
- 多重采样的工作方式对每个像素的几何图元进行多次采样，此时每个像素点不会只保存单个颜色值、深度和模板值，而是记录过个样本值，当需要表示最终图像的内容时，这个像素的所有样本值会被解析为最终像素的颜色，除了在初始化阶段需要一点工作，且开启相应特性之外，多重采样功能对应充程序的改动非常有限
- 用户程序需要先在创建窗口时请求一处多重采样的缓存，可以通过glGetIntegerv()函数设置参数为GL_SAMPLE_BUFFERS判断是否请求成功，若结果为1则可以使用多重采样光栅化方法，否则只能使用单一采样的光栅化方法
- 使用glEnable()设置参数为GL_MULTISAMPLE启用多重采样
- 多重采样在渲染每个图元的时候可能会花费更多的时间，因此有时不一定需要使用多重采样来渲染场景中的所有几何对象
- 调用glGetIntegerv()设置参数为GL_SAMPLES获得每个像素中有多少个样本值用于实现多重采样
- 通过glGetMultisamplefv()函数查找像素中记录的样本位置信息
- 在片元着色器中，可以通过读取gl_SamplePosition变量获取样本位置信息，也可以通过gl_SampleID变量判断片元着色器当前在处理哪个样本值
- 若只启用多重采样，则片元着色器的执行过程与平常无异，最终颜色值会被自动分配给该像素所有的样本，即所有的颜色值都是一样的，但每个样本经过光栅化得到的深度值和模板值是不同的。若片元着色器当中使用gl_Sample*变量，或使用sample关键字限定着色器的输入变量，那么片元着色器将会在同一个像素上执行多次，每次都会输出不同的样本位置信息
- 若不能使用sample关键字来修改片元着色器，则可以通过glEnable()设置参数GL_SAMPLE_SHADING强制使用采样着色的方式，没有修改过的片元着色器也会自动使用样本位置插值的方式处理变量
- 使用glMinSampleShading()设置最小采样着色比率，可以控制从片元着色器获取独立样本插值数据的采样点数量
- 不同OpenGL实现中每个像素所包含的样本数量可能是不同的，使用比率的方式可以减少对多重采样配置参数的查询要求
- 多重采样中使用采样着色的方式，对像素颜色进行计算会增加不少负担，可能影响到程序的性能

### 4.6 逐图元的反走样

- 当实现反走样时，OpenGL会根据屏幕上的每个像素块所覆盖的范围来计算每个片元的覆盖值，将片元的alpha值与覆盖值相乘，然后就可以使用alpha值来实现片元与帧缓存中已有像素的融混操作
- 覆盖值在不同OpenGL实现中的计算方法存在细微差别，可以使用glHint()进行进一步的控制，在图像的质量和速度上做出权衡，不是所有设备的实现都会受到该函数的影响

### 4.7 像素数据的读取和拷贝

- 可以使用glReadPixels()从可读帧缓存中读取像素，然后将像素返回到应用程序中，可以在程序汇总分配一处内存空间以保存返回的像素，或使用当前绑定的像素压缩缓存
- 可能需要使用glReadBuffer()设置从那个缓存读取像素
- OpenGL中不同类型的缓存都可以保存在范围[0, 1]挚爱的数据，当使用glReadPixels()读回这些数据时，可以通过glClampColor设置是否需要阶段到归一化范围内还是保留原始数据

### 4.8 拷贝像素矩形

- 若在一块缓存的不同区域间进行拷贝，或在不同帧缓存间进行拷贝，则可以使用glBlitFramebuffer()，其在拷贝过程中会使用像素滤波的方式，该函数还支持多重采样的缓存类型，且支持不同帧缓存之间的拷贝操作