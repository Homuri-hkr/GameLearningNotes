### 6.1 纹理综述

- 纹理贴图（简称纹理）是通过摄像机拍摄或艺术家绘制的一张图片，但这不是必要条件。纹理也可以通过程序生成或由OpenGL将纹理作为一种显示设备渲染得到
- 自然界中纹理是二维的，但OpenGL支持一维纹理、二维纹理、三维纹理、立方体映射纹理、缓存纹理、数组纹理，其中数组纹理可以视为一系列相同纹理和格式的纹理切片，然后封装到一个对象之后的结果
- 纹理是由纹素(texel)组成的，其中通常包含颜色数据信息，也有很多工具将纹理作为一种数据表，然后在着色器中进行查询并且用于特定的工作
- 若要在程序中使用纹理映射所需步骤：
  1. 创建一个纹理对象并且加载文素数据
  2. 为顶点数据增加纹理坐标
  3. 若要在着色器中使用采样器，将它关联在纹理贴图
  4. 在着色器中通过纹理采样器获取纹素数据

### 6.2 基本纹理类型

- 纹理绑定到OpenGL环境中需要通过纹理单元来完成，是一个不小于0不大于设备所支持的最大单元数量的绑定点整数值，若环境支持多个纹理单元，多个纹理可以同时绑定到同一个环境中，一旦纹理绑定到环境中，就可以在着色器中通过采样器变量的方式去访问，而后者需要提前进行声明并确保声明的纹理维度和实际维度是一致的

- 纹理目标和对应的采样器类型

  | 目标(GL_TEXTURE_*)  | 采样器类型       | 维度               |
  | ------------------- | ---------------- | ------------------ |
  | 1D                  | sampler1D        | 一维               |
  | 1D_ARRAY            | sampler1DArray   | 一维数组           |
  | 2D                  | sampler2D        | 二维               |
  | 2D_ARRAY            | sampler2DArray   | 二维数组           |
  | 2D_MULTSAMPLE       | sampler2DMS      | 二维多重采样       |
  | 2D_MULTSAMPLE_ARRAY | sampler2DMSArray | 二维多重采样数组   |
  | 3D                  | sampler3D        | 三维               |
  | CUBE                | samplerCube      | 立方体映射纹理     |
  | ARRAY               | samplerCubeArray | 立方体映射纹理数组 |
  | RECTANGLE           | samplerRect      | 二维长方体         |
  | BUFFER              | samplerBuffer    | 一维缓存           |

  - 长方形纹理目标(GL_TEXTURE_RECTANGLE)是一种特殊的二维纹理类型，可以表达简单的长方形区域的纹素集合，不能有mipmap也不能构成数组类型，也不支持某些纹理封装的模式
  - 缓存纹理目标(GL_TEXTURE_BUFFER)表示任意一维的纹素数组，没有mipmap且无法构成数组。存储区域通常是通过缓存对象来表达的，其尺寸最大边界会比通常的一维纹理要大得多，它可以在任意着色器阶段访问诸如顶点数据这样的内容而不需要将数据再重新复制到纹理图片中

### 6.3 创建并初始化纹理

- 使用纹理：

  1. 创建纹理对象，创建时需要设置纹理的名称，维度和类型。glCreateTextures()

  2. 当不需要纹理对象时，可以使用glDeleteTextures()删除，传入一定数量的待删除纹理对象，用一个参数数组包含这些对象的名称，纹理所对应的存储内容的所有引用都会被删除，存储空间本身则会在它不再被使用之后由OpenGL负责释放

  3. 使用glIsTexture()判断某个名称是否是纹理对象

  4. 创建好纹理对象之后，纹理会保持target对应的默认纹理状态，但没有任何内容，在向传入数据前，需要告诉OpenGL这个纹理的大小是多少，这样纹理就可以分配内存空间来管理这些数据。根据类型的不同，可能需要调用glTextureStorage1D()、glTextureStorage2D()、glTextureStorage3D()之一来分配存储的空间。这三个函数都是用来为纹理创建永久的存储空间的，纹理存储空间的属性也就是用来存储给定纹理中所有纹素包括mipmap层次中的纹素的内存总量，其需要根据选定的内部格式和对应的分辨率来决定，一旦使用了这三个函数分配的空间，这个空间是无法再次被定义的。对于纹理的不可变性而言，只有上述存储空间的属性是永久不变的，至于纹理的内容是可以通过glTextureSubImage2D()这样的函数来修改的

     对于数组纹理来说，多出来的一个维度是用来设置数组大小的

  5. 将对象绑定到环境的纹理单元，以在着色器中读取它的数据。glBindTextureUnit()，OpenGL支持的纹理单元的最大值可以通过GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS常量的数值查询，在OpenGL4.0中至少是80个

- OpenGL还支持代理的纹理目标，对于每一个标准的纹理目标，都可以有一个对应的代理纹理目标。其可以用来测试OpenGL具体实现的能力，检查是否存在一些特定的限制

  | 纹理目标（GL_TEXTURE_*） | 代理纹理目标（GL_PROXY_TEXTURE_*） |
  | ------------------------ | ---------------------------------- |
  | 1D                       | 1D                                 |
  | 1D_ARRAY                 | 1D_ARRAY                           |
  | 2D                       | 2D                                 |
  | 2D_ARRAY                 | 2D_ARRAY                           |
  | 2D_MULTISAMPLE           | 2D_MULTISAMPLE                     |
  | 2D_MULTISAMPLE_ARRAY     | 2D_MULTISMAPLE_ARRAY               |
  | 3D                       | 3D                                 |
  | CUBE                     | CUBE                               |
  | CUBE_ARRAY               | CUBE_ARRAY                         |
  | RECTANGLE                | RECTANGLE                          |
  | BUFFER                   | /                                  |

- glTextureStorage1/2/3D()只能分配单采样点的纹理存储空间，若使用多重采样纹理，可以调用glTextureStorage2Dmultisample()、glTextureStorage3Dmultisample()创建存储空间

### 6.4 指定纹理数据

**显式设置纹理数据**

- 用户可以通过glTextureSubImage1/2/3D()将数据载入到纹理对象中

**从缓存中加载纹理**

- 