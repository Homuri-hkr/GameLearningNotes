### 2.1 综述

#### 2.1.1 什么是流水线

- 流水线指将一段工序分成n个流水线阶段，其提供单位时间的生产量，决定最后生产速度的是最慢工序所需的时间，理想情况下每个阶段耗费时间相同会使整个系统得到n倍的速度提升

#### 2.1.2 什么是渲染流水线

- 渲染流水线的工作任务在于由一个三维场景出发渲染一张二维图像，计算机需要从一系列的顶点数据、纹理等信息出发等信息出发，将这些信息最终转换成一张人眼可以看到的图像，该工作通常由CPU和GPU共同完成的

- 实时渲染将一个渲染流程分成3个阶段：应用阶段、几何阶段、光栅化阶段，每个阶段本身通常也是一个流水线系统，即包含了子流水线阶段：

  - 应用阶段。由应用主导的，通常由CPU负责实现，开发者具有该阶段的绝对控制权。该阶段有三个主要任务：

    1. 准备好场景数据，如摄像机的位置、视椎体、包含了哪些模型、使用了哪些光源等
    2. 为提高渲染效率，需要做一个粗粒度剔除工作，把不可见的物体剔除
    3. 设置好每个模型的渲染状态，包括但不限于材质、纹理、Shader

    这一阶段最重要的是输出渲染所需的几何信息，即渲染图元（点、线、三角面）

  - 几何阶段。处理所有和要绘制的几何相关的事情，通常在GPU上进行。几何阶段负责和每个渲染图元打交道，进行逐顶点、逐多边形操作，该阶段可进一步分成更小的流水线阶段。其一个重要任务是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。通过对输入的渲染图元进行多步处理后将输出屏幕空间的二维顶点坐标、顶点深度值、着色等相关信息

  - 光栅化阶段。使用上个阶段的数据产生屏幕上的像素，并渲染出最终的图像，该阶段在GPU上运行。其主要任务是决定每个渲染图元中的哪些像素应该被绘制在屏幕上，需要对上一个阶段得到的逐顶点数据进行插值然后进行逐像素处理

### 2.2 CPU和GPU之间的通信

- 应用阶段大致分为3个阶段：
  1. 将数据加载到显存中
  2. 设置渲染状态
  3. 调用Draw Call

#### 2.2.1 把数据加载到显存中

- 所有的渲染所需的数据都需要从硬盘（HDD）中加载到系统内存（RAM）中，然后网格和纹理等数据又被加载到显卡上的存储空间显存（VRAM）中，因为显卡对显存的访问速度更快且大多数显卡对RAM没有直接访问的权利
- 当把数据加载到显存后，RAM中的数据就可以移除了，但对于用网格进行碰撞检测等CPU需要访问的数据，则不移除

#### 2.2.2 设置渲染状态

- 渲染状态定义了场景中的网格如何渲染，如使用什么着色器、光源属性、材质等，若没有更改渲染状态，所有网格都将使用同一种渲染状态

#### 2.2.3 调用Draw Call

- 在设置好状态后就可以调用渲染命令Draw Call来告诉GPU可以开始渲染
- Draw Call是一个命令，发起方是CPU，接收方是GPU，该命令仅仅会指向一个需要被渲染的图元列表，而不会包含任何材质信息

### 2.3 GPU流水线

#### 2.3.1 概述

- 几何阶段和光栅化阶段可以分成若干更小的流水线阶段，这些流水线阶段由GPU来实现，每个阶段GPU提供了不同的可配置性或可编程性

  <img src=".\2.6-GPU流水线.png" alt="2.6-GPU流水线" style="zoom:100%;" />

  几何阶段：

  1. 顶点着色器：完全可编程的，通常用于实现顶点的空间转换、顶点着色等
  2. 曲面细分着色器：可选着色器，用于细分图元
  3. 几何着色器：可选着色器，可以被用于执行逐图元的着色操作或产生更多的图元
  4. 裁剪：可配置的，将不再摄像机视野内的顶点裁剪掉，并剔除某些三角图元的面片
  5. 屏幕映射：不可配置和编程的，负责把每个图元的坐标转换到屏幕坐标系中

  光栅化阶段：

  1. 三角形设置和三角形遍历是固定函数的阶段
  2. 片元着色器：完全可编程的，用于实现逐片元的着色操作
  3. 逐片元操作：具有很高的配置性，负责执行很多重要操作，修改颜色、深度缓冲、混合等

#### 2.3.2 顶点着色器

- 顶点着色器的输入来自CPU，处理的单位是顶点，对输入的每个顶点调用一次顶点着色器，其本身不可以创建或销毁任何顶点，因此无法得到顶点和顶点之间的关系。正是因为相互独立性，GPU可利用本身的特性并行化处理每一个顶点，该阶段的处理速度会非常快
- 顶点着色器的需要完成的主要工作有：坐标变换和逐顶点光照，其还可以输出后续阶段所需的数据
- 坐标变换在顶点动画中是非常有用的，可以模拟水面、布料等。无论怎么改变顶点的位置，一个最基本的顶点着色器必须完成一个工作是将顶点坐标从模型创建转换到齐次裁剪空间，之后由硬件做透视除法后得到归一化的设备坐标（NDC）
- Unity和OpenGL使用的NDC中z变量在[-1,1]，DirextX中z变量是[0,1]

#### 2.3.3 裁剪

- 在NDC中进行处理
- 一个图元和摄像机视野的关系有三种：完全在视野内、部分在视野内、完全在视野外，完全在视野内的图元就继续传递给下一个流水线阶段，完全在视野外的图元不会传递
- 裁剪：对部分在视野内的图元进行的处理，与视野边界交汇出的位置使用新的顶点裁剪物体。这一步是不可编程的，是硬件上的固定操作，但可以自定义一个裁剪操作对该步进行配置

#### 2.3.4 屏幕映射

- 在NDC中进行处理，屏幕映射的任务是把每个图元的x和y坐标转换到屏幕坐标系下，屏幕坐标系是一个二维坐标系，与用于显示画面的分辨率有很大关系
- 假设窗口左下角为（x1，y1），右上角为（x2，y2），目标是将[-1,1]范围的x和y映射到[x1~x2][y1~y2\]范围，实际是一个缩放的过程。屏幕映射不会对z坐标进行任何处理，z坐标和屏幕坐标系一起构成了窗口坐标系，这些值将传递到光栅化阶段
- OpenGL将屏幕的左下角当成了最小的窗口值，而DirectX定义左上角为最小窗口值

#### 2.3.5 三角形设置

- 三角形设置阶段会计算光栅化一个三角形网格所需的信息。上个阶段得到的是三角形网格的顶点，若要得到整个三角形网格对像素的覆盖情况，就必须计算每条边上的像素坐标，若要计算边界像素的坐标信息，就需要得到三角形边界的表示方式，这样一个计算三角网格表示数据的过程就叫做三角形设置

#### 2.3.6 三角形遍历

- 三角形遍历阶段会检查每个像素是否被一个三角网格覆盖，若覆盖就生成一个片元。也被称为扫描变换
- 一个片元不是真正意义上的像素，而是包含了很多状态的集合，这些状态用于计算每个像素的最终颜色

#### 2.3.7 片元着色器

- 片元着色器的输入是上一阶段对顶点信息插值得到的结果，输出是一个或多个颜色值
- 该阶段可以完成很多重要的渲染技术，如纹理采样。但局限在于只能影响单个片元

#### 2.3.8 逐片元操作

- 该阶段有几个主要任务：
  1. 决定每个片元的可见性。如模板、深度、alpha测试等
  2. 对通过所有测试的颜色值和已经存在颜色缓冲区的颜色进行混合
- 模板测试中可以更改模板缓冲区的值，但深度测试中，若一个片元没有通过深度测试则没有权利更改深度缓冲区的值，只有通过测试之后才能设定是否更改缓冲区中的深度值

### 2.4 一些容易困惑的地方

#### 2.4.1 什么是OpenGL/DirectX

- 图像编程接口在硬件的基础上实现了一层抽象，OpenGL和DirectX是这些图像应用编程接口，其用于渲染二维或三维图形。这些接口架起了上层应用程序和底层GPU的沟通桥梁，一个应用程序向这些接口发送渲染命令，而这些接口会一次向显卡驱动发送渲染命令，显卡驱动将OpenGL或DirectX的函数调用翻译成了GPU能听懂的语言，同时负责把纹理等数据转换成GPU所支持的格式。可以将显卡驱动比喻为GPU的操作系统

#### 2.4.2 什么是HLSL、GLSL、Cg

- 常见的着色语言：DirectX的HLSL（High Level Shading Language），OpenGL（OpenGL Shading Language）的GLSL以及NVIDIA的Cg（C for Graphic）
  1. GLSL：优点是跨平台性，可以在Windows、Linux、Mac甚至移动平台等工作，因为OpenGL没有提供着色器编译器，而是由显卡驱动来完成着色器编译工作，所以只要显卡驱动支持对GLSL的编译就可以运行。该做法的好处在于供应商可以让着色器发挥最大作用，但也意味着GLSL的编译结果取决于硬件供应商
  2. HLSL：有微软控制着色器的编译，就算使用你不同的硬件，同一个着色器的编译结果是一样的。但支持HLSL的平台相对有限，几乎完全是微软自己的产品如Windows、Xbox360
  3. Cg：真正意义上的跨平台，根据平台的不同，编译成相应的中间语言。很大原因取决于与微软的合作，导致Cg语法和HLSL非常像，可以无缝移植成HLSL代码，缺点是完全无法发挥出OpenGL的最新特性

#### 2.4.3 什么是Draw Call

- 命令缓冲区中包含了一个命令队列，由CPU向其中添加命令，而由GPU从中读取命令，添加和读取的过程是互相独立的，其使CPU和GPU可以相互独立工作。当CPU需要渲染对象时，可以向命令缓冲区中添加命令，当GPU完成了上一次渲染；任务后可以从命令队列中取出一个命令执行
- 命令缓冲区中的命令有很多种类，而Draw Call是其中一种，其他命令如改变渲染状态等
- 在每次调用Draw Call之前，CPU需要向GPU发送很多内容，包括数据、状态和命令等。该阶段CPU需要完成，该阶段CPU需要完成很多工作，一旦CPU完成了这些准备工作，GPU就可以开始本次的渲染
- 减少Draw Call的方法有很多，如批处理。批处理的思想是将很多小的DrawCall合并成一个大的DrawCall，由于要在CPU的内存中合并网格，而合并的过程是需要消耗时间的，所以更适合静态的物体，其只需要合并一次即可。对动态物体也可以进行批处理，但需要每一帧都重新合并，对空间和时间都会造成影响
- 游戏开发中减少DrawCall的开销：
  1. 避免使用大量很小的网格，当不可避免的使用很小的网格结构时，考虑是否可以合并它们
  2. 避免使用过多的材质，尽量在不同网格间共用一个材质

#### 2.4.4 什么是固定渲染管线

- 固定函数的流水线，简称固定管线，通常指在较旧的GPU上实现的渲染流水线，这种流水线只给开发者提供一些配置操作，但开发者没有对流水线阶段的完全控制权

