### 16.1 移动平台的特点

- 和PC平台相比，移动平台上的GPU架构有很大的不同，由于处理资源等条件的限制，其GPU架构专注于尽可能使用更小的带宽和功能，由此有很多与PC平台不同的现象

- 为了尽可能移除隐藏的表面，减少overdraw（一个像素被绘制多次），PowerVR芯片（用于IOS设备和某些Android设备）使用了基于瓦片的延迟渲染（TBDR）架构，将所有的渲染图像装入一个个瓦片中，由硬件找到可见的片元然后执行片元着色器。

  另一些基于瓦片的GPU架构，如Adreno（高通的芯片）和Mali（ARM的芯片）则会使用Early-Z或相似的技术进行一个低精度的深度检测来剔除不需要渲染的片元

  还有一些GPU，如Tegra（英伟达的芯片）则使用了传统的架构设计，在这些设备上overdraw可能造成性能瓶颈

- 由于移动芯片架构造成的不同，一些游戏往往需要针对不同的芯片发布不同的版本，以便对每个芯片进行更有针对性的优化，尤其是Android平台，不同设备使用的硬件大相庭径

### 16.2 影响性能的因素

- 造成游戏性能瓶颈的主要原因有：
  1. CPU
     - 过多的draw call
     - 复杂的脚本或物理模拟
  2. GPU
     - 顶点处理：过多的顶点，过多的逐顶点计算
     - 片元处理：过多的片元（分辨率或overdraw造成的），过多的逐片元计算
  3. 带宽：
     - 使用了尺寸很大且未压缩的纹理
     - 分辨率过高的帧缓存
- 对于CPU来说限制的主要是每帧的draw call数目，而对于GPU来说，限制的主要是顶点数目、屏幕分辨率、显存等因素有关
- 相关优化技术有：
  1. CPU优化
     - 使用批处理技术减少draw call的数目
  2. GPU优化
     - 减少需要处理的顶点数目：优化几何体、使用模型的LOD技术、使用遮挡剔除技术
     - 减少需要处理的片元数目：控制绘制顺序、警惕透明物体、减少实时光照
     - 减少计算复杂度：使用Shader的LOD技术
     - 代码方面的优化
  3. 节省内存带宽
     - 减少纹理大小
     - 利用分辨率缩放

### 16.3 Unity中的渲染分析工具

#### 16.3.1 渲染统计窗口

- 可以在Game视图的右上方菜单中单击Stats按钮打开渲染统计窗口，其包含音频、图像和网络

| 信息名称             | 描述                                                         |
| -------------------- | ------------------------------------------------------------ |
| 每帧时间和FPS        | 给出了处理和渲染一帧所需的时间，以及FPS数目                  |
| Batches              | 一帧需要进行的批处理数目                                     |
| Saved by batching    | 合并的批处理数目，表明了批处理节省了多少draw call            |
| Tris和Verts          | 需要绘制的三角面片和顶点数目                                 |
| Screen               | 屏幕大小及占用内存的大小                                     |
| SetPass              | 渲染使用的Pass数目，每个Pass都需要Unity的runtime绑定一个新的Shader，可能造成CPU的瓶颈 |
| Visible Skinned Mesh | 渲染的蒙皮网格数目                                           |
| Animations           | 播放的动画数目                                               |

#### 16.3.2 性能分析器（渲染区域）

- 可以在Window->Analysis->Profiler打开Unity的性能分析器
- 性能分析器显式了绝大部分在渲染统计窗口提供的信息，也给出其他如draw call数目、动态批处理/静态批处理数目、渲染纹理的数目和内存占用等有用的信息
- 性能分析器给出的draw call数目和批处理数目、Pass数目并不相等，且看上去大于程序员估算的数目，因为Unity在背后需要进行很多工作，可能花费比预期更多的draw call

#### 16.3.3 再谈帧调试器

- 可以在Window->Analysis->Profiler Debugger打开帧调试器
- 帧调试器的调试面板上显示了渲染该帧所需要的所有的渲染事件。通过单击面板上每个事件，可以在Game视图查看改时间的结果，同时渲染统计面板上

### 16.4 减少draw call数目

- 批处理的实现原理是为了减少每一帧需要的draw call数目。为了将一个对象渲染到屏幕上，CPU需要检查哪些光源影响了该物体，绑定shader并设置参数，再将渲染命令发给GPU，当场景中包含了大量对象时，这些操作就会非常耗时。GPU的性能消耗没有多大区别，但CPU的draw call就会成为性能瓶颈。批处理就是在每次调用draw call时尽可能多的处理多个物体

- 同一个材质的物体可以进行批处理，因为它们之间的不同仅仅在于顶点数据，所以可以将这些顶点数据合并在一起再发给GPU完成一次批处理

- Unity中支持静态批处理和动态批处理。

  对于动态批处理，优点是一切由Unity自动完成，不需要做任何操作，且物体可以移动，但缺点是限制很多，可能一不小心就破坏了该机制，导致Unity无法动态批处理使用了相同材质的物体

  对于静态批处理，优点是自由度高，限制很少，缺点是可能占用更多的内存，且经过静态批处理后所有的物体都不可以移动了

#### 16.4.1 动态批处理

- 当场景中有些模型共享了同一个材质并满足一些条件，Unity就可以自动将它们进行批处理。其基本原理是每一帧把可以进行批处理的模型网格进行合并，再把合并后的模型数传递给GPU然后使用同一个材质将其渲染。处理每帧时Unity都会重新合并一次网格（所以物体仍可以移动）
- 动态批处理的条件限制（随着版本可能有些变化）：
  - 网格的顶点属性规模小于900（该数字可能发生变化）。如一个顶点需要使用三个属性，则顶点数目不能超过300。
  - 一般来说所有对象都需要使用同一个缩放尺度，但若所有的物体都使用了不同的非统一缩放，则也可以动态批处理。从Unity5中该限制不存在
  - 使用光照纹理的物体需要小心处理，这些物体需要额外的渲染参数，如光照纹理上的索引、偏移量、缩放信息。为了让这些物体可以被动态批处理，需要保证指向光照纹理的同一位置
  - 多Pass的shader会中断批处理，在前向渲染中多光照Pass就会出现该问题
- 启动动态批处理需要在Player Seting中勾选Dynamic Batching

#### 16.4.2 静态批处理

- 相比于动态批处理，静态批处理适用于任何大小的几何模型，其实现原理是只在运行开始阶段，把需要进行静态批处理的模型合并到一个新的网格结构中，该大网格包含了所有子网格（同一种网格多次使用则会被包含多次），意味着模型不可以在运行时刻被移动。且由于只需要进行一次合并操作，其比动态批处理更加高效。但缺点在于需要占用更多的内存来存储合并后的几何结构，因为在静态批处理前一些物体共享了相同的网格，则内存中每个物体都会对应一个该网格的复制品，即一个网格变成多个网格再发送给GPU。解决方法要么人手，要么换成动态批处理，要么自己编写批处理方法
- Unity中使用静态批处理只需要在物体面板上勾上Static复选框，且在Player Seting中勾选Static Batching
- 在内部实现上，Unity静态物体变换到世界空间下，然后为它们构建一个更大的顶点和索引缓存。对于使用了同一材质的物体，Unity只需要一个draw call就可以绘制全部物体。对于不同材质的物体，仍需要调用多个draw call但静态批处理可以减少draw call之间的状态切换，而这些切换是耗时的操作

#### 16.4.3 共享材质

- 无论是动态批处理还是静态批处理都要求模型之间共享一个材质，但不同的模型之间总会需要不同的渲染属性，如纹理颜色等，需要使用一些策略来尽可能的合并材质
- 若两个材质之间只有使用的纹理不同，可以将纹理合并到一张更大的纹理中，被称为一张图集，这样使用就可以使用不同的采样坐标对纹理进行采样
- 若是在其他如颜色不同、某些浮点属性不同，但不管是动态批处理还是静态批处理都要求同一个材质而不是使用了同一种Shader的材质，即指向的材质必须是同一个实体，意味着只要调整了参数就会影响到所有使用该材质的对象。若想要进行调整参数，常见方法是使用网格的顶点数据来存储这些参数
- 若需要在脚本中共享访问材质，应使用Renderer.sharedMaterial保证修改的是和其他物体共享的材质，但以意味着修改会应用到所有使用改材质的物体上。另一个Renderer.material修改材质时，Unity会创建一个该材质的复制品，从而破坏该批处理在该物体上的应用

### 16.5 减少需要处理的顶点数目

#### 16.5.1 优化几何体

- 在建模时，尽可能减少模型中三角形面片的数目，对于模型没有影响或是肉眼难以察觉到区别的顶点要尽可能去掉
- Unity中显示的三角形面片数目和顶点数目往往多余建模软件中显示的数目。因为三维软件更多的是站在人类角度理解顶点，组成几何体的没一个点都是一个单独的点。而Unity是站在GPU角度去计算顶点的，有时需要将一个顶点拆分成多个顶点，主要是为了分离纹理坐标和产生平滑边界，因为顶点的每一个属性和顶点之间必须是一对一的关系。而分离纹理坐标是因为建模时一个顶点的纹理坐标有多个（不同面上被共用的顶点可能对应多个纹理坐标），平滑边界也是因为一个顶点可能会对应多个发现信息或切线信息。所以要溢出不必要的硬边以及纹理衔接，避免边界平滑和纹理分离

#### 16.5.2 模型的LOD技术

- LOD技术原理是当物体离摄像机很远时，模型上很多细节是无法被察觉到的，LOD允许当对象逐渐原理摄像机时，减少模型上的面片数量从而提升性能
- 在Unity可以使用LOD Group组件来为一个物体构建一个LOD，需要为同一个对象准备多个包含不同细节程度的模型，然后将它们赋给LOD Group组件汇总不同等级，Unity就会自动判断当前位置上需要使用哪个等级的模型

#### 16.5.3遮挡剔除技术

- 遮挡剔除可以用来消除那些在其他物体后面看不到的物件，意味着资源不会浪费在计算看不到的顶点上。其会使用一个虚拟的摄像机来遍历长江，构建一个潜在的可见的对象集合的层级结构，在运行时摄像机将会使用该数据识别哪些物体是可见的
- 要在Unity中使用遮挡剔除技术需要进行一系列额外的处理工作，可参照unity手则

### 16.6 减少需要处理的片元数目

- 可以在Scene视图下拉菜单中选中Overdraw查看overdraw视图，但其只是提供了查看物体相互遮挡的层数，不是真正最终屏幕绘制的overdraw，可以理解为没有进行任何深度测试和其他优化策略的overdraw

#### 16.6.1 控制绘制顺序

- 为了最大限度的避免overdraw，一个重要的优化策略是控制绘制顺序，由于深度测试的存在，保证物体是从前往后绘制的就可以很大程度上减少overdraw，因为在后面绘制的物体无法通过深度测试
- 在Unity中渲染队列数目小于2500的对象被认为是不透明物体，总体上是从前往后绘制（从2500向0绘制），而使用其他队列的物体则是从后往前绘制（从2500向后绘制）。所以尽可能把物体的队列设置为不透明物体的渲染队列

#### 16.6.2 时刻警惕透明物体

- 对于半透明对象来说，由于没开启深度写入，要想获得正确渲染效果必须从后往前渲染，这意味着几乎都会造成overdraw
- GUI对象大多被设置成了半透明，若屏幕中GUI占据比例太多，而主摄像机有没有进行调整而是投影整个屏幕，则GUI就会造成大量overdraw。这种情况可以尽量减少窗口中GUI占据的面积，或将GUI的绘制和三维场景的绘制交给不同的摄像机，其中负责三维场景的摄像机视角范围尽量不和GUI充电
- 在移动平台透明度测试也会影响性能，虽然其没有关闭深度写入，但游戏使用了discard或clip操作，会导致一些硬件的优化策略失效

#### 16.6.3 减少实时光照和阴影

- 实时光照对于移动平台是一种非常昂贵的操作，若场景中包含了过多的点光源，且使用了多个Pass的Shader，则很可能造成性能下降。特别是对于逐像素的光源，每个物体都需要再被渲染一次，且无法使用批处理
- 可以使用烘焙技术将光照提前烘焙到光照纹理中，在运行时通过光源方向、视角方向、法线方向等参数在纹理中采样即可。另一种方法是使用God Ray，场景中许多小型的光源效果都是靠该方法模拟的，它们一般不是真正的光源，而是通过透明纹理模拟得到的。若一定要使用更多的实时光照，可使用逐顶点光照来替代

### 16.7 节省带宽

#### 16.7.1 减少纹理大小

- 所有纹理最好是正方形，且长宽值最好是2的整数幂，因为很多优化策略只有在这种时候可以发挥最大系哦啊用。在Unity中即使导入的纹理长宽值不是2的整数幂也会转换到离其最近的整数幂。但在制作美术资源时应注意该问题，以免放缩纹理造成不好的影响

- 尽可能将使用多级渐远纹理技术和纹理压缩。

  Unity中可以在纹理属性中勾选Generate Mip Maps创建大小不同的纹理，构成一个纹理金字塔，游戏运行中就可以根据距离选择不同的纹理。除非确定纹理不会发生缩放，如GUI和2D游戏中使用的纹理，否则都应该生成相应的多级渐远纹理

  纹理压缩同样可以节省带宽，但对于不同架构的GPU，纹理压缩就会变得有点复杂，因为不同架构有不同的压缩格式。但Unity可以根据不同的设备选择不同的压缩格式，所以只需要将纹理压缩格式设为自动压缩格式。但对于GUI类型的纹理，一些时候由于对画质的要求不希望对纹理进行压缩

#### 16.7.2 利用分辨率缩放

- 过高的屏幕分辨率也是造成性能下降的原因之一，尤其对于很多地段手机。可能需要对特定机器进行分辨率的放缩，当然可能会造成游戏效果的下降

### 16.8 减少计算复杂度

#### 16.8.1 Shader的LOD技术

- Shader的LOD技术可以控制使用的Shader等级，只有Shader的LOD值小于某个设定的值，该Shader才会被使用，而使用了超过设定值的Shader的物体将不会被渲染

  ```c++
  SubShader{
  	LOD 200
  }
  ```

- 可以在Unity Shader的导入面板上看到该Shader使用的LOD值，默认情况下，允许的LOD等级是无限大的，即任何被当前显卡支持的Shader都可以被使用。但在某些情况下可能需要去掉一些使用了复杂计算的Shader渲染，可以使用Shader.maximumLOD或Shader.globalMaximumLOD来设置允许的最大LOD值

- Unity内置的Shader使用了不同的LOD值

#### 16.8.2 代码方面的优化

- 通常来说游戏需要计算的对象、顶点、像素数目排序是：对象数<顶点数<像素数，所以应尽可能将计算放在每个对象或逐顶点上
- 在具体代码编写上，不同硬件甚至需要不同的处理。因此一些普遍的规则在某些硬件上可能并不成立，且通常Shader代码的优化并不直观，一些平台上缺少行管的分析器
- 普遍成立的优化策略（在个别设备上性能可能下降）：
  1. 尽可能使用低精度的浮点值进行运算。高精度的浮点数如float/highp适用于存储顶点坐标等变量，但计算速度是最慢的，应尽量避免在片元着色器中使用其进行运算。half/mediump适用于一些标量、纹理坐标等变量，计算速度大约是float的两倍。fixed/lowp适用于绝大多数颜色变量和归一化的方向矢量，在进行一些对精度要求不高的计算时，应尽量使用这种精度的变量，计算速度大约是float的4倍，但要避免对低精度的变量进行频繁swizzle操作。且尽量避免在不同精度之间的转换
  2. 对于绝大多数GPU来说，在使用插值寄存器将数据从顶点着色器传递给下一个阶段时，应使用尽可能少的插值变量。但对于有些平台来说这些插值是非常廉价的
  3. 尽可能不要使用全屏的屏幕后处理效果
  4. 尽量把多个特效合并在一个Shader中
  5. 尽可能不要使用分支循环与之，避免使用类似sin、tan、pow、log等复杂数学运算

