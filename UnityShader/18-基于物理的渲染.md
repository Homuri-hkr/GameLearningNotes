### 18.1 PBS的理论和数学基础

#### 18.1.1 光是什么

- 光在物理学中是一种电磁波，由太阳或其他光源中被发射出来，然后与场景中的对象相交，一些光被吸收，另一些则被散射，最后光线被一个感应器吸收成像。吸收是光转换成其他能量，其不会改变光的传播方向，而散射只会改变传播方向而不会改变能量。
- 在均匀的介质中，光沿直线传播，若传播时介质发生了变化，传播方向就会发生变化
- 现实生活中，光与物体的交互过程是非常复杂的，大多数情况下并不存在一种可分析的解决方法。但为了在渲染中对光照进行建模，往往只考虑一种特殊情况，即只考虑两个介质的边界是无限大且是光学平滑的，这样光在不同介质的边界会被分割成两个方向：反射和折射方向，而有多少百分比的光会被折射就是由菲涅尔等式来描述
- 对于一些物体，其在微表面层次并不平滑，对于微表面法线变化角度小的，高光反射就越清晰，反之越模糊
- 对于金属材质，其具有很高的吸收系数，所有被折射的光往往被立即吸收，被金属内部的自由电子转化成其他形式的能量。对于非金属材质则会同时表现出吸收和散射两种现象，被散射出去的光又被称为次表面散射光
- 次表面散射光会从不同入射点的位置从物体内部再次社畜，而这些离入射点的距离值和像素大小之间的关系会产生两种建模结果：
  1. 像素大于散射距离，这些次表面散射产生的距离可以忽略
  2. 若像素小于散射距离，则要实现真实的次表面散射效果就不能忽略，需要使用次表面散射渲染技术

#### 18.1.2 双向反射分布函数（BRDF）

- 用辐射率来量化光，其实单位面积、单位方向上光源的辐射通量，通常用L表示，被认为是第单一光线的亮度和颜色评估

- 在渲染中通常会基于表面的入射光线辐射率Li计算出射辐射率Lo，该过程被称为着色过程

- BRDF用以描述物体表面一点是如何与光进行交互的，大多数情况下可以用f(l, v)（l是入射方向，v是观察方向）来表示。

- 绕着表面法线旋转入射方向或观察方向不会影响BRDF结果，被称为各向同性BRDF，否则称为各向异性BRDF

- BRDF有两种理解方式：

  1. 当给定入射角度后，BRDF可以给出所有出射方向上的反射和散射光线的相对分布情况
  2. 当给定出射方向后，BRDF可以给出所有入射方向到该出射方向的光线分布

  更直观的理解是当一束光线沿着入射方向I到达表面某点时，f(l,v)表示了有多少部分的能量被反射到了观察方向v上

- 反射等式
  $$
  L_o(v) = \int_{\Omega}f(l,v) * L_i(l)(n\cdot{}l)d\omega_i
  $$
  其是渲染方程的一个特殊情况。给定观察视角v，该方向上所有的出射辐射率Lo(v)等于所有入射方向的辐射率积分乘以它的BRDF值f(l,v)再乘以一个余弦值(nl)。即出射光等于所有入射光乘以该光对该点的占的权重再投影到该表面，然后把这些光加起来

- 在游戏渲染中，通常是和精确光源打交道（方向确定，大小无限小的光源，如点光、聚光），而不是计算所有入射光线在半球面的积分。所以对于精确光源可以简化公式
  $$
  L_o(v) = \pi{}f(l_c,v) * c_{light}(n\cdot{}l_c)\\其中l_c表示光的方向，c_{light}表示光的颜色
  $$
  该公式使用了一个特定的BRDF值（pi）来代替积分操作

- BRDF决定了着色过程是否是基于物理的，根据其是否满足两个特性判断：

  1. 是否满足交换律：交换 l 和 v的值后，BRDF的值不变

  2. 是否满足能量守恒：表面反射的能量不能超过入射的光能
     $$
     \int_{\Omega}f(l,v) (n\cdot{}l)d\omega_i \leq{} 1
     $$

- BRDF可以用于描述两种不同的物理现象：表面反射和次表面散射，针对每种现象，BRDF通常会包含一个单独的部分描述：表面反射部分称为高光反射项，次表面散射部分称为漫反射项

#### 18.1.3 漫反射项

- Lambert模型是最简单应用最广泛的漫反射BRDF，其准确的表示为
  $$
  f_{Lambert}(l, v) = \frac{c_{diff}}{\pi}\\ c_{diff}表示漫反射光线所占比例，通常被称为反射颜色
  $$
  该式子结果是一个定值。除以pi因为该模型假设在所有方向上的强度是相同的，而BRDF要求在半球内积分值为1。

  注：平时乘的(nl)部分实际上是反射等式的一部分而不是BRDF部分

- 很多基于物理的渲染选择使用了更复杂的漫反射项模拟次表面散射，如
  $$
  f_{diff}(l,v) = \frac{baseColor}{\pi}(1+(F_{D90} - 1)(1 - n\cdot{}l)^5)(1 + (F_{D90}-1)(1-n\cdot{}v)^5)\\
  F_{D90} = 0.5 + 2roughness(h \cdot{}l)
  $$
  baseColor是表面颜色，通常由纹理采样得到，roughness是表面粗糙度。该表达式既考虑了掠射角漫反射能量变化，还考虑了表面粗糙度对漫反射的影响

#### 18.1.4 高光反射项

- 在基于物理的渲染中，BDRF中的高光反射项大多数都是建立在微面元理论的假设上的，其认为物体表面实际由许多人眼看不到的微面元组成的，虽然物体表面不是光学平滑的，但微面元可以被认为是光学平滑的，即具有完美的高光反射。当光线和物体一点相交时，实际上是和一系列微面元交互的结果

- 微面元理论也仅仅是对真实世界的散射的一种近似理论，也有自身的缺陷，仍有一些材质无法使用微面元理论描述

- 假设表面法线为n，微面元的法线并不都等于n，因此不同的微面元会把同一入射方向的光线反射到不同方向上，当计算BRDF时，入射方向和观察方向都会给定，意味着只有一部分微面元反射的光线会进入到视野中（刚好反射到观察方向），即这些微面元的法线等于入射方向和出射方向的一般，也就是半程向量。但半程向量的微面元反射也不会全部进入到BRDF计算中，因为其中一部分会在入射方向或反射方向上被其他微面元挡住

- Torrance-Sparrow微面元模型（l：入射方向，v：视野方向，h：半程向量，n：法向量）
  $$
  f_{spec}(l,v) = \frac{F(l,h)G(l,v,h)D(h)}{4(n\cdot{}l)(n\cdot{}v)}
  $$
  F(l,h)：菲涅尔反射函数，计算每个活跃的微面元会把多少入射光线反射到观察方向上，即反射光线所占入射光的比率（有些被吸收了）

  D(h)：法线分布函数（NDF），计算有多少比例的微面元法线等于半程向量，只有这部分的才可能反射到视野中

  G(l,v,h)：阴影遮掩函数，计算有多少由于遮挡而不会被人眼看到，所以只给出了活跃的微面元所占的浓度

  4(nl)(nv)：校正从微面元的局部空间到整体宏观表面数量差异的校正因子

  不同的部分可以衍射出不同的BRDF实现

#### 18.1.5 Unity中的PBS实现

- Unity提供了两种PBS模型，一种基于GGX模型，一种基于归一化的Blinn-Phong，一种基于GGX。在5.3之前默认Blinn-Phong，之后默认使用GGX。

- GGX的漫反射项使用之前的漫反射公式，高光项的几个函数分别为：

  1. 法线分布函数采用GGX的一种实现
     $$
     D_{GGX} = \frac{\alpha^2}{\pi((\alpha^2 - 1)(n\cdot{}h)^2 + 1)^2}\\
     \alpha = roughness^2
     $$

  2. 阴影遮掩函数使用一种由GGX衍生出的Smith-Schlick模型
     $$
     G(l,v,h)=\frac{1}{((n\cdot{}h)(1-k)+k)((n\cdot{}v)(1-k)+k)}\\
     k=\frac{roughness^2}{2}
     $$

  3. 菲涅尔反射使用Schlick菲涅尔近似等式
     $$
     F(l,h)=F_0 + (1-F_0)(1-l\cdot{}h)^5 \\
     F_0为高光反射系数
     $$

### 18.2 Unity5的Standard Shader

- Unity支持两种物理的工作流程：金属工作流和高光反射工作流。

  金属工作流是默认的工作流程，名字来源是因为直接指定表面的高光表面的金属值用于表明是金属类型还是非金属类型，并不意味着只能模拟金属类型的材质

  高光反射工作流名字来源于可以直接指定高光反射颜色是强还是弱

  两种工作流可以实现相同的效果，只是使用的参数不同而已

#### 18.2.1 它们是如何实现的

- Standard和Standard(Specular setup)的Shader源码可以在Unity内置的builtin_shaders-5.x/DefaultResourcesExtra文件夹找到，其依赖于builtin_shaders-5.x/CGIncludes，其中定义了和PBS相关的各个函数、结构体和宏等

  | 文件                          | 描述                                                         |
  | ----------------------------- | ------------------------------------------------------------ |
  | UnityPBSLighting.cginc        | 定义了表面着色器使用的标准光照函数和相关的结构体等，如LightingStandardSpecular函数和SurfaceOutputStandardSpecular结构体 |
  | UnityStandardCore.cginc       | 定义了Standard和Standard(Specular setup) Shader使用的顶点/片元着色器和相关的结构体、辅助函数等，如vertForwardBase、fragForwardBase、MetallicSetup、SpecularSetup和VertexOutputForwardBase、FragmentCommonData结构体 |
  | UnityStandardBRDF.cginc       | 实现了Unity中基于物理的渲染技术，定义了BRDF1_Unity_PBS、BRDF2_Unity_PBS和BRDF3_Unity_PBS等函数，来实现不同平台下的BRDF |
  | UnityStandardInput.cginc      | 声明了Standard Shader使用的相关输入，包括shader使用的属性和顶点着色器的输入结构体VertexInput，并定义了基于这些输入的辅助函数，如TexCoords、Albedo、Occlusion、SpecularGloss等函数 |
  | UnityStandardUtils.cginc      | Standard Shader使用的一些辅助函数，可能移动到UnityCG.cginc中 |
  | UnityStandardConfig.cignc     | 对Standard Shader的相关配置，如默认情况下关闭简化版的PBS实现（将UNITY_STANDARD_SAMPLE设为0），以及使用基于归一化的Blinn-Phong模型而非GGX模型来实现BRDF（将UNITY_BRDF_GGX设为0） |
  | UnityStandardMeta.cginc       | 定义了Standard Shader中的"LightMode"为"Meta"的Pass（用于提取光照纹理和全局光照的相关信息）使用的顶点/片元着色器，以及它们使用的输入/输出结构体 |
  | UnityStandardShadow.cginc     | 定义了Standard Shader中"LightMode"为"ShadowCaster"的Pass，使用的顶点/片元着色器，以及它们使用的输入/输出结构体 |
  | UnityGlobalIllumination.cginc | 定义了和全局光照相关函数，如UnityGlobalIllumination函数      |

- Standard.shader和StandardSpecular.shader都定义了两个SubShader。

  第一个SubShader的计算更复杂，主要针对非移动平台（通过#pragma exclude_renderers gles排除GLES平台），并定义了前向渲染路径和延迟渲染路径使用的Pass，以及用于投射阴影和提取元数据的Pass。

  第二个SubShader主要针对移动平台，定义了4个Pass，其中两个Pass用于前向渲染路径，一个Pass用于投射阴影，一个Pass用于提取元数据

- Standard.shader和StandardSpecular.shader最大不同是，设置BRDF的输入时使用了不同的函数来设置各个参数，Standard.shader使用了MetallicSetup函数来设置各个参数，StandardSpecular.shader使用了SpecullarSetup函数来设置。

#### 18.2.2 如何使用Standard Shader

- 金属材质：

  1. 几乎没有漫反射，所有被吸收的光都会被自由电子立即转化为其他形式的能量
  2. 有非常强烈的高光反射
  3. 高光反射通常有颜色

  非金属材质

  1. 大多数角度高光反射的强度比较如，但在掠射角时高光反射强度会增强，即菲涅尔现象
  2. 高光反射的颜色比较单一
  3. 漫反射的颜色多种多样

- 可以在官方提供的实例项目Shader Calibration Scene中提供了两个有参考价值的校准表格

### 18.3 一个更复杂的例子

#### 18.3.1 设置光照环境

- 可以在Light Setting的Environment Lighting中设置环境光的来源（天空盒、渐变值、固定值），环境光照强度，若不想让物体接受环境光照可以设为0

- 可以在Light Setting的Environment Reflections中设置反射的来源，若不想物体接受反射可以把反射源设为Custom并将自定义的Cubemap保留为空或将场景中使用的Skybox设置为空。通过Resolution可以控制它每个面的分辨率

- Unity还引入了实时全局光照（GI）流水线，场景中的物体不仅可以受直接光照的影响，还可以接受间接光照（通过其他物体反射）的影响

- 在烘焙选项中选择Realtime模式，场景受平行光影响的所有物体都会进行实时的光照计算，当光源或场景中其他物体的位置、旋转角度等发生变化时，场景中的光照结果也会随之变化。

  若选择Backed模式，会将光源的光照效果烘焙到一张光照纹理中，若场景中的物体发生了移动，但是阴影等光照效果并不会发生变化。

  选择Mix模式允许混合使用实时和烘焙，会将场景中的静态物体的光照烘焙到光照纹理汇总，仍然会对动态物体产生实时光照

- 光源面板中Bounce Intensity参数可以调节间接光照的强度，当为0时，一条光线仅会和一个物体相交，不会继续反弹

- 也可以在Light Setting中设置Bounce Booset参数来控制场景中反射的间接光照强度，其会和单个光源的参数一起控制间接光照的反射强度。

- Indirect Intensity参数调大同样可以增大间接光照的强度

#### 18.3.2 放置反射探针

- 反射探针的工作原理和光照探针类似，允许在场景中的特定位置上对整个场景的环境反射进行采样，并将采样结果存储在每个探针上，当游戏中包含反射效果的物体从这些探针附近经过时，Unity会从这些邻近探针存储的反射结果传递给物体使用的反射纹理，若存在多个反射探针，则会在这些反射的结果进行插值
- Unity在场景中放置一个默认的反射探针，该探针存储了对场景中使用的Skybox的反射结果，来作为场景的环境光照。若需要让场景中的物体包含额外的反射效果就需要放置更多的反射探针
- 反射探针共有三种类型：
  1. Baked：通过提前烘焙来得到该位置使用的Cubmap，在游戏运行时反射探针中存储的Cubemap不会发生变化，该探针在烘焙时只会处理静态物体（标识为Reflection Probe Static）
  2. Realtime：实时更新当前的Cubemap，且不受静态物体还是动态物体的影响，其花费更多的处理时间。Unity允许从脚本通过触发来精确控制反射探针的更新
  3. Custom：既可以从编辑器烘焙它，也可以使用一个自定义的Cubemap来作为反射映射，但自定义的Cubemap不会被实时更新
- 通常反射探针放置在具有明显反射现象的物体旁边，或是墙角等容易发生遮挡的物体周围
- Unity内置的反射探针可以模拟互相反射

#### 18.3.4 线性空间

- 在使用基于物理的渲染方法渲染整个场景时，应该使用线性空间来获得最好的渲染效果。默认情况下Unity会使用gamma空间，使用线性空间需要Edit->Project Settings->Player->Ohter Settings->Color Space选择Linear选项。线性空间需要一些硬件来支持，一些移动平台上支持并不好

### 18.4 答疑解惑

#### 18.4.1 什么是全局光照

- 全局光照指模拟光线如何在场景中传播，不仅会考虑直接光照的结果，还会计算光线被不同的物体表面发射而产生的间接光照
- 通常来讲，间接光照的计算是非常耗时的，通常不会在实时渲染中。一个传统的方法是使用光线追踪，来追踪场景中每一条重要的光线的传播路径，该方法能得到非常出色的画面效果，被大量应用在电影制作中，但往往需要大量时间才能得到一帧，不满足实时的要求
- Unity采用了Enlighten解决方案来让全局光照能在各个平台上有不错的性能表现，该解决方案也被集成在虚幻中。总体上讲Unity采用了实时+预计算的方法来模拟场景中的光照，其中实时光照用于计算那些直接光源对场景的影响，物体移动时光照发生变化，但其无法模拟光线多次反射的效果，所以使用预计算的方法使全局光照甚至在一些高级的移动设备上也能打到实时的要求。
- 预计算包含了常见的光照烘焙，即将光源对场景中静态物体的光照效果提前烘焙到一张光照纹理中，然后将光照纹理直接贴在这些物体的表面来得到光照效果。由于静态光照烘焙无法在光照条件改变时更新物体的光照效果，因此使用了预计算实时全局光照提供一个解决途径来动态为场景实时更新复杂的光照结果。其利用了当物体和光源的位置被固定，则物体对光线的反弹路径以及漫反射光照都是固定的，与摄像机无关，可以提前将这些数据算出来，在实时运行时，只要光源的位置不变，即使改变了光的颜色和强度、物体的漫反射自发光相关属性，这些数据也一直有效不需要更新。
- 预计算阶段Enlighten会在由所有静态物体组成的场景上进行简化的“光线追踪”过程，该过程中Enlighten会自动将场景分割成多个子系统，得到场景中物体的关系。这些预计算都是在静态物体上进行的

#### 18.4.2 什么是Gamma校正

- 伽马曲线表达式
  $$
  L_{out}=L_{in}^{\gamma}
  $$

- 人眼具有一种特性，对光的灵敏度在不同的亮度上是不一样的，正常光照下对较暗的区域变化更加敏感

- 微软联合爱普生、惠普提供了sRGB颜色空间表针，推荐显示器的显示伽马值为2.2，并配合0.45的编码伽马就可以保证最后伽马曲线之间可以相互抵消。大多数的摄像机、PC和打印机都使用了sRGB

- 忽视伽马校正造成渲染出来的东西是暗的且不小心在非线性空间下计算或使输出的图像是非线性的

- 将Unity的颜色空间设置为伽马空间时，不会对Shader的输入进行任何处理。当选择线性空间时，Unity会将输入纹理设置为sRGB模式，硬件在对纹理进行采样时会自动将其转换到线性空间中，且GPU会在Shader写入颜色缓冲前自动进行伽马校正或是保持线性在后面进行伽马校正，若开启HDR，渲染会使用浮点精度的缓冲，其拥有足够的进度不需要进行任何伽马校正。当渲染完成要写入显示设备的后备缓冲区时，再进行最后一次伽马校正。若没有使用HDR，Unity就会将缓冲设置为sRGB格式，其像一个普通的纹理，写入缓冲前进行伽马校正，读取缓冲时进行解码操作。若开启混合，每次混合时硬件先将颜色缓冲中的颜色值转换到线性空间中，再与当前颜色进行混合，完成后进行伽马校正，再将混合结果存入颜色缓冲。透明通道不会参与伽马校正

- 伽马校正最好不要在中间进行，而是在读取写入前进行

- 当对图像的存储空间够大，通用的格式不是8位时，伽马就可能小时

#### 18.4.3 什么是HDR

- HDR，高动态范围。动态范围指最高和最低的亮度之间的比值，在真实世界中场景最亮和最暗区域的范围可以非常大。HDR使用远远高于8位精度来记录亮度信息，可以表示超过0-1内的亮度值，从而更精确的反映真实的光照环境，尽管最后还是要映射会0-1，但光照环境会更加真实可信，让亮的亮，暗的暗，且不丢失中间亮度的细节
- HDR的使用可以在屏幕后处理中拥有更多的控制权，如当提取非常亮的区域时，若不使用则可能和其他偏白的地方一样，造成不希望出现的泛光效果
- HDR使用了浮点缓冲来存储高精度图像，不仅需要更大的显存空间且渲染速度会变慢，且一些硬件不支持HDR。当使用HDR时无法再利用硬件的抗锯齿功能，只能使用基于屏幕后处理的抗锯齿