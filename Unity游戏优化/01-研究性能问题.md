#### 1.2 通用的性能分析检查方法

- 验证目标脚本是否出现在场景中

  当期待看见的脚本操作没有出现时，在Hierarchy窗口的文本输入框中输入 t:脚本名 即可搜索所有挂载该脚本以及脚本的派生类的物体，查找目标物体是否挂载该脚本，并检查相应脚本是否启用

- 验证脚本执行次数是否符合预期

  当查看Profile数据，某些MonoBehaviour方法执行的次数或者时间超过预期，需要进行该检查。

  若在场景文件创建对象的次数或者代码中实例化对象的次数比预期多，问题可能来源于调用了冲突或重复的代码，产生性能瓶颈，在运行中检查该脚本的数量，若短列表显示的组件数比预期的多或者少，最好编写一些初始化代码或者自定义编辑器辅助函数，防止这种情况发生

- 验证事件的顺序

  Unity应用程序主要执行从本机代码到托管代码的一系列回调（如Awake等函数），负责处理游戏循环（并非像简答的控制台应用程序，有一个程序起点，然后通过while循环渲染游戏），在相同类型的事件发生时，无法确定其执行顺序。若在确定事件的实际顺序时遇到困难，使用带IDE的逐步调试器来处理或通过Debug.Log 打印日志语句。

  协程通常用来编写一些事件序列的脚本，何时出发取决于yield类型，最不可预测的是 waitforseconds yield类。在协程启动和结束间调用的update回调数量是可变的，因此不要使协程依赖于某个对象的update特定调用次数，应保持协程的简单性和独立性

  -------ps：Unity的日志器非常昂贵，若使用的太频繁可能会导致一些不必要的性能峰值，最好只对代码库中国--------最相关的部分进行针对性日志记录

- 最小化正在进行的代码修改

  为了调试更改代码时，可以通过几种方式来防止忘记做出的代码更改。

  书写日志语句，在删除日志语句时比较麻烦，若忘记删除则会在发行版本中出现不必要的性能开销；

  在更改的地方添加独特的标记或注释；

  使用源代码控制工具，使代码库易于区分任何修改过的文件和内容，以便恢复到原有状态；

  使用断点，可跟踪完整的调用栈、变量数据和条件代码路径，从而不用更改代码

- 最小化内部影响

  unity编辑器仍存在一些问题使调试变的困难

  若一帧需要很长时间去处理，Profiler可能无法获取结果并记录在窗口中，如希望在程序或者场景初始化期间捕获数据就很麻烦，自定义CPU分析是一个备选方案；

  若通过按键启动测试，且已经打开Profiler，则在按键之前先回到game窗口，因为Profiler是最近单击的窗口，编辑器就会将按键时间发送到该窗口，而不是运行的程序，没有游戏物体会捕捉到这次按键；

  若Game窗口再编辑器中不可见但出于活动状态，则不会像该视图渲染任何内容，因此不会触犯Game窗口的渲染事件

  垂直同步（VSync）用于将应用程序的帧率匹配将要显示到的设备的帧率，该特性减少了屏幕撕裂（后一副图像的一部分和前面重叠）。执行启用了VSync的Profiler可能会在WaitForTargetFPS标题下的CPU使用情况时产生许多嘈杂的峰值，这将产生不必要的混乱使不能更好的发现问题，因此在监视CPU峰值时禁用VSync复选框（在Edit/Project Settings/Quality导航到当前选择的平台的子页面可以完全禁用VSync的功能）；

  确保性能下降不是因为控制台窗口中出现大量异常和错误消息而导致的直接结果。

- 最小化外部影响

  检查有无有台进程消耗CPU周期或占用大量内存，可用内存不足通常会干扰测试，因为其会导致更多的缓存丢失

- 代码片段的针对性分析

  可通过Profiler类在脚本中控制它。该类最终要的方法是运行时激活和禁用分析功能的分隔符方法BeginSample和EndSample，BeginSample方法还有个带参的重载版本，允许参数名称出现在“CPU使用情况”区域的Hierarchy模式中

  ------ps：这两种方法仅在开发构建过程中编译，不会在未选中开发模式的版本构建过程中编译火执行，这称为 ------非操作代码

  Mono框架在System.Diagnostics空间中提供了Stopwatch类，可以随时停止和启用Stopwatch对象，能简单的度量自启动以来经过了多长时间，但是其只能精确到毫秒级，最多1/10毫秒。可以自定义CPU分析类。







































































