- 设计模式是解决常见软件设计问题的可复用设计方案，适当使用设计模式可以让代码结构更清晰，更加稳定，容易维护并具有一致性

#### 开闭原则

- 定义：一个软件实体应对扩展开放，对修改关闭，即在设计一个模块时，应当使该模块可以在不被修改的前提下被扩展。软件实体可以指一个软件模块、一个由多个类组成的局部结果或一个独立的类
- 开闭原则的关键是抽象，从需求找出实体可被扩展的共同点，实现一个抽象类，扩展就通过继承该抽象类进行扩展

#### 依赖倒转原则

- 定义：高层模块不应该依赖底层模块，都应该依赖抽象，抽象不应该依赖细节，细节应该依赖抽象。 要针对接口编程，不要针对实现编程
-  简单来说就是如果说有几个具体实现类，让一个函数使用，但是若具体实现类发生变动，则使用的函数也要变，可以将几个具体实现类抽象为一个接口，让使用函数使用接口中的成员

#### 里氏替换原则

- 定义：若对每一个类型为C的对象c都有类型B的对象b，使得程序中所有c替换成b时行为没有发生变化，则C是B的子类。所有引用基类的地方必须能透明的使用其子类对象
- 在软件中若能使用基类对象，那么一定能使用其子类对象，把基类替换成子类不会产生任何错误。但反过来不成立，一个软件使用的是子类不一定能使用其基类
- 其实现开闭原则的重要方式之一：在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象替换父类对象。若没有父类型的话在进行扩展功能时，就必须修改调用代码的实现

#### 单一职责原则

- 定义：一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中，对于一个类而言，应该仅有一个引起它变化的原因

#### 接口隔离原则

- 定义：客户端不应该依赖不需要的接口，一旦一个接口太大，则需要分割成更细小的接口，使用该接口的客户端仅需要知道与之相关的方法即可

#### 合成复用原则

- 定义：尽量使用对象组合，而不是继承来达到复用的目的。多用组合少用继承

#### 迪米特法则

- 定义：每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位
- 该法则就是指一个软件实体应当尽可能少的与其他软件实体发生相互作用，这样当一个模块修改时，就会尽量少的影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，要求限制软件实体间通信的宽度和深度

#### 状态模式

```c#
public class Context
{
    private IState mState;
    public void SetState(IState state)
    {
        mState = state;
    }

    public void Handle()
    {
        mState.Handle(arg);
    }
}

public interface IState
{
    void Handle(int arg);
}

public class ConcreteStateA : IState
{
    private Context mContext;
    public ConcreteStateA(Context context)
    {
        mContext = context;
    }

    public void Handle(int arg)
    {
        Debug.Log("处理A状态 " + arg);
        if(arg > 10)
        {
            //处理
            mContext.SetState(new ConcreteStateB(context));
        }
    }
}

public class ConcreteStateB : IState
{
    private Context mContext;
    public ConcreteStateB(Context context)
    {
        mContext = context;
    }

    public void Handle(int arg)
    {
        Debug.Log("处理B状态 " + arg);
        if(arg <= 10)
        {
        	//处理
            mContext.SetState(new ConcreteStateA(context));
        }
    }
}
//之后就可以只用调用Context的方法，装态切换和相关处理逻辑都在不同的状态里面
```

#### 外观模式

- 使用一个外观类负责和外面客户进行交互，执行不同服务

#### 单例模式

```c#
//将构造函数声明为私有
//定义静态单例字段
//定义静态单例属性
```

#### 桥接模式

- 将抽象和实现分离，即将几个需要交互的类的分别提取一个抽象类，使用抽象类进行交互

```c#
class BridgeDesignMode
{
    void Start()
    {
        IRenderEngine renderEngine = new OpenGL();

        Sphere sphere = new Sphere(renderEngine);
        sphere.Draw();
        Cube cube = new Cube(renderEngine);
        cube.Draw();
    }
}

public class IShape
{
    public string name;

    public IRenderEngine renderEngine;

    public IShape(IRenderEngine renderEngine)
    {
        this.renderEngine = renderEngine;
    }

    public void Draw()
    {

    }

}

public abstract class IRenderEngine
{
    public abstract void Draw(string name);
}

public class Sphere : IShape
{
    public Sphere(IRenderEngine renderEngine) : base(renderEngine)
    {
        name = "Sphere";
    }

}

public class Cube : IShape
{
    public Cube(IRenderEngine renderEngine) : base(renderEngine)
    {
        name = "Cube";
    }
}

public class OpenGL : IRenderEngine
{
    public override void Draw(string name)
    {
        Debug.Log($"Opengl {name}");
    }
}

public class DirectX : IRenderEngine
{
    public override void Draw(string name)
    {
        Debug.Log($"Directx {name}");
    }
}
```

#### 策略模式

- 有一个使用策略的类，定义一个公共的策略接口，调用接口中的接口使用不同的策略

```c++
public class Strategy
{
    void Start()
    {
        StrategyContext context = new StrategyContext();
        context.strategy = new ConcreteStrategyA();

        context.Cal();
    }
}

public class StrategyContext
{
    public IStrategy strategy;
    public void Cal()
    {
        strategy.Cal();
    }
}

public interface IStrategy
{
    void Cal();
}

public class ConcreteStrategyA : IStrategy
{
    public void Cal()
    {
        throw new System.NotImplementedException();
    }
}

public class ConcreteStrategyB : IStrategy
{
    public void Cal()
    {
        throw new System.NotImplementedException();
    }
}
```

#### 模板方法模式

- 某些方法的实现需要多个步骤，某些步骤固定有些不固定，不固定的步骤就对不同的步骤每个定义一个子类，且在子类中重写

```c#
public class TempleMethodDesignMode
{
    void Start()
    {
        IPeople people = new NorthPeople();
        people.Eat();
    }
}

public abstract class IPeople
{
    public void Eat()
    {
        OrderFoods();
        EatSomething();
        PayBill();
    }
    private void OrderFoods()
    {
        Debug.Log("点单");
    }

    public virtual void EatSomething()
    {

    }

    private void PayBill()
    {
        Debug.Log("买单");
    }
}

public class NorthPeople : IPeople
{
    public override void EatSomething()
    {
        Debug.Log("吃面条");
    }
}

public class SouthPeople : IPeople
{
    public override void EatSomething()
    {
        Debug.Log("吃米饭 ");
    }
}
```

#### 工厂模式

- 将对象的创建和使用分开，避免使用对象的类需要创建对象，使两个类耦合在一起

- 简单工厂模式：使用一个简单的工厂创建类，对不同的类型的对象直接使用判断进行创建

  不满足开闭原则，当增加新类时需要在工厂类中修改代码

- 工厂模式：定义一个抽象工厂类，再对每种类型定义一个工厂，扩展时就只需要新添加一个类