### 3.1 重温C++及最佳实践

#### 3.1.1 扼要重温面向对象编程

- 类：属性（数据）和行为（代码）的集合，共同组成既有用又有意义的整体
- 封装：对象向外只提供有限接口，隐藏对象的内部状态和实现细节
- 继承：能接着延伸现有的类去定义新的类
- 多态：一种语言特征，允许使用单一共同的接口操作一组不同类型的对象

#### 3.1.3 C++11

- auto：在C++11中改变了语义，在之前是一种存储类指定符，类似的修饰符还有static、register、extern，每个变量都只能使用四者之一，默认存储类指定是auto表示变量为局部作用域，应分配于寄存器或程序堆栈中。C++11中，auto关键字用于变量类型推导，可以用于代替类型指定符，编译器从右侧推到出变量的类型
- nullptr：类型安全的显式常数值，表示空指针，是std::nullptr_t的实例
- 基于范围的for：只需要数据结构提供非成员函数的begin()和end()就可以遍历整个数据结构
- override、final：之前仅仅使用virtual一个关键字声明和重写虚函数，新加入override指明该函数会覆盖基类一个现有的虚函数，final指定符标记该虚函数不能再被子类覆盖
- 强类型enum：enum会把其枚举项输出到该作用域，而枚举项的类型由编译器按枚举里的值决定。强类型以enum class声明，其作用域像类和结构体的成员，让程序员可以指明底层类型
- 智能指针：unique_ptr、shared_ptr以及伴随类weak_ptr
- Lambda表达式：\[\]\(\){} => type
- 移动语义和右值引用：右值引用本身是一个左值，可以对右值引用变量赋值或修改

### 3.2 C/C++的数据、代码和内存

#### 3.2.1 数值表达形式

- 定点记法：可随意选择整数部分以及小数部分各用多少位表示，限制了可表示整数部分的范围以及小数部分的精度

- 浮点记法：小数点可以任意移动不同位置，该位置由指数控制的，浮点数的精度增加，可表示的范围则缩小。在IEEE-754格式中，把指数设为255有特别意义，用以标识数值是NaN或无穷大

  在零附近还可以填充浮点数表示法的一种扩展，称为非规约值或低于正常值，当使用此扩展时，偏移指数为零被当做非规约值，此时指数被当做1而非0，而尾数首个隐藏位被改为零

- 许多电脑和游戏主机的CPU都有特殊的算术逻辑单元ALU，称为矢量处理器或矢量单元，矢量处理器提供一种并行处理方式，称为单指令多数据（SIMD），可以并行的对多个数据进行运算，数据由矢量处理器处理，需要把数据以两个或更多个数据打包，存进64位或128位寄存器

- <cstdint\>C++11标准库引入了一组标准化的特定大小整数类型

- 大于1byte的值称为多字节量，在使用2byte以上的整数/浮点数数值的软件中，多字节量非常普遍

- 小端：微处理器将多字节值的最低有效字节存储于较低的内存位置，则该处理器为小端处理器

  大端：微处理器将多字节值的最低有效字节存储于较低的内存位置，则该处理器为大端处理器

- 解决数据存储在不同字节序平台的问题：

  - 所有数据以文字方式写入文件，多字节数值以一串十进制数字或十六进制数字，每数字一个字节写入，该方法会浪费磁盘空间，但却可行
  - 先用工具转换数据字节序，然后再把转换后的数据写进二进制文件

- 字节转换：

  - 整数：将最低的x字节转到对应的最高x字节
  - 浮点数：使用C++的reinterpret_cast操作把浮点数诠释为整数，称为类型双关，但在使用严格别名时，类型双关会导致优化bug，取而代之的一个方法是使用union

#### 3.2.2 声明、定义及链接规范

- 编译器每次操作只针对一个翻译单元，遇到未解决引用的外部变量和函数时，只能“毫不犹豫“的相信该变量是真的存在。
- 链接器的任务是把所有对象文件组合成为最终可执行映像，链接器读取所有对象文件，并尝试解决对象文件间的交叉引用，若链接成功，生成的可执行映像包含所有函数、全局变量、静态变量，并正确解决所有翻译单元间的交叉引用
- 链接器的主要功能是解决外部引用，因此只能报告如下两种错误：
  1. 找不到extern引用的目标，报告“无法解决的外部符号”
  2. 若找到两个或以上相同名字的实体（函数或变量），链接器报告“符号被多重定义”
- 声明：数据对象或函数的描述，声明使编译器知道使其的名字，以及其数据类型或函数签名
- 定义：程序中个别内存区域的描述，此内存区域可能用来防止变量、struct或class的实例，以及函数的机器码
- 任何C/C++里的数据对象或函数都可以有多个同等的声明，但只能有一个定义。若有两个或更多同等定义位于一个翻译单元，编译器会报告有多个同名实体错误。但若有两个或更多同等定义存在于不同的翻译单元，则编译器发现不了，因为编译器每次都是以翻译单位运作的，链接器会在解析交叉引用时报告“符号被多重定义”错误
- 若多个.cpp文件包含了含有定义的头文件，就肯定会产生“符号被多重定义”的链接错误。内联函数是个例外，每个调用内联函数的地方都会复制该函数的机器码，并把机器码直接嵌入调用方的函数里，若内联函数要供多余一个翻译文件使用，则该内联函数必须置于头文件中，只是为.h文件内的函数声明加上inline关键字并将函数主体置于.cpp文件内是不够的，编译器必须知道函数主体才能将函数内联
- inline关键字只是给编译器的提示，编译器会为每个内联函数分析器内联的成本效益，即测量函数大小，对比内联该函数的潜在效率收益，决定是否对函数进行内联，编译器有最终决定权
- 每个C/C++定义都有名为链接规范的属性，外部链接的定义可被定义处以外的翻译单元看见并引用。内部链接的定义则只能被该定义所处的翻译单元看见，而不能被其他翻译单元引用
- 所有定义预设均为外部链接，使用static关键字可以把定义改为内部链接
- 从技术上看，声明不会有链接属性，因为声明不会在可执行映像中分配存储空间，因此不存在链接器是否允许交叉引用那些存储空间的问题

#### 3.2.3 C/C++内存布局

- 无论何种格式，可执行文件总是包含程序的部分映像，程序执行此部分映像会置于内存中，被称为部分映像的原因是程序出了把可执行映像置于内存中一般也会分配额外内存
- 可执行映像被分为几个相连的块，称为段或者节。每个操作系统可执行文件布局方式都有些诧异，同一个操作系统里的不同可执行文件也会有些微差异
- 映像文件一般最少有以下4个段组成：
  1. 代码段：包含程序定义的全部函数的可执行机器码
  2. 数据段：包含全部获初始化的全局及静态变量，链接器为这些变量分配所需内存，其内存布局将会和程序执行时完全一样，并且链接器会填入适当的初始值
  3. BSS段（block start by symbol）：包含程序中定义的所有未初始化的全局变量和静态变量，任何未初始化的全局变量和静态变量皆为零。链接器只需简单的存储所需零值的字节个数，足以安置此段内未初始化的全局及静态边浪你，当操作系统载入长须时，变回保留BSS段所需的字节个数，并未该部分内存填入零然后调用程序进入点
  4. 只读数据段（rodata段）：包含程序中定义的只读（常量）全局变量。编译器通常把整数常量视为明示常量，并且直接把明示常量插进机器码中，明示常量直接占用代码段的存储空间而不存储于只读数据段
- 当可执行程序被载入内存并运行时，操作系统会保留一块称为程序堆栈的内存，当调用函数时一块连续的内存就会被压入栈，此内存块称为堆栈帧。
- 堆栈帧存储3类数据：
  1. 调用函数的返回地址
  2. 相关CPU寄存器的内容。被调用方可以使用任何觉得合适的寄存器而不用担心调用方所需的数据被覆盖，函数返回时各寄存器会还原至调用方继续执行的状态，若函数有返回值，该值会存储于指定的寄存器中，使调用方能取用，但其他寄存器会恢复原来的值
  3. 函数中所有局部变量（一些局部变量会分配使用CPU寄存器但大多数情况下使用堆栈帧）。每个函数调用都各自保持一组私有的局部变量集合
- 当含自动变量的函数返回时，其堆栈帧就会被舍弃，该函数内的所有自动变量都被视为不存在，从技术上说，这些变量所占的内存仍然在已被舍弃的堆栈帧中，当调用下一个函数时，这些变量所占的内存就可能被覆盖
- 为了提供动态分配功能，操作系统为每个运行进程维护一块内存，可调用malloc/new函数从中分配，free/delete归还内存，次内存块称为堆内存或自由存储

#### 3.2.4 成员变量

- C中的struct和C++中的class都可用来把变啦滚组成逻辑单元，但class和struct的声明并不占用内存，仅仅是数据布局的描述
- 当声明一个struct或class时，就能以和基本数据类型相同的方式进行分配：
  - 作为自动变量分配在程序堆栈上
  - 作为全局变量、文件静态变量或函数静态变量
  - 动态从自由存储中分配
- 不同上下文，static关键字有不同的含义：
  - 当用于文件作用域时，static意味着“限制变量或函数的可见性，只有本文件才能使用该变量或函数
  - 当用于函数作用域时，static意味着“变量为全局，非自动，只在本函数内可见”
  - 当用于struct或class声明时，static意味着“该变量非一般成员变量，而是类似于全局变量”。类声明内的类静态变量不占用内存，必须在一个文件内定义静态变量以分配内存

#### 3.2.5 对象的内存布局

- 每种数据类型都有其天然的对齐方式供CPU高效的从内存中进行读/写，数据对象的对齐是指，内存地址是否是对齐字节大小的倍数（通常是2的幂）
- class或struct中，当把较小的数据类型放置于较大类型之间时，编译器就会启用填充，以保证所有成员都是正常对齐的。将较小的数据成员安排在一起可以省去一些填充空间
- 当B类继承自A类时，内存里B类的数据成员会紧接A类数据成员之后，每个新的派生类都会简单的把其数据成员附加到末端，即使类之间可能因对齐而加入填充
- 当类含有或继承一个或多个虚函数时，那么就会在类的布局里添加虚表指针指向虚函数表，通常在内的布局最前端。每个类的虚函数表里包含该类声明或继承而来的所有虚函数指针，每个含有虚函数的类都具有一个虚函数表，且这些类的实例都会有虚表指针指向该虚函数表

#### 3.2.6 kilobyte及kibibyte

- 国际单位制（SI）kilobyte（KB）或megabyte（MB）是以10进制为基础描述的，如kilo指10^3.IEC指定了用于计算机科学的单位kibibyte（KiB）指2^10

### 3.3 捕捉及处理错误

#### 3.3.1 错误类型

- 所有软件项目皆有两类基本错误状况：
  1. 用户错误：指用户做了不正确的事情而引发的错误
  2. 程序员错误：由代码本身的bug所导致的错误
- 用户在不同的语境中有所变化，可能是玩游戏的人、游戏制作者，甚至于团队中的其他程序员，在最后一类中，用户和程序员的界限就不在明显

#### 3.3.2 错误处理

- 对于用户错误，应处理越妥善越好，向用户显示有用信息然后允许用户继续工作。

  对于程序员错误，应中止程序并提供低阶调试信息使程序员能快速鉴定及修正问题。

**处理玩家错误**

- 当“用户”为玩家时，显然要以游戏性来处理错误。如使用音频信息提示

**处理开发者错误**

- 当“用户”为游戏开发者时，有两种看法：

  - 一方面，避免坏游戏资产持续存在过久，当遇到任何一个游戏资产有问题时，便不允许游戏执行，造成无效资产的始作俑者便会有强大的动机去理解移除或修正该资产
  - 另一方面，游戏开发是混乱的迭代过程，实际上鲜有从一开始就产生“完美”资产的情况。该思路下，游戏引擎应尽可能健壮能处理几乎任何想象到的问题种类，即使错误的资产也能继续工作

  可以取两者之间平衡点，当发现开发者错误时，让错误变的明显，且让团队可在问题存在的情况下继续工作

**处理程序员错误**

- 检测及处理程序员错误最佳的办法一般是在源代码中嵌入错误检测代码，并且当检测到错误时终止程序，该机制名为断言系统

#### 3.3.3 实现错误检测及处理

**错误返回码**

- 常见处理方法之一是当函数检测到错误时，从该函数返回某种错误码。其可以用布尔值表示函数执行的成败，也可以用不可能的值去表示，更佳的是返回一个枚举值表明函数执行失败，该方式可以清楚地区分错误和函数输出，并可显示失败的确切原因

**异常**

- 错误返回码也有缺点，最大的问题是检测到错误的函数与可处理错误的函数完全无关，在发生错误时该错误可能必须由顶层的游戏循环处理，此时需要逐个传递错误码到顶层函数
- 解决方法是抛出异常，异常处理是C++的强大功能，让检测到错误的函数在无须知道能处理该错误函数的情况下就可以把错误信息传递到其余代码处。发生异常时程序员可以选择把错误信息存储于异常对象，然后程序自动进行堆栈展开，寻找合适的try块。此时错误检测和错误处理是分离开的，但异常会为程序添加一些额外开销，任何使用到异常的函数其调用帧会变大以承载堆栈辗转开解时所需的额外信息，且堆栈展开通常很慢，比简单的返回函数要多约1-2倍时间。就算程序仅有一个函数使用了异常，整个程序都必须使用，编译器不能预知抛出异常时调用堆栈会有哪些函数
- 在存在抛出异常的可能时，几乎代码库里的每个函数都需要健壮的处理所有函数调用，并且销毁局部对象。因此在游戏引擎中有充分的理由完全关掉异常处理

**断言**

- 断言是一行检查表达式的代码，当表达式求值为真时一切如常，若表达式求值为假，则暂停程序，打印消息，并在可行的情况下启动调试器

```c++
#if ASSERTIONS_ENABLED
	//定义一个内联汇编让调试器暂停程序，不同CPU的做法有所区别
	#define debugBreak() asm {int 3;}
	//对运算式求值，若不正确则报告断言失败
	#define ASSERT(expr)\
		if(expr){}\
		else{\
			reportAssertionFailure(#expr, __FILE__, __LINE__);\
			debugBreak();\
		}
#else
	#define ASSERT(expr)	//不求值，同时保证程序中ASSERT宏存在
#endif
```

- 断言只应用于捕捉程序本身的bug，永远不要用来捕捉用户错误，且断言失败时应总是终止程序，应该只用来捕捉严重错误，若可以在断言后继续正常运行程序则最好采用其他方式向用户报告错误

#### 3.3.4 内联汇编（补）

- 常需要内联汇编的情况：

  - 代码优化。若性能要求是至关重要的，则内联汇编可能有所帮助，调优编译器选项不会永远都是最佳选择，一个便利的内联汇编代码片段可以让用户大幅提高程序性能
  - 硬件操作或OS服务。编译器总是需要一些时间来标准化和实现最新的特性，为了使用最新的硬件指令或OS服务，经常使用内联汇编

- 内联汇编的组成：

  ```c++
  asm volatile(assembly template
  	: output operand list
  	: input operand list
  	: clobber list);
  ```

  1. 关键字asm()或\_\_asm\_\_()：用于说明随后的字符串是内联汇编代码块。两者几乎是相同的，唯一区别是当预处理程序宏中使用内联汇编时，asm在编译过程中可能会引发警告

     修饰符volatile或\_\_volatile\_\_：可选的，可以添加到asm后禁止某些编译器的优化。两者的区别同上

  2. 汇编模板：括号中的第一部分，包含汇编指令行，这些指令行都包括在双引号中，以行分隔符\n或\n\t结束。内联汇编代码的语法是相同的，但比一般的汇编代码简单得多。且很少在其中创建一个分段，一般情况下除了汇编指令，只允许使用一些本地标签

  3. 输入输出操作数列表：以冒号开始，每条以逗号隔开。其列出的每个变量必须有一个约束，且有一个可选的约束修饰符。各个平台的约束是不同的

  4. 破坏列表：通知编译器，有些寄存器或内存已因内联汇编块造成乱码

  除了关键字和汇编模板外，都是非必须的

### 3.4 流水线、缓存及优化

- 游戏是软实时系统，必须在限期内完成操作，其中最显然的需求是每帧必须在16.6ms（60fps）或33.3ms（30fps）内完成。“软”指没有什么会因为帧率导致严重的事故

#### 3.4.1 并行范式转移

- 早期计算机CPU相对较慢，优化的思路是降低任务所花费的CPU周期数目，每一刻CPU仅做一项工作，那时内存访问的开销相对较低，程序员常用内存换取更少的周期。现今计算机及游戏机都包含并行运算的CPU核心，CPU性能的提升速度高于内存访问的提升速度，此时规则与早期相反，优化是在CPU上做更多工作而避免访问内存

#### 3.4.2 内存缓存

- 访问现代游戏或PC的主系统内存是缓慢的操作，通常需要几千个处理器周期才能完成，和CPU的寄存器相比，存取寄存器只要数十个周期甚至于一个周期。为降低访问内存的平均时间，现代处理器采用高速的内存缓存
- 缓存打到最低的内存访问延迟原因：
  1. 缓存内存通常采用现代最快及最贵的技术
  2. 在物理上尽量置于最接近CPU核心的地方，通常置于同一芯片上
- 内存缓存系统提升内存访问性能的方法：将程序最常使用的数据块保存至缓存的局部拷贝

**缓存线**

- 为降低缓存命中失败的概率，缓存控制器会尝试载入多于所请求的内存
- 缓存的内存地址和主内存的地址为一个简单一对多关系
- 直连映射：每个内存地址仅映射至一根缓存线，即内存空间分为n个缓存空间大小的块，然后进行一一映射。这种方式给定一个内存的地址，模以缓存大小即可获得缓存地址
- 缓存只能处理与缓存线大小倍数对齐的内存地址，所以缓存实际上只能以缓存线为单位寻址而非字节单位，所以实际上获得是缓存线的索引。旁路转换缓冲（translation lookaside buffer，TLB）是一个特殊数据结构存储在缓存控制器中，用于追踪缓存线索引与内存地址之间的一对多关系

**指令缓存和数据缓存**

- 指令缓存会预载即将执行的机器码，数据缓存用来加速从主内存读写数据
- 大多数处理器会在物理上独立分开这两种缓存，因为不希望读一个指令会导致一些合法数据被踢出缓存，反之亦然。优化代码时必须同时考虑数据缓存及指令缓存的性能

**组关联和替换策略**

- 直接映射的问题在于可能大致病态情况，使两个不相关的内存块不断来回互相替换
- 若主内存地址能映射至两个或更多不同的缓存线，就能获得更好的平均性能
- 2路组关联缓存中，每个主内存映射至两个缓存线

**写入策略**

- 写入策略：缓存控制器如何处理写入
- 最简单的缓存写入设计称为透写式缓存，写入缓存时会立即把数据同时写入内存
- 回写式，数据会先写到缓存中，在某些情况下才会把缓存线写回到主内存。比透写式节约大量带宽

**多级缓存**

- 命中率测量程序命中缓存的频繁度，而不是被缓存命中失败而带来巨大开销
- 缓存延迟和命中率有个基本的权衡关系，缓存越大命中率越高，但更大的缓存不能置于离CPU越近的地方，所以更大的缓存会比小的慢
- 多数游戏机采用至少两级缓存，CPU首先尝试在一级缓存（L1）中找数据，此缓存小，但有非常低的访问延迟。若数据不在则尝试在更大但更慢的二级缓存（L2）查找数据。只有在多级缓存中都查找不到数据时才选择在主内存中查找数据

**缓存一致性：MESI和MOESI**

- 通常每个核心备有其独立的L1缓存，但多个核心共享L2缓存及主内存
- 当出现多个核心时系统必须维持缓存一致性，需要确保数据在多个缓存及主内存里保持匹配，并不需要在每一刻都维持一致性，最重要的是运行时程序不能展示出缓存中的内容是不同步的
- MESI：基于失效的缓存一致性协议，是支持回写式缓存最常用的协议。用“脏”状态标识缓存中数据与主存中不同。要求在缓存不命中且数据块在另一个缓存时允许缓存到缓存的数据复制。
  - 状态：
    1. 已修改Modified（M）。缓存行是脏的，其数据和主存不同，若CPU要读取主存这块数据，该缓存行必须写到主存，且状态变为共享Shaderd
    2. 独占Exclusive（E）。缓存行只在当前缓存中，但是是干净的。当别的缓存读取时装态变为共享Shared，当写数据时变为已修改Modified
    3. 共享Shared（S）。缓存行也存在于其他缓存中，是干净的。缓存行可在任意时刻抛弃
    4. 无效Invalid（I）。缓存行是无效的
- MOESI：包含四个常见的MESI状态外，还有第五个Own状态，表示已修改和共享数据，避免在共享数据前将修改后的数据写回到主存储器，虽然最好仍需要回写数据，但可以推迟回写

**避免缓存命中失败**

- 避免数据缓存命中失败的最佳方法就是把数据编排进连续的内存块中，尺寸越小越好，并且顺序访问这些数据。当数据是连续的，单次命中失败便会把尽可能多的相关数据载入单个缓存线。若数据小就更有可能塞进单个缓存线
- 要避免指令缓存命中失败，最容易实践的是保持高性能循环的代码量越少越好，并避免在最内存的循环中调用函数，这样可以确保整个循环体能在运行的所有实践中保留在指令缓存中。若循环体需要调用函数，最好令被调用函数位于接近循环体代码的地方
- 多数C/C++链接器都有一些简单的规则：
  - 单个函数的机器码几乎总是置于连续的内存中，绝大多数情况下，链接器不会把一个函数切开并在中间放置另一个函数（内联函数除外）
  - 编译器和链接器按函数在翻译单元源代码中的出现次序排列内存布局
  - 位于一个编译单元内的函数总是置于连续内存中，链接器不会把已编译的翻译单元切开，中间插入其他翻译单元的代码。若使用函数级链接（某些编译器选项/Gy），那么编译的输出单位是函数，链接时各个函数不一定以翻译单元内的次序进行布局，还可以在链接时使用/ORDER选项自定义函数布局次序
- 一些经验法则：
  - 高效能代码的体积越小越好，以机器码指令数为单位
  - 在性能关键的代码中避免调用函数，若要调用则置于最接近调用函数的地方，最好是紧接调用函数的前后，而不要把该函数置于另一翻译单元
  - 谨慎使用内联函数，小的内联函数能增加效能，过多的内联会增大代码体积，使性能关键代码不能完全装入缓存

#### 3.4.3 指令流水线及超纯量CPU

- 两个紧密相关的增强CPU内并行性的架构技术：指令流水线、超纯量架构
- 指令流水线：当执行一个机器语言指令时，CPU必须以多个步骤执行。首先从内存或指令缓存中读取指令，然后指令被解码，接着执行指令。若指令要访问数据，则还需要执行一个内存访问周期。最后寄存器的内容可能回写到内存。每个步骤由CPU中独立电路执行，而这些电路连接到另一组电路组成一个流水线
- 流水线的延迟是指完成一个指令所需的时间，其等流水线中所有阶段的延迟之和。而流水线的带宽或吞吐量用于测量单位时间内能执行多少个指令的指标，流水线的带宽取决于最慢的阶段
- 超纯量处理器：包含多组冗余的电路，这些电路可能属于流水线中的部分或全部阶段，可以让CPU并行处理多个指令
- 不同的数据类型通常在CPU芯片上不同的电路上运作，这些CPU架构与超纯量架构相似，相似的地方在于不同的数据 类型的运算能同时执行，但对于真正的超纯量，CPU需要多个整数、浮点数以及矢量单元

**数据依赖及流水线停顿**

- 含流水线的CPU通过在每个始终周期发送新指令，尝试让所有阶段保持繁忙，若一个指令需要另一个指令的结果，较后的指令便必须等待较前的指令完全经过流水线所有阶段，这称为数据依赖，会导致流水停顿
- 富优化功能的编译器会尝试自动的重新编排机器指令的次序以避免停顿，例如让后面不依赖的机器指令先执行

**分支预测**

- 流水线停顿还可因为分支产生，遇到分支时含流水线的CPU便没有选择，只能猜测将会走哪个分支，CPU会继续发送所选的分支，希望猜测是正确的。当流水线完成的分支前的计算才知道所走的分支是对还是错的。若发现猜测结果是错的，则执行了不应该执行的指令，流水线必须清空再重新执行正确分支的指令
- CPU最简单的猜测方法是总是选择反向的分支，这种分支存在于while或for循环的结尾，而不选择向前的分支。
- 多数高品质的CPU包含分支预测硬件，可显著提升猜测的准确性。分支预测器会追踪分支指令在多个迭代中的结果，并发现模式以帮助在未来迭代中做更好的猜测。使用没有良好分支预测器的CPU时，需要由程序员去提升代码性能。可以重写关键性能的循环，减少分支甚至消除分支，一种做法是同时计算分支的两个结果，然后用无分支的机制去挑选结果，如用位掩码做逻辑与

**load-Hit-Store**

- load-Hit-Store是很差的流水线停顿，常出现在PowerPC架构上。CPU在讲float转换至int时，无法直接把数据从浮点寄存器传送至整数寄存器，因此必须将结果从浮点寄存器写入内存再从内存读入整数寄存器，这段时间整个流水线被迫停顿