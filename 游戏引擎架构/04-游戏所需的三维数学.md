### 4.2 点和矢量

#### 4.2.1 点和笛卡尔坐标

- 常用坐标系：
  1. 笛卡尔坐标系：使用两个或三个互相垂直的轴描述二维和三维空间的位置
  2. 圆柱坐标系：由3部分组成，分别是垂直“高度”轴h、从垂直轴发射出来的辐射轴r和yaw角度\theta
  3. 球坐标系：该坐标系也是由3部分组成的，分别是俯仰角、偏航角和半径长度r

#### 4.2.2 左手坐标系与右手坐标系的比较

- 左手和右手坐标系相互转换十分容易，只需要把其中一个轴翻转，并保留另外两个轴不变即可，数学法则在左手和右手坐标系里是不会改变，改变的只是我们如何把这些数字在脑海里诠释为三维空间。
- 左手和右手约定只应用在可视化过程中，并不影响底层的数学。利手对物理模拟中的叉积有影响，叉积的结果实际上并不是一个矢量，而是一个赝矢量的特殊数学对象

#### 4.2.3 矢量

- 大部分游戏程序员使用“矢量”一词来同时表示点（位置矢量）及矢量（纯方向性矢量）

#### 4.2.4 矢量运算

- 显式欧拉法（前向欧拉）：下一个值可以根据当前值及其倒数推测出来

  隐式欧拉法（后向欧拉）：后一个推测前一个

- 计算平方根在多数计算机上都是费时的运算，若可以，游戏程序员应尽量改用模的平方

- 若u为单位矢量，则点积a*u表示在u的方向定义的无限长度的直线上a的投影

- 模的平方可以用矢量和自身的点积计算，而要计算矢量的模则可以将点积开平方

- 点积适合判断两个矢量是否共线或垂直，或测试两个矢量是否大致在相同或相反的方向：

  1. 共线方向相同：a*b = |a||b|=ab，夹角为0，cos为1
  2. 共线方向相反：a*b=-ab
  3. 垂直：a*b=0
  4. 相同方向：a*b>0
  5. 相反方向：a*b<0

- 叉积的模等于两矢量各自的模的乘积再乘以两个矢量夹角的正弦值，若a和b是平行四边形的两条边，其面积为两矢量叉积的模|a x b|

- 若使用左手坐标系，则叉积使用左手法则来定义的，叉积的方向按选用的坐标系而改变

- 叉积特性：

  - 叉积不符合交换律但符合反交换率：a x b = -(b x a)
  - 叉积在加法上符合分配律：a x (b + c) = (a x b) + (a x c)
  - 叉乘和标量乘法可进行如下结合：(sa) x b = a x (sb) = s(a x b)
  - 3个叉积定义了绕笛卡尔轴的正旋方向，自x到y（绕z轴）、自y到z（绕x轴）、自z到x（y轴），当绕y轴旋转时，是按“反向”字母顺序，所以y轴的旋转矩阵相对于其他两轴是倒转的

- 叉积的应用：

  - 求垂直于两个矢量的矢量
  - 求三角形表面或其他平面的法矢量
  - 应用在物理模拟中，当向一物体施加力时，当且仅当器施力方向离开中心点时，该例会对物体的旋转运动产生影响

- 矢量和赝矢量区别并不显著，在平常游戏编程中应用到的各种变换并不能区分两者，仅当坐标系统反射，赝矢量的特殊性质才会显露出来，矢量经过反射变量后，矢量变成镜像，但赝矢量还会改变方向

- 位置及其所有导数都表示为真矢量，或成极矢量、逆变矢量。角速度及磁场都表示为赝矢量，或称为轴矢量、协变矢量、二重矢量、二阶片积。三角形通过叉积计算的表面法线也是赝矢量

- 叉积（A x B）、纯量三重积（A * （B x C））及矩阵的行列式都是相关的，而赝矢量是其中的核心

- 外代数或格拉斯曼代数描述了矢量与赝矢量如何运作，并可以计算二维中平行四边形的面积、三维中平行六边形的体积以至更高维的量

- 格斯曼代数的基本概念是引入一个特殊的矢量积，称为楔积（外积），记作A^B，两个矢量的楔积产生一个赝矢量

#### 4.2.5 点和矢量的线性插值

- 线性插值是一个简单的数学运算，用来计算两个已知点的中间点，从数学上看就是求两个矢量的加权平均：
  $$
  LERP(A,B,t) = (1 - t)A + tB
  $$

### 4.3 矩阵

- 若3x3矩阵中的所有行及列矢量为单位矢量，则该矩阵称为特殊正交矩阵、各向同性矩阵或标准正交矩阵。其表示一个纯旋转
- 仿射矩阵是一种4x4变换矩阵，它能维持直线在变换前后的平行性以及相对的距离比（即线性变换的特性），但不一定维持直线在变换前后的绝对长度及角度

#### 4.3.1 矩阵乘法

- 矩阵乘法不满足交换率，其次序会影响结果

#### 4.3.2 以矩阵表示点和矢量

- 行矢量或列矢量影响矩阵乘法的书写顺序：
  - 对于行矢量（1 x n），需要左乘矩阵
  - 对于列矢量（n x 1），需要右乘矩阵

#### 4.3.4 逆矩阵

- 矩阵A的逆矩阵A^-1能还原矩阵A的变换

- 并非所有的矩阵都有逆矩阵，然而对于仿射矩阵都有逆矩阵

- 逆矩阵可用高斯消元法或LU分解求得

- 矩阵串接后求逆相当于反向串接各个矩阵的逆矩阵：
  $$
  (ABC)^{-1}=C^{-1}B^{-1}A^{-1}
  $$

#### 4.3.5 转置矩阵

- 矩阵的转置写作M^T，就是把原来的矩阵以主对角线为对称轴做反射，将以前的行变成列，列变成行

- 转置矩阵的优良特性：

  1. 标准正交矩阵（纯旋转）的逆矩阵和转置矩阵是一样的，计算转置矩阵比计算逆矩阵快得多
  2. 对于有些数学库使用行矢量，有些使用列矢量的，当在两个数学库中进行通信时，使用转置

- 矩阵串接的转置等于反向串接各个矩阵的转置
  $$
  (ABC)^{T}=C^{T}B^{T}A^{T}
  $$

#### 4.3.6 齐次坐标

- 当矩阵变换一个点时，平移、旋转、缩放都会施加与点上。但当用矩阵变换一个方向矢量时，要忽略平移的效果，因为方向矢量本身并无平移
- 在齐次坐标中，可以把点的w分量设为1，而把方向矢量的w分量设为0

#### 4.3.7 基础变换矩阵

**旋转矩阵**

- cos(-a) = cos (a)，sin(-a) = -sin(a)，所以将角度求反等于将两个正弦项求反，余弦项不变。即逆矩阵等于转置矩阵 

**缩放矩阵**

- 对纯缩放矩阵求逆，相当于将各个部分用倒数替代
- 当缩放矩阵的三个轴的缩放因子相同，称为统一缩放。对于球体来说，统一缩放之后还是球体，若使用非同一缩放就会变成椭球。所以许多游戏引擎加上限制，只允许对对渲染和碰撞图元进行统一缩放
- 当将一个同一缩放矩阵和一个旋转矩阵串接时，相乘的次序不重要

#### 4.3.8 4x3矩阵

- 4x4 仿射矩阵的最右侧必然是一列 [0, 0, 0, 1]，所以游戏程序员可以省略该列节省内存

#### 4.3.9 坐标空间

**模型空间**

- 模型空间也可称物体空间或局部空间，其原点可置于物体的中心位置，如物体的质心，或人形及动物角色的足部
- 模型空间的轴通常会对准模型的自然方向，并以直观的标签为这些轴命令，若前向、向上、向左/向右

**世界空间**

- 世界空间是一个固定的坐标空间，游戏世界中的所有物体位置、定向、缩放都会用此空间表示。该坐标空间将所有单个的物体联系在一起，形成一个内聚的虚拟世界

**观察空间**

- 观察空间又称摄像机空间，是固定于摄像机的坐标系，原点置于摄像机的交点

#### 4.3.11 变换法矢量

- 若点或矢量可用3x3矩阵M将其从空间A转换至空间B，则法矢量可用该矩阵的逆转置矩阵(M^-1)^T变换。从另一个角度上看，法线是赝矢量，所以需要逆转矩阵

#### 4.3.12 在内存中存储矩阵

- C/C++中二维数组存储矩阵有两个选择：行主序或列主序

  行主序的好处：取矩阵中的每个矢量时都可以简单的按行索引，且内存布局中一个矢量也是连续的

  列主序的好处：在含矢量运算功能（如SIMD）的微处理器中可以进行快速矢量矩阵乘法

### 4.4 四元数

详见数学推导中四元数的推导

### 4.5 比较各种旋转表达方式

**欧拉角**

- 优势：

  1. 仅需三个浮点数，而且用三个角表示容易视觉化
  2. 对于围绕单个轴的旋转很容易进行插值，直接线性插值即可

  缺点：

  1. 对任意方向的旋转轴，欧拉角不能轻易插值
  2. 会遇见万向节死锁状况，当一个轴旋转90度时，三个主轴中的一个会与另一个主轴重合
  3. 欧拉角是按照一定次序进行旋转的，先后次序不一样结果也是不同的，一些领域没有特定的规范
  4.  对于要旋转的物体，欧拉角依赖从x/y/z轴以及其在各个方向的映射（万向节死锁破坏了这个映射），若没有额外信息是不知道哪个轴映射的哪个方向

**3x3矩阵**

- 优势：

  1. 方便有效的旋转表达方式，不收万向节死锁的影响，可以独一无二的表达任意旋转
  2. 旋转可以通过矩阵乘法直接了当的施于点或矢量
  3. 现在多数CPU及所有GPU都有硬件支持加速点乘和矩阵乘法
  4. 反转矩阵乘法直接使用逆矩阵，纯旋转可以使用转置矩阵替代逆矩阵，计算很简单

  缺点：

  1. 不太直观，当看见一个矩阵时无法简单的想成一个对应的三维旋转
  2. 不容易进行插值
  3. 需要9个浮点数进行存储

**轴角式**

- 优势：

  1. 轴角使用[x, y, z, \theta]表示，比较直观，且只需要4个浮点数

  缺点：

  1. 不能简单的进行插值
  2. 旋转不能直接施加于点或矢量，必须将轴角转换为矩阵或四元数

**四元数**

- 优势：
  1. 四元数乘法能串接旋转，且能直接将旋转施加于点和矢量
  2. 可以轻易使用LERP或SLERP运行进行旋转插值
  3. 只需存储为4个浮点数

**SQT变换**

- SQT变换是四元数结合平移矢量和缩放因子得到的4x4仿射矩阵的替代形式，当是非统一缩放时缩放因子是一个矢量（总共需要10个浮点数），若是统一缩放则是标量（总共需要8个浮点数）
- SQT变换广泛的应用在计算机动画中，容易进行插值，平移和缩放可以使用LERP，四元数LERP和SLERP均可

**对偶四元数**

- 对偶四元数的4个分量并非实数，而是对偶数。对偶数可写成非对偶部和对偶部之和：
  $$
  \hat{a}= a + b\varepsilon,\varepsilon^2 = 0
  $$
  因为每个对偶数都能表示成两个实部，所以对偶四元数表示为8个元素的矢量。

  也可表示为两个普通四元数之和，第二个四元数要乘以对偶单位（即上面那个）

- 对偶四元数相对于一般矢量和四元数的关键优点是，进行线性插值混合时，可以保持匀速、最短路径、坐标不变性，能简单的推广至3个或更多的变换混合

- 刚体变换是一种包含旋转和平移的变换，可以表示成对偶四元数

#### 4.5.7 旋转和自由度

- 自由度（DOF）描述物体有多少个独立可变的状态
- 所有三维旋转表达式都有3个或以上的浮点参数，一些表达方式也会对参数加上一个或一个以上的约束，这些约束表明参数间并非独立的，某参数的改变会带动其他参数的改变，以维持约束的正确性
- 旋转表达方式的自由度与约束：
  - 欧拉角：3个参数 - 0个约束 = 3个DOF
  - 轴角：4个参数 - 1个约束 = 3个DOF。约束：轴矢量为单位向量
  - 四元数：4个参数 - 1个约束 = 3个DOF。约束：四元数为单位长度
  - 3x3矩阵：9个参数 - 6个约束 = 3个DOF。约束：3个行矢量和3个列矢量都限制为单位长度

### 4.6 其他数学对象

#### 4.6.1 直线、光线及线段

- 一条无限长的直线可以表示为直线上某一点S沿直线方向的单位矢量u。直线的参数方程可从起点S沿单位矢量u方向移动任意距离t。无穷大的点积P称为标量t的矢量函数
  $$
  P(t) = S + tu,-\infty < t +\infty
  $$

- 光线也是直线，但光线只沿一个方向，可加上约束 t >= 0

- 线段受限于两个端点S1和S2，可以表示为一下两种形式：

  - $$
    P(t) = S_1 + tu, 0 <= t <= L,L = |S_1 - S_0|
    $$

  - $$
    P(t) = S_0 + tL, 0 <= t <= 1, L = S_1 - S_0
    $$

  形式2相对方便，因为参数t是归一化的，且不用专门存储L的长度

#### 4.6.2 球体

- 球体定义为中点C加上半径r，恰好能置于一个四元数矢量中，在SIMD矢量处理中把数据打包为矢量有显著的好处

#### 4.6.3 平面

- 平面方程可写为
  $$
  Ax+By+Cz+D = 0
  $$
  此方程只满足位于平面上点的轨迹。此方程中的参数A、B、C可诠释为三位适量，该矢量沿平面的法线方向，若对D进行归一化，即除以三个和的平方根，结果是平面到原点的距离，若法矢量指向原点，则d为正数，否则d为负数

- 平面方程也可用平面上一点P和其单位法矢量n来表示

- 可使用单位法矢量和平面至原点的距离表示位移平面，四个元素的矢量紧凑又方便，若点P是w=1的齐次坐标，该四元素矢量乘以P=0等价于点法式。将逆转矩阵施加于四元素矢量也能正确的把平面从一个空间变换至另一个空间

#### 4.6.4 轴对齐包围盒

- 轴对齐包围盒（AABB）是三维长方体，6个面都与某坐标系的正交轴对齐，AABB可用六元素矢量[Xmin,Xmax,Ymin,Ymax,Zmin,Zmax]表示

#### 4.6.5 定向包围盒

- 定向包围盒（OBB）也是三维长方体，但其定向与包围的物体按照某逻辑方式对齐，通常OBB与物体的局部空间轴对齐。常见测试点是否在OBB内，先将点转换至局部坐标再运用AABB方式检测

#### 4.6.6 平头截体

- 平头截体可方便的表示为6个平面的数组，每个平面以点法式表示，测试是否在平头截体内基本是用点积测出该点在每个平面的前面还是后面，若该点在6个平面内，则该点在平头截体内
- 一个有用的技巧是将要测试的世界空间点，通过摄像机的透视投影变换至齐次裁剪空间，世界空间的平头截体在此空间变为AABB，则可以简单进行内外测试

#### 4.6.7 凸多面体区域

- 凸多面体区域由任意数量的平面集合定义，屁股面的方向全向内或向外，测试一个点是否在平面构成的体积内，测试点是否在每个平面内即可

### 4.7 硬件加速的SIMD运算

- 单指令多数据（SIMD），现代微处理器能用一个指令并行的对多个数据执行数学运算
- SIMD广泛的应用在游戏引擎的数学库中，因为其能极迅速的执行常见的矢量运算
- 英特尔将多媒体扩展（MMX）指令集加入奔腾CPU产品线中，把8个8位整数、4个16位整数或两个32位整数载入特设的MMX寄存器后，MMX指令集就能对这些寄存器进行SIMD计算。英特尔陆续加入多个版本的扩展指令集称为单指令多数据流扩展（SSE）
- 游戏引擎中最常用的SSE模式为32位浮点数包裹模式，此模式中4个32位float值被打包进单个128寄存器，单个指令可对4对浮点数进行并行运算

#### 4.7.1 SSE寄存器

- 存储于SSE寄存器的4个浮点数，可以分别抽出存进内存，或从内存载入，但这类操作速度相对较慢。在x87FPU（浮点运算器）之间传送数据很糟糕，CPU必须等待x87单元或SSE单元完成所有正在进行的工作，会令CPU的整个指令执行流水线停顿，导致大量CPU周期被浪费，所以应该尽量避免普通浮点数运算和SIMD运算的混合代码
- 为了把内存、x87FPU寄存器和SSE寄存器之间的数据传输量降至最低，多数SIMD数学库都会尽量把数据保存在SSE寄存器中，且越久越好。这意味着标量值也保存在SSE寄存器中，而不传送至float变量

#### 4.7.2 __m128数据类型

- C/C++中，使用SSE128值颇为容易，vs编译器提供内键的__m128数据类型。该类型可用来声明全局变量、自动变量甚至是类或结构里的成员变量 。大多数情况下，该数据类型变量会存储于内存中，但在计算时会直接在CPU的SSE寄存器中运用（和一般内建数据类型类似，只是有些SIMD指令的寻址模式可以直接存取内存中的\_\_128数据），以\_\_m128声明的自动变量或函数参数，编译器通常直接置于SSE寄存器中而非内存的程序堆栈

**gcc的vector类型**

- GUN C/C++编译器gcc提供了一系列128位矢量类型，仅需在类型前加上关键字vector即可

**__128变量的对齐**

- 当一个__m128变量存储在内存中时，程序员有责任确保该变量是16字节对齐的，其最低有效半字节必须总是0x0，用于类和结构体会自动加入填充进行正确对齐。当编译器要动态分配数据结构时，程序员必须自己负责对齐

#### 4.7.3 用SSE内部函数编码

- SSE运算可用原始的汇编语言实现或C/C++中的内联汇编实现，但这么做即缺乏可移植性，比较复杂，且编译器限制了优化。为了更加简便，如今编译器都提供内部函数，它是一些特殊指令，形式和作用都和普通C函数类似，但编译器会将它们转化为内联汇编编码。多数内部函数会被翻译成单个汇编语言指令，但有些内部函数是宏，它们被翻译成一串指令。
- .cpp文件需要引用头文件xmmintrin.h才能使用__m128数据类型和SSE内部函数

```c++
#include <stdio.h>
#include <xmmintrin.h>

//内联汇编
__m128 addWithAssembly(const __m128 a, const __m128 b) {
	//有赖于调用约定，a和b已分别存储在xmm0和xmm1
	__asm addps xmm0, xmm1
	//根据调用约定，xmm0负责存储一个__128返回值，所以不需要任何事情去返回结果
}

//内部函数
__m128 addWithIntrinsics(const __m128 a, const __m128 b) {
	return _mm_add_ps(a, b);
}

void testSSE() {
    //__declspec(align(16))强制16字节对齐
	__declspec(align(16)) float A[4];
	__declspec(align(16)) float B[4] = {8.0f, 6.0f, 4.0f, 2.0f};

	__declspec(align(16)) float C[4];
	__declspec(align(16)) float D[4];

	//使用字面值设置a
	__m128 a = _mm_set_ps(1.0f, 2.0f, 3.0f, 4.0f);
	//从浮点数组载入b，B[]从后至前写入，因为Intel是小端机器
	__m128 b = _mm_load_ps(&B[0]);

	//测试函数
	__m128 c = addWithAssembly(a, b);
	__m128 d = addWithIntrinsics(a, b);

	//把a和b的值存储回之前的数组
	_mm_store_ps(&A[0], a);
	_mm_store_ps(&B[0], b);

	//将结果存储值数组
	_mm_store_ps(&C[0], c);
	_mm_store_ps(&D[0], d);

	printf("a = %g %g %g %g\n", A[0], A[1], A[2], A[3]);
	printf("b = %g %g %g %g\n", B[0], B[1], B[2], B[3]);
	printf("c = %g %g %g %g\n", C[0], C[1], C[2], C[3]);
	printf("d = %g %g %g %g\n", D[0], D[1], D[2], D[3]);
}

int main() {
	testSSE();

	return 0;
}
```

#### 4.7.4 用SSE实现矢量与矩阵的相乘

- $$
  \begin{bmatrix}
  r_x & r_y & r_z & r_w
  \end{bmatrix} = \begin{bmatrix}
  v_x & v_y & v_z & v_w
  \end{bmatrix} \begin{bmatrix}
  M_{11} & M_{12} & M_{13} & M_{14} \\
  M_{21} & M_{22} & M_{23} & M_{24} \\
  M_{31} & M_{32} & M_{33} & M_{34} \\
  M_{41} & M_{42} & M_{43} & M_{44} \\
  \end{bmatrix} \\ = \begin{bmatrix}
  v_xM_{11} + v_yM_{21} + v_zM_{31} + v_wM_{41}, 
  v_xM_{12} + v_yM_{22} + v_zM_{32} + v_wM_{43},
  v_xM_{13} + v_yM_{23} + v_zM_{33} + v_wM_{43},
  v_xM_{14} + v_yM_{24} + v_zM_{34} + v_wM_{44}
  \end{bmatrix}
  $$

- 若使用矢量v和M矩阵的每一列相乘，则需要对计算出的四个向量的四个分量进行加法。对于几乎所有SIMD架构把寄存器内的分量相加都是低效的

- 将矢量v中的每个分量单独复制成四个矢量，然后和每行进行相乘

  ```c++
  #define SHUFFLE_PARAM(x, y, z, w) ((x) | ((y) << 2) | ((z) << 4) | ((w) << 6))
  
  //_mm_shuffle_ps可以将SSE寄存器中的分量任意次序调乱
  #define _mm_replicate_x_ps(v) _mm_shuffle_ps((v), (v), SHUFFLE_PARAM(0, 0, 0, 0))
  #define _mm_replicate_y_ps(v) _mm_shuffle_ps((v), (v), SHUFFLE_PARAM(1, 1, 1, 1))
  #define _mm_replicate_z_ps(v) _mm_shuffle_ps((v), (v), SHUFFLE_PARAM(2, 2, 2, 2))
  #define _mm_replicate_w_ps(v) _mm_shuffle_ps((v), (v), SHUFFLE_PARAM(3, 3, 3, 3))
  
  __m128 mulVectorMatrixAttempt(const __m128& v, const __m128& mRow1, const __m128& mRow2, const __m128& mRow3, const __m128& mRow4) {
  	const __m128 xxxx = _mm_replicate_x_ps(v);
  	const __m128 yyyy = _mm_replicate_y_ps(v);
  	const __m128 zzzz = _mm_replicate_z_ps(v);
  	const __m128 wwww = _mm_replicate_w_ps(v);
  
  	const __m128 xMrow1 = _mm_mul_ps(xxxx, mRow1);
  	const __m128 yMrow2 = _mm_mul_ps(yyyy, mRow2);
  	const __m128 zMrow3 = _mm_mul_ps(zzzz, mRow3);
  	const __m128 wMrow4 = _mm_mul_ps(wwww, mRow4);
  
  	__m128 result = _mm_add_ps(xMrow1, yMrow2);
  	result = _mm_add_ps(result, zMrow3);
  	result = _mm_add_ps(result, wMrow4);
  
  	return result;
  }
  ```


### 4.8 产生随机数

- 随机数产生器实际上并不生成随机数，其产生的仅仅是复杂但完全确定性的、预定义的数列。这种序列称为伪随机序列
- 随机数产生器的好坏在于其产生多少个数字之后会重复，以及该序列在多个著名测试中的表现

#### 4.8.1 线性同余产生器

- 线性同余产生器（LCG）可以很简捷的产生伪随机序列，有些平台会使用该算法实现标准C语言库的rand()函数
  $$
  X_{n+1} = (aX_{n} + c) \% m
  $$

- LCG并不能产生特别高质量的伪随机序列，其产生的序列并不符合一些被广泛接受的准则，如长周期、高低位有接近的长周期、产生的值在序列上和空间上都无关联性等

#### 4.8.2 梅森旋转

- 梅森旋转（Mersenne Twister，MT）伪随机数产生器的算法是特别为改进LCG的众多问题而设计的，优点有：

  1. MT被设计有庞大的周期：2^19937 - 1
  2. MT有非常高阶的均匀分布维度，即其输出序列里的连续数字关联性微不足道
  3. MT通过了多个统计随机性的测试
  4. MT的速度很快

  缺点：内存占用大，且一般实现不具有密码学上的安全性

#### 4.8.3 所有伪随机数产生器之母及Xorshift

- 所有伪随机数产生器之母是一个94年发表的伪随机产生器算法，与MT相比更易实现且运行更快，生成该算法能产生32位伪随机数列，且其不重复周围为2^250，是当今为高速应用设计的最佳伪随机数产生器之一
- Xorshift随机性介于MT和所有伪随机数产生器之母之间，但运行速度稍快于所有伪随机数产生器之母

