### 5.1 子系统的启动和终止

- 引擎启动时，必须一次配置和初始化每个子系统，各个子系统间的相互一奶关系隐含定义了每个子系统所需启动的次序，被依赖的子系统要在依赖的子系统前先启动，终止则采用相反顺序

#### 5.1.1 C++的静态初始化次序（不可用）

- 在C++中，程序进入main函数之前，全局及静态对象已经被构建，但完全不可预知这些构造函数的调用顺序，函数结束返回后，也无法预知析构函数的调用顺序。所以全局对象不适合初始化及终止游戏引擎的子系统（在GCC中可以使用init_priority()属性设置变量的初始化顺序）
- 常见的设计模式是为每个子系统定义单例类，通常称为管理器，若C++能指明全局或静态实例的构建、析构次序，那么可以把单例定义为全局变量，而不必使用动态内存分配，但一般是无法直接控制的

**按需构建**

- 可以使用C++的小技巧：在函数内声明的静态变量并不会在main()函数前构建，而是在第一次调用该函数时构建。若将全局单例改为函数内的静态变量，则可以控制单例的构建次序。但这种方法不能控制析构顺序，且难以预计每个子系统单例确切构建的时间，只知道第一次调用get时创建，同时对于一个重量级的单例会有很高的开销

  ```c++
  class RenderManager {
  public:
  	static RenderManager& get() {
  		static RenderManager s_Instance;
  		return s_Instance;
  	}
  
  	RenderManager() {
  		//调用RenderManager依赖的子系统管理器的get()启动
  
  		//启动该子系统
  		get();
  	}
  
  	~RenderManager() {
  		//终止管理器
  	}
  };
  ```

- 含动态分配单例的变种get方法

  ```c++
  static RenderManager& get() {
  	static RenderManager* s_Instance = nullptr;
  	if (!s_Instance) {
  		s_Instance = new RenderManager();
  	}
  	ASSERT(s_Instance);
  	return *s_Instance;
  }
  ```

#### 5.1.2 行之有效的简单方法

- 若对子系统采用单例管理器最简单的蛮力方法就是明确的为各个单例管理器类定义启动和终止函数用以取代构造和析构函数，让构造和析构函数完全不做任何事情

  ```c++
  class RenderManager {
  public:
  	RenderManager() {
  		// Empty
  	}
  
  	~RenderManager() {
  		// Empty
  	}
  
  	void StartUp() {
  		//启动管理器
  	}
  
  	void ShutDown() {
  		//终止管理器
  	}
  };
  
  //创建所有管理器的全局变量
  RenderManager renderManager;
  
  int main() {
  	// 以正确次序启动各个子系统
  	renderManager.StartUp();
  
  	//游戏循环
  	while (true);
  
  	//以反向次序终止各个子系统
  	renderManager.ShutDown();
  
  	return 0;
  }
  ```

- 这种方法有更优雅的实现方式，如让各个管理器将自己登记在一个全局的有限队列中，按恰当次序逐一启动所有管理器。或通过每个管理器列举依赖的管理器，定义一个管理器之间的依赖图，然后按互相依赖关系计算最优的启动次序。作者认为蛮力方法总是优于其他方法：蛮力方法简单易实现，且看看代码就能得知子系统的启动次序，更容易调试和维护

#### 5.1.3 一些实际引擎启动终止的例子

**OGRE**

- OGRE中的一切对象都由Ogre::Root单例控制，该单例中含有指向其他OGRE子系统的指针，并负责启动和终止这些子系统。程序可以轻松启动OGRE，只需new一个Ogre::Root即可。OGRE中提供了一个Ogre::Singleton模板基类，所有管理器都派生自此基类，在基类的实现里并不会进行延迟构建，而是依赖于Root明确的new每一个单例

  ```c++
  class _OgreExport Root : public Singleton<Root> {
  	//其他成员
  
  	//各个单例
  	LogManager* mLogManager;
  	...
  };
  
  Root::Root(...) {
  	//基类会检查单例
  
  	//初始化系统
  
  	//构建以启动子系统
  }
  ```

**顽皮狗的神秘海域系列和最后生还者**

- 该引擎采用了相似的明确方法去启动和终止各个子系统，其中并不是总是一串简单的单例分配，许多不同的操作系统服务和第三方库都必须在引擎初始化时启动，且在可行情况下尽量避免动态分配

### 5.2 内存管理

- 内存对效能的影响有两方面：
  1. 以malloc()或全局new运算符进行动态内存分配是非常慢的操作，要提升效能最佳的方法是尽量避免动态分配内存，或利用自制的内存分配器来大大减低分配成本
  2. 在现代的CPU上，软件的效能受其内存访问模式主宰，把数据置于细小连续的内存块，相比把数据分散至广阔的内存地址，CPU对前者的操作会高效的多

#### 5.2.1 优化动态内存分配

- 通过malloc()和全局new运算符动态分配内存又称为对分配，其低效的原因主要有两个：

  1. 堆分配器是通用的设施，必须处理任何大小的内存分配请求，这需要大量的管理开销。
  2. 在多数操作系统中，malloc必然会从用户模式切换至内核模式处理请求，再切换至原来的程序，这些上下文切换可能会耗费非常多的时间

  常见经验法则：维持最低限度的对分配，且永不在紧凑循环中使用堆分配

- 多数游戏引擎会实现一个或多个定制分配器。定制分配器能享有比操作系统分配器更优的性能：

  1. 定制分配器从预分配的内存中完成分配请求，这样分配过程都在用户模式下执行，完全避免了进入操作系统的上下文切换
  2. 通过对定制分配器的使用模式做出多个假设，定制分配器便可以比通用堆分配器高效的多

**基于堆栈的分配器**

- 堆栈分配器是非常容易实现的。要分配一大块连续内存，可简单的使用malloc()、全局new或是声明一个全局字节数组，再胺片一个指针指向堆栈的顶端，指针以下的部分是已分配的，指针以上的是未分配的。对于每个分配请求，仅需把指针往上移动请求所需的字节数量。要释放最后分配的内存块也只需要把指针向下移动该内存块的字节数量

- 使用堆栈分配器时，不能以任意次序释放内存，必须以分配时相反的次序释放内存。有一个简单的方法可以简单的实施此限制，即完全不允许释放个别的内存块，而提供一个函数，该函数可以把堆栈顶端指针回滚至之前标记了的位置，那么其实际上的意义就是释放从回滚点至目前堆栈顶端之间的所有内存。为保证正确回滚，堆栈分配器通常提供一个函数，该函数传回一个标记，代表目前堆栈的顶端，而回滚函数则使用这个标记作为参数

  回滚顶端指针时，回滚位置必须位于两个分配内存块之间的边界，否则分配新内存块时会覆盖前一个内存块或会多出一块内存块碎片。

  ```
  class StackAllocator {
  public:
  	// 堆栈标记：表示堆栈的当前顶端
  	// 用户只可以回滚一个标记，而不是堆栈的任意位置
  	typedef uint32_t Marker;
  	
  	// 构建堆栈分配器
  	// @param stackSize_bytes 构建的内存块大小
  	explicit StackAllocator(uint32_t stackSize_bytes);
  
  	// 从堆栈地段分配一个新的内存块
  	// @param stackSize_bytes 构建的内存块大小
  	void* alloc(uint32_t size_bytes);
  
  	// 获取指向当前堆栈的标记
  	Marker getMarker();
  
  	// 把堆栈回滚至之前的标记
  	void freeToMarker(Marker marker);
  
  	// 清空堆栈
  	void clear();
  
  private:
  };
  ```

**双端堆栈分配器**

- 双端堆栈分配器：一块内存可以给两个堆栈分配器使用，一个内存块的底端向上分配，另一个从内存块的顶端向下分配。它允许权衡地段堆栈和顶端堆栈的使用，使它能够有效的运用内存

**池分配器**

- 池分配器的工作方式如下：首先会预分配一大块内存，其大小是分配元素大小的倍数，池内的每个元素都被加到一个存放自由元素的链表，在对池进行初始化时，自由列表包含所有元素，池分配器收到分配请求时，就会把自由链表的下一个元素取出，并传回该元素，释放元素只需简单的把元素插回自由链表中，分配和释放都是O(1)操作
- 存储自由元素的链表可实现为单链，即每个自由元素都需要存储一个指针，这种情况取得这些存储指针的内存可以再预分配另一块内存存储这些指针，内存块的大小为sizeof(void\*)\*元素数量，但比较浪费。若元素尺寸大于指针，可以使用自由列表内的内存块存储指针。当元素尺寸小于指针时，可以使用池元素的索引代替指针去实现链表。（分配器只用管分配）

