### 5.1 子系统的启动和终止

- 引擎启动时，必须一次配置和初始化每个子系统，各个子系统间的相互一奶关系隐含定义了每个子系统所需启动的次序，被依赖的子系统要在依赖的子系统前先启动，终止则采用相反顺序

#### 5.1.1 C++的静态初始化次序（不可用）

- 在C++中，程序进入main函数之前，全局及静态对象已经被构建，但完全不可预知这些构造函数的调用顺序，函数结束返回后，也无法预知析构函数的调用顺序。所以全局对象不适合初始化及终止游戏引擎的子系统（在GCC中可以使用init_priority()属性设置变量的初始化顺序）
- 常见的设计模式是为每个子系统定义单例类，通常称为管理器，若C++能指明全局或静态实例的构建、析构次序，那么可以把单例定义为全局变量，而不必使用动态内存分配，但一般是无法直接控制的

**按需构建**

- 可以使用C++的小技巧：在函数内声明的静态变量并不会在main()函数前构建，而是在第一次调用该函数时构建。若将全局单例改为函数内的静态变量，则可以控制单例的构建次序。但这种方法不能控制析构顺序，且难以预计每个子系统单例确切构建的时间，只知道第一次调用get时创建，同时对于一个重量级的单例会有很高的开销

  ```c++
  class RenderManager {
  public:
  	static RenderManager& get() {
  		static RenderManager s_Instance;
  		return s_Instance;
  	}
  
  	RenderManager() {
  		//调用RenderManager依赖的子系统管理器的get()启动
  
  		//启动该子系统
  		get();
  	}
  
  	~RenderManager() {
  		//终止管理器
  	}
  };
  ```

- 含动态分配单例的变种get方法

  ```c++
  static RenderManager& get() {
  	static RenderManager* s_Instance = nullptr;
  	if (!s_Instance) {
  		s_Instance = new RenderManager();
  	}
  	ASSERT(s_Instance);
  	return *s_Instance;
  }
  ```

#### 5.1.2 行之有效的简单方法

- 若对子系统采用单例管理器最简单的蛮力方法就是明确的为各个单例管理器类定义启动和终止函数用以取代构造和析构函数，让构造和析构函数完全不做任何事情

  ```c++
  class RenderManager {
  public:
  	RenderManager() {
  		// Empty
  	}
  
  	~RenderManager() {
  		// Empty
  	}
  
  	void StartUp() {
  		//启动管理器
  	}
  
  	void ShutDown() {
  		//终止管理器
  	}
  };
  
  //创建所有管理器的全局变量
  RenderManager renderManager;
  
  int main() {
  	// 以正确次序启动各个子系统
  	renderManager.StartUp();
  
  	//游戏循环
  	while (true);
  
  	//以反向次序终止各个子系统
  	renderManager.ShutDown();
  
  	return 0;
  }
  ```

- 这种方法有更优雅的实现方式，如让各个管理器将自己登记在一个全局的有限队列中，按恰当次序逐一启动所有管理器。或通过每个管理器列举依赖的管理器，定义一个管理器之间的依赖图，然后按互相依赖关系计算最优的启动次序。作者认为蛮力方法总是优于其他方法：蛮力方法简单易实现，且看看代码就能得知子系统的启动次序，更容易调试和维护

#### 5.1.3 一些实际引擎启动终止的例子

**OGRE**

- OGRE中的一切对象都由Ogre::Root单例控制，该单例中含有指向其他OGRE子系统的指针，并负责启动和终止这些子系统。程序可以轻松启动OGRE，只需new一个Ogre::Root即可。OGRE中提供了一个Ogre::Singleton模板基类，所有管理器都派生自此基类，在基类的实现里并不会进行延迟构建，而是依赖于Root明确的new每一个单例

  ```c++
  class _OgreExport Root : public Singleton<Root> {
  	//其他成员
  
  	//各个单例
  	LogManager* mLogManager;
  	...
  };
  
  Root::Root(...) {
  	//基类会检查单例
  
  	//初始化系统
  
  	//构建以启动子系统
  }
  ```

**顽皮狗的神秘海域系列和最后生还者**

- 该引擎采用了相似的明确方法去启动和终止各个子系统，其中并不是总是一串简单的单例分配，许多不同的操作系统服务和第三方库都必须在引擎初始化时启动，且在可行情况下尽量避免动态分配

### 5.2 内存管理

- 内存对效能的影响有两方面：
  1. 以malloc()或全局new运算符进行动态内存分配是非常慢的操作，要提升效能最佳的方法是尽量避免动态分配内存，或利用自制的内存分配器来大大减低分配成本
  2. 在现代的CPU上，软件的效能受其内存访问模式主宰，把数据置于细小连续的内存块，相比把数据分散至广阔的内存地址，CPU对前者的操作会高效的多

#### 5.2.1 优化动态内存分配

- 通过malloc()和全局new运算符动态分配内存又称为对分配，其低效的原因主要有两个：

  1. 堆分配器是通用的设施，必须处理任何大小的内存分配请求，这需要大量的管理开销。
  2. 在多数操作系统中，malloc必然会从用户模式切换至内核模式处理请求，再切换至原来的程序，这些上下文切换可能会耗费非常多的时间

  常见经验法则：维持最低限度的对分配，且永不在紧凑循环中使用堆分配

- 多数游戏引擎会实现一个或多个定制分配器。定制分配器能享有比操作系统分配器更优的性能：

  1. 定制分配器从预分配的内存中完成分配请求，这样分配过程都在用户模式下执行，完全避免了进入操作系统的上下文切换
  2. 通过对定制分配器的使用模式做出多个假设，定制分配器便可以比通用堆分配器高效的多

**基于堆栈的分配器**

- 堆栈分配器是非常容易实现的。要分配一大块连续内存，可简单的使用malloc()、全局new或是声明一个全局字节数组，再胺片一个指针指向堆栈的顶端，指针以下的部分是已分配的，指针以上的是未分配的。对于每个分配请求，仅需把指针往上移动请求所需的字节数量。要释放最后分配的内存块也只需要把指针向下移动该内存块的字节数量

- 使用堆栈分配器时，不能以任意次序释放内存，必须以分配时相反的次序释放内存。有一个简单的方法可以简单的实施此限制，即完全不允许释放个别的内存块，而提供一个函数，该函数可以把堆栈顶端指针回滚至之前标记了的位置，那么其实际上的意义就是释放从回滚点至目前堆栈顶端之间的所有内存。为保证正确回滚，堆栈分配器通常提供一个函数，该函数传回一个标记，代表目前堆栈的顶端，而回滚函数则使用这个标记作为参数

  回滚顶端指针时，回滚位置必须位于两个分配内存块之间的边界，否则分配新内存块时会覆盖前一个内存块或会多出一块内存块碎片。

  ```c++
  class StackAllocator {
  public:
  	// 堆栈标记：表示堆栈的当前顶端
  	// 用户只可以回滚一个标记，而不是堆栈的任意位置
  	typedef uint32_t Marker;
  	
  	// 构建堆栈分配器
  	// @param stackSize_bytes 构建的内存块大小
  	explicit StackAllocator(uint32_t stackSize_bytes);
  
  	// 从堆栈地段分配一个新的内存块
  	// @param stackSize_bytes 构建的内存块大小
  	void* alloc(uint32_t size_bytes);
  
  	// 获取指向当前堆栈的标记
  	Marker getMarker();
  
  	// 把堆栈回滚至之前的标记
  	void freeToMarker(Marker marker);
  
  	// 清空堆栈
  	void clear();
  
  private:
  };
  ```

**双端堆栈分配器**

- 双端堆栈分配器：一块内存可以给两个堆栈分配器使用，一个内存块的底端向上分配，另一个从内存块的顶端向下分配。它允许权衡地段堆栈和顶端堆栈的使用，使它能够有效的运用内存

**池分配器**

- 池分配器的工作方式如下：首先会预分配一大块内存，其大小是分配元素大小的倍数，池内的每个元素都被加到一个存放自由元素的链表，在对池进行初始化时，自由列表包含所有元素，池分配器收到分配请求时，就会把自由链表的下一个元素取出，并传回该元素，释放元素只需简单的把元素插回自由链表中，分配和释放都是O(1)操作
- 存储自由元素的链表可实现为单链，即每个自由元素都需要存储一个指针，这种情况取得这些存储指针的内存可以再预分配另一块内存存储这些指针，内存块的大小为sizeof(void\*)\*元素数量，但比较浪费。若元素尺寸大于指针，可以使用自由列表内的内存块存储指针。当元素尺寸小于指针时，可以使用池元素的索引代替指针去实现链表。（分配器只用管分配）

**含对齐功能的分配器**

- 所有内存分配器都必须能传回对齐的内存块。实现该功能只要在分配内存时，分配比请求所需多一点的内存，再向上调整其内存地址至矢量的对齐，最后传回调整后的地址。在多数的实现中，额外分配的字节等于对齐字节
- 计算调整偏移量方法如下：用掩码把原本内存块地址的最低有效位取出，再用期望的对齐减去此值，结果就是调整偏移量。对齐应总是2的幂，要计算掩码只要用对齐减1就行了

```c++
void* allocateAligned(size_t size_bytes, size_t alignment) {
	// 对齐必须是2的幂
	ASSERT((alignment & (alignment - 1)) == 0);
	// 共要分配的内存量
	size_t expandedSize_bytes = size_bytes + alignment;
	// 分配未对齐的内存块，并转换地址为uintptr_t
	uintptr_t rawAddress = reinterpret_cast<uintptr_t>(allocateUnaligned(expandedSize_bytes));
	// 使用掩码去除地址低位部分，计算“错位”量，从而计算调整量
	size_t mask = (alignment - 1);
	uintptr_t misalignment = (rawAddress & mask);
	ptrdiff_t adjustment = alignment - misalignment;
	// 计算调整后的地址，并以指针类型返回
	uintptr_t alignedAddress = rawAddress + adjustment;
	return static_cast<void*>(alignedAddress);
}
```

- 当要释放此内存块时，代码会传给分配器调整后的地址，而非原本分配的地址，所以需要将调整后的地址转换成原本的、可能未对齐的地址。可以存储一些元信息至额外分配的内存，最少的调整量为1字节，而偏移量不会超过1字节（256），可以将偏移量存储至调整后地址之前的1字节，这样就能简单的从调整后地址取回偏移量，并计算原本的地址

```c++
void* allocateAligned(size_t size_bytes, size_t alignment) {
	ASSERT(alignment >= 1);
	ASSERT(alignment <= 128);
	// 对齐必须是2的幂
	ASSERT((alignment & (alignment - 1)) == 0);
	// 共要分配的内存量
	size_t expandedSize_bytes = size_bytes + alignment;
	// 分配未对齐的内存块，并转换地址为uintptr_t
	uintptr_t rawAddress = reinterpret_cast<uintptr_t>(allocateUnaligned(expandedSize_bytes));
	// 使用掩码去除地址低位部分，计算“错位”量，从而计算调整量
	size_t mask = (alignment - 1);
	uintptr_t misalignment = (rawAddress & mask);
	ptrdiff_t adjustment = alignment - misalignment;
	// 计算调整后的地址
	uintptr_t alignedAddress = rawAddress + adjustment;
	// 将alignment存储在调整后地址的前4字节
	ASSERT(adjustment < 256);
	uint8_t* pAdjustment = reinterpret_cast<uint8_t*>(alignedAddress);
	pAdjustment[-1] = static_cast<uint8_t>(adjustment);

	return static_cast<void*>(alignedAddress);
}

void freeAligned(void* pMem) {
	const uint8_t* pAlignedMem = reinterpret_cast<const uint8_t*>(pMem);
	uintptr_t alignedAddress = reinterpret_cast<uintptr_t>(pMem);
	ptrdiff_t adjustment = static_cast<ptrdiff_t>(pAlignedMem[-1]);
	uintptr_t rawAddress = alignedAddress - adjustment;
	void* pRawMem = reinterpret_cast<void*>(rawAddress);

	freeUnaligned(pRawMem);
}
```

**单帧和双缓冲内存分配器**

- 几乎所有游戏引擎都会在游戏循环中分配一些临时用数据，要么在循环结束时丢弃，要么在下一次迭代结束时丢弃。很多游戏引擎都支持单帧分配器和双缓冲分配器来管理类似数据

- 实现单帧分配器要预留一块内存，以简单堆栈分配器管理，在每帧开始时，把堆栈的顶端指针重置到内存块的底端地址，该帧中分配要求使堆栈向上成长，该过程不断重复

  ```c++
  StackAllocator g_singleFrameAllocator;
  
  // 游戏循环
  while (true) {
  	//每帧清除单帧分配器的缓冲区
  	g_singleFrameAllocator.clear();
  
  	//从单帧分配器中分配内存，不需要手动设防这些内存，但要确保这些内存仅在本帧中使用
  	void* p = g_singleFrameAllocator.alloc(nBytes);
  
  	...
  }
  ```

  单帧分配器的主要好处是分配的内存永不用手动释放，依赖于每帧开始时分配器会自动清除所有内存，且其十分高效。缺点是从单帧分配的内存块只能在当前帧有效，程序员不能把指向单帧内存块的指针跨帧使用

- 双缓冲分配器允许在第i帧分配的内存块用于第(i + 1)帧，实现方法是建立两个相同尺寸的单帧堆栈分配器，并在每帧交替使用

  ```c++
  class DoubleBufferedAllcator {
  public:
  	void swapBuffers() {
  		m_curStack = (uint32_t)!m_curStack;
  	}
  
  	void clearCurrentBuffer() {
  		m_stack[m_curStack].clear();
  	}
  
  	void* alloc(uint32_t mBytes) {
  		return m_stack[m_curStack].alloc(mBytes);
  	}
  
  private:
  	uint32_t m_curStack;
  	StackAllocator m_stack[2];
  };
  
  DoubleBufferedAllcator g_doubleBufAllocator;
  
  // 游戏循环
  while (true) {
  
  	// 交换缓冲区
  	g_doubleBufAllocator.swapBuffers();
  	// 清空当前缓冲区，保留前帧的缓冲不变
  	g_doubleBufAllocator.clearCurrentBuffer();
  	// 从双缓冲分配器中分配内存，不影响前一帧的数据
  	// 确保分配的内存仅在本帧或下一帧中使用
  	void* p = g_doubleBufAllocator.alloc(bytes);
  
  	... 
  }
  ```

  其在多核处理器中，缓冲异步处理结果时非常有用，可以防止异步处理的结果被覆盖掉

#### 5.2.2 内存碎片

- 动态对分配的另一个问题在于会随时间产生内存碎片，当程序启动时整个堆空间都是自由的，当分配一块内存时，一块合适尺寸的连续内存块便会标记为"使用中"，而其余内存仍是自由的。当释放内存块时，该内存块便会与相邻内存块合并形成单个更大的自由内存块。但多次分配和释放后，内存就会被划分为很多小块，此时虽然有足够的内存进行分配，但无法形成连续的内存块分配出去
- 在支持虚拟内存的操作系统中，内存碎片并非大问题，其使用分页分段技术让不连续的内存页对应用程序来说是连续的。多数嵌入式设备负担不起虚拟内存的实现，现代某些游戏机虽然技术上能支持虚拟内存，但由于其开销太大，多数游戏引擎不会使用虚拟内存

**以堆栈和池分配器避免内存碎片**

- 堆分配器或池分配器可以避免一些内存分配带来的问题：
  1. 堆栈分配器完全避免了内存碎片的产生，其分配的内存总是连续，释放总是以相反次序释放
  2. 池分配器也无内存碎片问题，虽然实际上池会产生碎片，但这些碎片不会像一般的堆，提前引发内存不足的情况，像池分配器做分配请求时，不会因缺乏足够大的连续内存块，而造成分配失败，因为池内所有内存块是完全一样大的

**碎片整理及重定位**

- 若要分配和释放不同大小的对象并以随机次序进行，则堆栈和池分配器也不适用。对于该情况可以对堆定期进行碎片整理，其方法是将内存从高位移至地位。

- 一个简单的方法是搜寻第一个碎片，然后将碎片上面紧接的内存块向下移，重复进行该操作，直至将所有的已分配的内存全移至底端，碎片全移至顶端，形成连续的自由空间。但若有指针指向要被移动的内存块，在移动后这些指针便会失效

  其中一个解决方法是，将指向要移动内存块的指针逐一更新，使移动内存块指针仍能指到新的地址，该过程称为指针重定位。但在C/C++中没有方法可以搜寻所有指向某地址范围的指针，若要在引擎中支持碎片整理功能，程序员必须小心手动维护所有指针，在重定位时正确更新指针

  另一个选择是舍弃指针，取而代之使用重定位时更容易修改的构件，如智能指针或句柄

- 智能指针是细小的类，包含一个指针并且其实际行为几乎和普通指针完全相同。但由于智能指针是用类实现的，可以编写的代码正确处理内存重定位。如让所有智能指针把自己加进一个全局链表中，当要移动某块内存时便可扫描全局链表更新每个指向该内存的智能指针

- 句柄通常实现为索引，这些索引指向句柄表内的元素，每个元素存储指针
