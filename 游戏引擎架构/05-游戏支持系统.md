### 5.1 子系统的启动和终止

- 引擎启动时，必须一次配置和初始化每个子系统，各个子系统间的相互一奶关系隐含定义了每个子系统所需启动的次序，被依赖的子系统要在依赖的子系统前先启动，终止则采用相反顺序

#### 5.1.1 C++的静态初始化次序（不可用）

- 在C++中，程序进入main函数之前，全局及静态对象已经被构建，但完全不可预知这些构造函数的调用顺序，函数结束返回后，也无法预知析构函数的调用顺序。所以全局对象不适合初始化及终止游戏引擎的子系统（在GCC中可以使用init_priority()属性设置变量的初始化顺序）
- 常见的设计模式是为每个子系统定义单例类，通常称为管理器，若C++能指明全局或静态实例的构建、析构次序，那么可以把单例定义为全局变量，而不必使用动态内存分配，但一般是无法直接控制的

**按需构建**

- 可以使用C++的小技巧：在函数内声明的静态变量并不会在main()函数前构建，而是在第一次调用该函数时构建。若将全局单例改为函数内的静态变量，则可以控制单例的构建次序。但这种方法不能控制析构顺序，且难以预计每个子系统单例确切构建的时间，只知道第一次调用get时创建，同时对于一个重量级的单例会有很高的开销

  ```c++
  class RenderManager {
  public:
  	static RenderManager& get() {
  		static RenderManager s_Instance;
  		return s_Instance;
  	}
  
  	RenderManager() {
  		//调用RenderManager依赖的子系统管理器的get()启动
  
  		//启动该子系统
  		get();
  	}
  
  	~RenderManager() {
  		//终止管理器
  	}
  };
  ```

- 含动态分配单例的变种get方法

  ```c++
  static RenderManager& get() {
  	static RenderManager* s_Instance = nullptr;
  	if (!s_Instance) {
  		s_Instance = new RenderManager();
  	}
  	ASSERT(s_Instance);
  	return *s_Instance;
  }
  ```

#### 5.1.2 行之有效的简单方法

- 若对子系统采用单例管理器最简单的蛮力方法就是明确的为各个单例管理器类定义启动和终止函数用以取代构造和析构函数，让构造和析构函数完全不做任何事情

  ```c++
  class RenderManager {
  public:
  	RenderManager() {
  		// Empty
  	}
  
  	~RenderManager() {
  		// Empty
  	}
  
  	void StartUp() {
  		//启动管理器
  	}
  
  	void ShutDown() {
  		//终止管理器
  	}
  };
  
  //创建所有管理器的全局变量
  RenderManager renderManager;
  
  int main() {
  	// 以正确次序启动各个子系统
  	renderManager.StartUp();
  
  	//游戏循环
  	while (true);
  
  	//以反向次序终止各个子系统
  	renderManager.ShutDown();
  
  	return 0;
  }
  ```

- 这种方法有更优雅的实现方式，如让各个管理器将自己登记在一个全局的有限队列中，按恰当次序逐一启动所有管理器。或通过每个管理器列举依赖的管理器，定义一个管理器之间的依赖图，然后按互相依赖关系计算最优的启动次序。作者认为蛮力方法总是优于其他方法：蛮力方法简单易实现，且看看代码就能得知子系统的启动次序，更容易调试和维护

#### 5.1.3 一些实际引擎启动终止的例子

**OGRE**

- OGRE中的一切对象都由Ogre::Root单例控制，该单例中含有指向其他OGRE子系统的指针，并负责启动和终止这些子系统。程序可以轻松启动OGRE，只需new一个Ogre::Root即可。OGRE中提供了一个Ogre::Singleton模板基类，所有管理器都派生自此基类，在基类的实现里并不会进行延迟构建，而是依赖于Root明确的new每一个单例

  ```c++
  class _OgreExport Root : public Singleton<Root> {
  	//其他成员
  
  	//各个单例
  	LogManager* mLogManager;
  	...
  };
  
  Root::Root(...) {
  	//基类会检查单例
  
  	//初始化系统
  
  	//构建以启动子系统
  }
  ```

**顽皮狗的神秘海域系列和最后生还者**

- 该引擎采用了相似的明确方法去启动和终止各个子系统，其中并不是总是一串简单的单例分配，许多不同的操作系统服务和第三方库都必须在引擎初始化时启动，且在可行情况下尽量避免动态分配

### 5.2 内存管理

- 内存对效能的影响有两方面：
  1. 以malloc()或全局new运算符进行动态内存分配是非常慢的操作，要提升效能最佳的方法是尽量避免动态分配内存，或利用自制的内存分配器来大大减低分配成本
  2. 在现代的CPU上，软件的效能受其内存访问模式主宰，把数据置于细小连续的内存块，相比把数据分散至广阔的内存地址，CPU对前者的操作会高效的多

#### 5.2.1 优化动态内存分配

- 通过malloc()和全局new运算符动态分配内存又称为对分配，其低效的原因主要有两个：

  1. 堆分配器是通用的设施，必须处理任何大小的内存分配请求，这需要大量的管理开销。
  2. 在多数操作系统中，malloc必然会从用户模式切换至内核模式处理请求，再切换至原来的程序，这些上下文切换可能会耗费非常多的时间

  常见经验法则：维持最低限度的对分配，且永不在紧凑循环中使用堆分配

- 多数游戏引擎会实现一个或多个定制分配器。定制分配器能享有比操作系统分配器更优的性能：

  1. 定制分配器从预分配的内存中完成分配请求，这样分配过程都在用户模式下执行，完全避免了进入操作系统的上下文切换
  2. 通过对定制分配器的使用模式做出多个假设，定制分配器便可以比通用堆分配器高效的多

**基于堆栈的分配器**

- 堆栈分配器是非常容易实现的。要分配一大块连续内存，可简单的使用malloc()、全局new或是声明一个全局字节数组，再胺片一个指针指向堆栈的顶端，指针以下的部分是已分配的，指针以上的是未分配的。对于每个分配请求，仅需把指针往上移动请求所需的字节数量。要释放最后分配的内存块也只需要把指针向下移动该内存块的字节数量

- 使用堆栈分配器时，不能以任意次序释放内存，必须以分配时相反的次序释放内存。有一个简单的方法可以简单的实施此限制，即完全不允许释放个别的内存块，而提供一个函数，该函数可以把堆栈顶端指针回滚至之前标记了的位置，那么其实际上的意义就是释放从回滚点至目前堆栈顶端之间的所有内存。为保证正确回滚，堆栈分配器通常提供一个函数，该函数传回一个标记，代表目前堆栈的顶端，而回滚函数则使用这个标记作为参数

  回滚顶端指针时，回滚位置必须位于两个分配内存块之间的边界，否则分配新内存块时会覆盖前一个内存块或会多出一块内存块碎片。

  ```c++
  class StackAllocator {
  public:
  	// 堆栈标记：表示堆栈的当前顶端
  	// 用户只可以回滚一个标记，而不是堆栈的任意位置
  	typedef uint32_t Marker;
  	
  	// 构建堆栈分配器
  	// @param stackSize_bytes 构建的内存块大小
  	explicit StackAllocator(uint32_t stackSize_bytes);
  
  	// 从堆栈地段分配一个新的内存块
  	// @param stackSize_bytes 构建的内存块大小
  	void* alloc(uint32_t size_bytes);
  
  	// 获取指向当前堆栈的标记
  	Marker getMarker();
  
  	// 把堆栈回滚至之前的标记
  	void freeToMarker(Marker marker);
  
  	// 清空堆栈
  	void clear();
  
  private:
  };
  ```

**双端堆栈分配器**

- 双端堆栈分配器：一块内存可以给两个堆栈分配器使用，一个内存块的底端向上分配，另一个从内存块的顶端向下分配。它允许权衡地段堆栈和顶端堆栈的使用，使它能够有效的运用内存

**池分配器**

- 池分配器的工作方式如下：首先会预分配一大块内存，其大小是分配元素大小的倍数，池内的每个元素都被加到一个存放自由元素的链表，在对池进行初始化时，自由列表包含所有元素，池分配器收到分配请求时，就会把自由链表的下一个元素取出，并传回该元素，释放元素只需简单的把元素插回自由链表中，分配和释放都是O(1)操作
- 存储自由元素的链表可实现为单链，即每个自由元素都需要存储一个指针，这种情况取得这些存储指针的内存可以再预分配另一块内存存储这些指针，内存块的大小为sizeof(void\*)\*元素数量，但比较浪费。若元素尺寸大于指针，可以使用自由列表内的内存块存储指针。当元素尺寸小于指针时，可以使用池元素的索引代替指针去实现链表。（分配器只用管分配）

**含对齐功能的分配器**

- 所有内存分配器都必须能传回对齐的内存块。实现该功能只要在分配内存时，分配比请求所需多一点的内存，再向上调整其内存地址至矢量的对齐，最后传回调整后的地址。在多数的实现中，额外分配的字节等于对齐字节
- 计算调整偏移量方法如下：用掩码把原本内存块地址的最低有效位取出，再用期望的对齐减去此值，结果就是调整偏移量。对齐应总是2的幂，要计算掩码只要用对齐减1就行了

```c++
void* allocateAligned(size_t size_bytes, size_t alignment) {
	// 对齐必须是2的幂
	ASSERT((alignment & (alignment - 1)) == 0);
	// 共要分配的内存量
	size_t expandedSize_bytes = size_bytes + alignment;
	// 分配未对齐的内存块，并转换地址为uintptr_t
	uintptr_t rawAddress = reinterpret_cast<uintptr_t>(allocateUnaligned(expandedSize_bytes));
	// 使用掩码去除地址低位部分，计算“错位”量，从而计算调整量
	size_t mask = (alignment - 1);
	uintptr_t misalignment = (rawAddress & mask);
	ptrdiff_t adjustment = alignment - misalignment;
	// 计算调整后的地址，并以指针类型返回
	uintptr_t alignedAddress = rawAddress + adjustment;
	return static_cast<void*>(alignedAddress);
}
```

- 当要释放此内存块时，代码会传给分配器调整后的地址，而非原本分配的地址，所以需要将调整后的地址转换成原本的、可能未对齐的地址。可以存储一些元信息至额外分配的内存，最少的调整量为1字节，而偏移量不会超过1字节（256），可以将偏移量存储至调整后地址之前的1字节，这样就能简单的从调整后地址取回偏移量，并计算原本的地址

```c++
void* allocateAligned(size_t size_bytes, size_t alignment) {
	ASSERT(alignment >= 1);
	ASSERT(alignment <= 128);
	// 对齐必须是2的幂
	ASSERT((alignment & (alignment - 1)) == 0);
	// 共要分配的内存量
	size_t expandedSize_bytes = size_bytes + alignment;
	// 分配未对齐的内存块，并转换地址为uintptr_t
	uintptr_t rawAddress = reinterpret_cast<uintptr_t>(allocateUnaligned(expandedSize_bytes));
	// 使用掩码去除地址低位部分，计算“错位”量，从而计算调整量
	size_t mask = (alignment - 1);
	uintptr_t misalignment = (rawAddress & mask);
	ptrdiff_t adjustment = alignment - misalignment;
	// 计算调整后的地址
	uintptr_t alignedAddress = rawAddress + adjustment;
	// 将alignment存储在调整后地址的前4字节
	ASSERT(adjustment < 256);
	uint8_t* pAdjustment = reinterpret_cast<uint8_t*>(alignedAddress);
	pAdjustment[-1] = static_cast<uint8_t>(adjustment);

	return static_cast<void*>(alignedAddress);
}

void freeAligned(void* pMem) {
	const uint8_t* pAlignedMem = reinterpret_cast<const uint8_t*>(pMem);
	uintptr_t alignedAddress = reinterpret_cast<uintptr_t>(pMem);
	ptrdiff_t adjustment = static_cast<ptrdiff_t>(pAlignedMem[-1]);
	uintptr_t rawAddress = alignedAddress - adjustment;
	void* pRawMem = reinterpret_cast<void*>(rawAddress);

	freeUnaligned(pRawMem);
}
```

**单帧和双缓冲内存分配器**

- 几乎所有游戏引擎都会在游戏循环中分配一些临时用数据，要么在循环结束时丢弃，要么在下一次迭代结束时丢弃。很多游戏引擎都支持单帧分配器和双缓冲分配器来管理类似数据

- 实现单帧分配器要预留一块内存，以简单堆栈分配器管理，在每帧开始时，把堆栈的顶端指针重置到内存块的底端地址，该帧中分配要求使堆栈向上成长，该过程不断重复

  ```c++
  StackAllocator g_singleFrameAllocator;
  
  // 游戏循环
  while (true) {
  	//每帧清除单帧分配器的缓冲区
  	g_singleFrameAllocator.clear();
  
  	//从单帧分配器中分配内存，不需要手动设防这些内存，但要确保这些内存仅在本帧中使用
  	void* p = g_singleFrameAllocator.alloc(nBytes);
  
  	...
  }
  ```

  单帧分配器的主要好处是分配的内存永不用手动释放，依赖于每帧开始时分配器会自动清除所有内存，且其十分高效。缺点是从单帧分配的内存块只能在当前帧有效，程序员不能把指向单帧内存块的指针跨帧使用

- 双缓冲分配器允许在第i帧分配的内存块用于第(i + 1)帧，实现方法是建立两个相同尺寸的单帧堆栈分配器，并在每帧交替使用

  ```c++
  class DoubleBufferedAllcator {
  public:
  	void swapBuffers() {
  		m_curStack = (uint32_t)!m_curStack;
  	}
  
  	void clearCurrentBuffer() {
  		m_stack[m_curStack].clear();
  	}
  
  	void* alloc(uint32_t mBytes) {
  		return m_stack[m_curStack].alloc(mBytes);
  	}
  
  private:
  	uint32_t m_curStack;
  	StackAllocator m_stack[2];
  };
  
  DoubleBufferedAllcator g_doubleBufAllocator;
  
  // 游戏循环
  while (true) {
  
  	// 交换缓冲区
  	g_doubleBufAllocator.swapBuffers();
  	// 清空当前缓冲区，保留前帧的缓冲不变
  	g_doubleBufAllocator.clearCurrentBuffer();
  	// 从双缓冲分配器中分配内存，不影响前一帧的数据
  	// 确保分配的内存仅在本帧或下一帧中使用
  	void* p = g_doubleBufAllocator.alloc(bytes);
  
  	... 
  }
  ```

  其在多核处理器中，缓冲异步处理结果时非常有用，可以防止异步处理的结果被覆盖掉

#### 5.2.2 内存碎片

- 动态对分配的另一个问题在于会随时间产生内存碎片，当程序启动时整个堆空间都是自由的，当分配一块内存时，一块合适尺寸的连续内存块便会标记为"使用中"，而其余内存仍是自由的。当释放内存块时，该内存块便会与相邻内存块合并形成单个更大的自由内存块。但多次分配和释放后，内存就会被划分为很多小块，此时虽然有足够的内存进行分配，但无法形成连续的内存块分配出去
- 在支持虚拟内存的操作系统中，内存碎片并非大问题，其使用分页分段技术让不连续的内存页对应用程序来说是连续的。多数嵌入式设备负担不起虚拟内存的实现，现代某些游戏机虽然技术上能支持虚拟内存，但由于其开销太大，多数游戏引擎不会使用虚拟内存

**以堆栈和池分配器避免内存碎片**

- 堆分配器或池分配器可以避免一些内存分配带来的问题：
  1. 堆栈分配器完全避免了内存碎片的产生，其分配的内存总是连续，释放总是以相反次序释放
  2. 池分配器也无内存碎片问题，虽然实际上池会产生碎片，但这些碎片不会像一般的堆，提前引发内存不足的情况，像池分配器做分配请求时，不会因缺乏足够大的连续内存块，而造成分配失败，因为池内所有内存块是完全一样大的

**碎片整理及重定位**

- 若要分配和释放不同大小的对象并以随机次序进行，则堆栈和池分配器也不适用。对于该情况可以对堆定期进行碎片整理，其方法是将内存从高位移至地位。

- 一个简单的方法是搜寻第一个碎片，然后将碎片上面紧接的内存块向下移，重复进行该操作，直至将所有的已分配的内存全移至底端，碎片全移至顶端，形成连续的自由空间。但若有指针指向要被移动的内存块，在移动后这些指针便会失效

  其中一个解决方法是，将指向要移动内存块的指针逐一更新，使移动内存块指针仍能指到新的地址，该过程称为指针重定位。但在C/C++中没有方法可以搜寻所有指向某地址范围的指针，若要在引擎中支持碎片整理功能，程序员必须小心手动维护所有指针，在重定位时正确更新指针

  另一个选择是舍弃指针，取而代之使用重定位时更容易修改的构件，如智能指针或句柄：

  1. 智能指针是细小的类，包含一个指针并且其实际行为几乎和普通指针完全相同。但由于智能指针是用类实现的，可以编写的代码正确处理内存重定位。如让所有智能指针把自己加进一个全局链表中，当要移动某块内存时便可扫描全局链表更新每个指向该内存的智能指针
  2. 句柄通常实现为索引，这些索引指向句柄表内的元素，每个元素存储指针。句柄表本身不能被重定位，但要移动某已分配内存时，可以扫描该句柄表，并自动修改相应指针，由于句柄只是句柄表的索引，无论如何移动内存块句柄的值都不变，所以使用句柄的对象不会受到内存重定位影响

- 重定位的另一个难题是某些内存块不能被重定位，如使用的第三方库没有使用智能指针或句柄，则指向库内的数据结构指针就可能不能重定位。解决该问题的方法：

  - 让这些库在另一个特别缓冲区里分配内存，此缓冲区位于可重定位内存范围之外。
  - 允许一些内存块不能被重定位，若这种内存块数量少且体积小，重定位系统仍可运行的相当好

- 分摊碎片整理成本：碎片整理要复制内存块，该过程可能很慢，但可以分多次进行碎片整理。

  - 针对细小的内存块：如允许每帧进行N次内存块移动（N很小，如8,16），若游戏以30帧运行，则每帧持续33ms，该情况下堆通常能在少于1s内完全整理所有碎片，而不会对游戏帧率产生明显影响，只要分配及释放碎片次数低于碎片整理的移动次数，则堆会经常保持接近完整整理的状态。
  - 针对比较大的内存块：可以将该内存块拆分为多个小块，然后每个小块都可以独立被重定位

### 5.3 容器

- 常见的容器数据类型包括但不限于：
  - 数组：有序、连续存储数据的元素集合，使用索引存取元素，每个数的长度通常在编译器静态定义，数组可以是多维的
  - 动态数组：可以在运行时动态改变长度的数组
  - 链表：有序集合，但其数据在内存中是以非连续方式存储的
  - 堆栈：在新增和移除数据时，采用后进先出的模式，即压入和弹出操作
  - 队列：在新增和移除数据时，采用先进先出的模式
  - 双端队列：可以在两端高效的插入与移除数据
  - 优先队列：加入元素后，可用事先定义了的优先值计算方式，高效的弹出队列中优先值最高的元素。通常使用堆来实现
  - 树：以层阶结构组织元素，每个节点有0至1个父节点以及0至多个子节点。该结构是有向无环图的特例
  - 二叉查找树：二叉查找树中的每个节点最多包含两个子节点，由于节点按照预先定义的方式排列，任何时候都可以按排列方式遍历整棵树。其包括很多类型，如红黑树、伸展树、AVL树
  - 二叉堆：采用完全或接近完全二叉树的数据结构通常使用静态或动态数组存储。根节点必是堆中最大或最小的元素。一般用于实现优先队列
  - 字典：由键值对组成的表，通过键可以高效的查找对应的值。从技术上来说散列表只是字典的一种实现方式
  - 集合：保证容器内没有任何重复元素，类似于字典，但只有键没有值
  - 图：节点的集合，节点之间可任意以单向或双向路径连接
  - 有向无环图：图的特例，节点间单向连接，且没有循环

#### 5.3.2 迭代器

- 迭代器是一种细小的类，其知道如何高效的访问某类容器中的元素。其类似于数组的索引或指针，每次都会指向容器内的某个元素，可以移至下一个元素，且能用某种方法表示是否已访问容器内的所有元素
- 相比于直接访问容器的元素，采用迭代器的好处包括：
  - 直接访问将破坏容器类的封装，而迭代器通常是容器类的友元，因此可高效迭代访问容器同时不暴露容器类的实现细节
  - 迭代器简化的迭代过程，大部分的迭代器行为和数组索引或指针相似，所以无论构成容器的数据结构多复杂，用户都可以编写一个简单的循环，每次将迭代器递增并检查终止条件即可

**前置递增和后置递增**

- 前置递增运算符首先对运算数递增再传回已修改的值。后置递增运算符则传回之前未递增的值，然后再递增该值。这意味着前置递增会在代码中产生数据依赖，CPU必须先完成递增运算后才能在表达式中使用该变量的值，在深度流水线化的CPU上，这会引起流水线停顿。使用后置自增并不造成数据依赖
- 在for循环的“更新”表达式中前置和后置递增没有分别，因为编译器知道在该循环中没有使用变量的值

#### 5.3.4 建立自定义的容器类

- 自行建立容器类的原因：
  - 完全掌控：程序员能控制数据结构的内存需求、使用的算法、何时/如何分配内存等
  - 优化的机会：某些游戏机可能有某些硬件功能，可借助这些功能优化数据结构和算法或基于引擎中某个应用做出微调
  - 可定制性：可自行提供在第三者库不常见的功能
  - 消除外部依赖：可能不会接触到第三方库的开发团队，若那些库出现问题，则可能无法立即自行调试或修正，而要等待该库的下一个发行版本
  - 操控并发数据结构：当编写自己的容器类时，可以全权控制它在多线程或多核系统中的保护机制

**建还是不建**

- 游戏引擎设计师以下几种选择：

  1. 自行建立所需的数据结构
  2. 依赖第三方的实现，常见包括：
     - C++标准模板库，STL
     - STL的变种，如STLport
     - 强大健壮的Boost库

- STL标准模板库的优势包括：

  1. STL提供了丰富的功能
  2. 在许多不同平台上都有尚算健壮的实现
  3. 几乎所有C++编译器都带有STL

  缺点：

  1. 陡峭的学习曲线，虽然文档质量不错，但大部分平台的STL头文件都晦涩难懂
  2. 相比为某问题而打造的数据结构，STL通常会较慢
  3. 相比自行设计的数据结构，STL几乎总会占用更多内存
  4. STL会进行许多动态内存分配，对于高性能、内存受限的游戏机游戏来说，控制STL的内存占用量是富有挑战性的工作
  5. STL的实现和行为在各编译器上有微小差异，增加了多平台引擎上应用STL的难度

  STL比较适合PC上运行的游戏引擎，因为现代PC的高级虚拟内存系统使内存分配变得高效，而通常也能忽略物理内存不足的可能性。STL一般不适合游戏主机，因为游戏主机内存受限、缺乏高级CPU和虚拟内存，且使用STL的代码可能较难移植至其他平台

- 作者的一些经验：

  - 使用某STL类之前，要认识其效能和内存特性
  - 若认为代码中的重量级STL类会造成瓶颈，尝试避免使用它们
  - 占少量内存的情况才使用STL
  - 若引擎需要支持多平台，则笔者极力推荐使用STLport，兼容多个编译器和目标平台而特别设计的，而且比原来的STL实现更高效、功能更丰富

- Boost：由几位C++委员会库工作小组成员发起的项目，现在已成为有大量全球贡献者的开源项目，其目标是制作一些库，能扩展STL并与STL联合工作，供商业或非商业使用，许多Boost库已纳入C++标准委员会的库技术报告，可能成为未来C++标准的一步：

  1. Boost提供了许多有用但STL没有的功能
  2. 在某些情况下，Boost提供了替代方案，能解决一些STL设计上或实现上的问题
  3. Boost能有效的处理一些非常复杂的问题
  4. 大部分Boost库的文档都写的很好，不单单解释每个库做什么和如何使用，很多时候还会深入探讨开发该库的设计决定、约束及需求

  缺点：

  1. 大部分Boost核心类都是模板，且使用多数Boost功能只需要包含一些头文件，有些Boost库会生成颇大的.lib文件，可能不适合小型的游戏项目
  2. 虽然全球规模的Boost社区是极好的支援网络，但Boost库并不停工任何保证
  3. 不保证支持向后兼容
  4. Boost库是按Boost软件许可证发布的

- Loki：C++编程中有一个比较深奥的分支，叫模板元编程，TMP的核心概念是利用编译器做一些通常在运行时才会做的工作，其运用C++模板功能诱使编译器做一些原本并非为此而设的事情。最知名且可能最强大的C++TMP库是Loki。

  缺点：

  1. 代码可能让人望而生畏，难以使用及全面理解
  2. 有些元件依赖某些编译器的“副作用”行为，必须细心调整才能应用在新的编译器上，所以相比于其他库来说，移植能力较弱

**链表**

- 外露式表：其节点数据结构完全和元素数据结构分离，每个节点包含指针指向元素

  优点：一个元素能同时置于多个链表中，只需为每个链表分配独立的节点，指向该共享元素

  缺点：必须动态分配接单，很多使用会使用池分配器分配节点，因为每个节点是同大小的

- 侵入式表：节点的数据结构被嵌进目标元素本身。两种实现方式，一种是使用节点数据结构类型作为成员，另一种是继承节点数据类型

  优点：无需再动态分配节点，每次分配元素时已“免费”获得节点

  缺点：每个元素不能同时置于多个链表中

- 若需要避免动态分配则选择侵入式表，若能负担起池分配的开销则选择外露式。若链表中存储一些第三方库的实例，且无法后者不想修改第三方库的源码，可能只能选用外露式

**循环链表**

- 完整的循环链表的实现需要提供头尾指针，最简单的方法是设置两个指针，分别指向头尾节点

  ```c++
  template<typename ELEMENT>
  struct Link{
  	Link<ELEMENT>* m_pPrev;		// 指向前一个
  	Link<ELEMENT>* m_pNext;		// 指向后一个
  }
  
  template<typename ELEMENT>
  struct LinkedList{
  	Link<ELEMENT>* m_pTail;		// 头结点
  	Link<ELEMENT>* m_pHead;		// 尾结点
  }
  ```

  或者直接使用一个节点存储头尾节点，该设计相较于前一个更优：

  - 插入删除操作书写过程更简便
  - 独立头尾节点实现中，头尾节点中必然是空，若链表中只存在一个元素，则不能只通过这个元素判断该元素是否属于一个链表

  ```c++
  template<typename ELEMENT>
  class LinkedList{
  	Link<ELEMENT> m_root;
  }
  ```

**单向链表**

- 单向链表中的节点只有后节点没有前节点，该设计能节省没存，但代价是插入或移除元素时间。双向链表插入移除操作为O(1)，单向链表则是O(n)
- 固有的插入以及删除代价通常是难以承受的，所以大多数链表都是双向的。若肯定只会加入或移除链表的首元素（如栈），或只会加入首元素并移除尾元素（如队列），则可以避开单向链表的问题并节省一些内存

**字典和散列表**

- 字典是键值对组成的表，该数据结构通常是使用二叉查找树或散列表实现：

  - 二叉树实现中键值对存储在二叉树的节点里，而整棵树则是按键值排序节点的，该方式查找值需要O(logn)的查找操作
  - 散列表实现中，所有值存储于固定大小的表中，其中每个位置表示一个或多个键。要插入键值对时若键不为整数形式需要将键转换为整数形式，该过程称为散列。将散列后的键模除表的大小来求得表的索引，最后将键值对存储在该索引的位置上。若无碰撞发生，查找散列表的复杂度为O(1)

- 有两个或两个以上的散列值为同一个值则称为碰撞。有两种基本方法解决碰撞，以此延伸出两种散列表：

  - 开放式散列（open hashing）：当碰撞发生时，多个键值对存储在同一位置，键值对通常以链表形式存储。该方法容易实现且存储于表中的键值对数目并无上限，且每次加入新键值对都需要动态分配内存
  - 闭合式散列（closed hashing）：碰撞发生时，使用探测法解决。此方法比较难实现，且必须要设定表的键值对数目上限，散列表大小设为质数是比较好的选择（减少碰撞发生的概率）。优点是内存是固定的，不需要动态分配内存。该散列表通常是游戏引擎的好选择

- 闭合式散列表的发生碰撞后使用的探测法（当前位置为i）：

  - 最简单的是线性探测，以 (i + 1)、(i + 2)的顺序进行探测
  - 线性探测的变体，交替向前向后搜索，以 (i + 1)、(i - 1)、(i + 2)、(i - 2)的顺序进行探测

  线性探测方法会造成键值对聚集成群

  - 二次探查算法，以 (i + 1^2)、(i - 1^2)、(i + 2^2)、(i - 2^2)的顺序进行探测

- 散列法（hashing）是把任意数据类型的键转换为整数的过程，该整数模除表的大小就能得到表的索引。散列函数的质量对散列表的效能极为重要，优秀的散列函数是指能把所有有效键值平均分布至整个散列表的函数，从而使碰撞机会降至最低，且其运算时间也要短，对于固定的输入必须产生完全相同的输出。

  几个优秀的散列函数算法：

  - LOOKPU3
  - 循环冗余校验函数，如CRC32
  - 信息摘要算法5（MD5），密码中使用的散列函数，能产生极好的结果但运算成本比较高
  - Paul Hsieh的文章中提出的一些其他选择（www.azillionmonkeys.com/qed/hash.html）

### 5.4 字符串

#### 5.4.1 字符串的使用问题

- 使用字符串需要思考的问题：
  1. 如何在程序中存储和管理字符串。在C++中字符串不是一个原子数据类型而是字符数组。面对可变长的字符串，若不是硬设置字符串的长度限制，就必须动态分配内存作为字符串缓冲区。C++程序员通常不直接处理字符数组而是使用字符串类，此时需要考虑使用哪个字符串类
  2. 本地化（L10N，单词中L和N有10个字符），即更改软件以发布其他语言版本的过程，也称国际化（I18N，单词中有I和N间有18个字符）。游戏还需要处理文本排版方向，因为不同语言的阅读方向不一样，还需要处理译文比原文长或短的情况
  3. 游戏引擎内部还会使用一些字符串作为资源文件名、对象标识符等用途
- 运行时操作字符串本身的开销部分，它不像比较和复制int或float数组可使用简单的机器语言指令完成，且比较字符串需要O(n)的字符数组遍历，复制也需要O(n)

#### 5.4.2 字符串类

- 字符串类含有隐性成本，在性能分析前难以预料。如用C风格字符数组形式将字符串传递给函数时过程非常迅速，只需要将首地址存于寄存器在传递即可，但传递字符串类对象时，若函数以值传递，可能引起一个或多个拷贝函数的开销，复制字符串时可能涉及动态内存分配，导致耗费很多性能
- 作者建议在游戏编程中避免使用字符串类，若希望使用字符串类，在选择和实现字符串类时务必查明其运行性能特性是否在可接受范围。若需要存储和管理文件系统路径，可以使用专门的字符串类，可以专门封装该类以隐藏不同平台之间路径表达的差异

#### 5.4.3 唯一标识符

- 在任何虚拟游戏中，游戏对象都需要某种唯一标识方法，使用唯一标识符，游戏设计师能记录组成游戏世界的对象，运行时游戏引擎也能寻找和操控游戏对象，游戏资产也需要唯一标识符
- 资产通常存储为磁盘上的文件，通常可以用路径作为唯一标识符，游戏对象也会被指定为字符串的名字，所以字符串可以作为唯一标识符，但其性能比较差。

**字符串散列标识符**

- 将字符串进行散列是比较好的方法，其能如整数般比较，所以其比较操作很快，且将实际字符串存于散列表就可以凭借hash码取回原来的字符串。若有恰当的散列函数可以保证游戏中用到的合理字符串输入不会造成碰撞，因为32位hash码能表示超过40亿的值
