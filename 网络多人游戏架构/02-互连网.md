### 2.1 起源：分组交换

- 在分组交换出现之前，长距离系统间传输信息通过一种称为点了交换的过程实现，使用电路交换的系统通过一个连续的电路发送数据，这个连续的电路由许多短电路拼接而成，在信息传输过程中，该电路始终要保持连通，始终被占用，其提供了非常高质量的服务，但限制一条线路只能用于两个点通信
- 分组交换：将传输的信息拆分为小块，称为分组（数据包），基于存储转发技术发送到共享的线路中，提高了线路的可用性
- 存储转发：网络中的每个节点通过线路与其他节点相连，该线路可以在节点之间传输分组，每个节点存储到来的分组然后转发给距离目的地更近的节点

### 2.2 TCP/IP模型

- 早期互连网主机需求：链路层、IP层、传输层（传送层）、应用层

- OSI模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

- 五层网络模型：物理层、链路层、网络层、传输层、应用层

- 每层的代表性职责：

  传输：

  - 接受上一层数据
  - 通过添加头部或尾部对数据进行封装
  - 将数据转发到下一层做进一步传输

  接收：

  - 接受下一层传输来的数据
  - 去掉头部或尾部解封传输来的数据包
  - 将数据转发到上一层做进一步处理

### 2.3 物理层

- 物理层：TCP/IP模型最底层，最基本的支持层，为网络中的计算机或主机提供物理连接

### 2.4 链路层

- 链路层：网络模型中真正计算机科学发挥作用的开始，任务是提供一种网络实体间通信的方法，可以实现源主机封装信息、通过物理层传输信息、目的主机接受封装好的信息并从中提取信息，传输单元为帧
- 链路层的职责：
  - 定义主机的唯一标识方法，方便帧数据对接收方进行进行编址
  - 定义帧的格式，包括目的地址的格式和所传输数据的格式
  - 定义帧的长短，以便确定上层每一次传输所能发送的数据大小
  - 定义一种将帧转换成电子信号的物理方法，以便数据可以通过物理层传输被接收方接受
- 帧的传输是不可靠的，即链路层的通信是不可靠的，有许多因素影响电子型号无差错抵达接收方，物理介质损坏、电子设备干扰或设备故障都可能导致帧丢失而无法投递，链路层不做任何操作来确认真是否抵达接受方或保证帧没有抵达重新发送
- 对于每种被选择作为物理层实现的物理介质，都有对应的协议或协议族来提供链路层所需要的服务
- 由于链路层实现和物理层介质关系紧密，一些网络模型将这两层合并为一层，但因为一些物理介质支持的链路层协议不止一种，所以一般还是视为两层
- 两个远距离的主机之间的网络连接不会仅仅使用一种物理介质和一种链路层协议，由于TCP/IP模型的抽象，链路层协议的细节大多隐藏在游戏背后，不需要探究现有链路层协议的内部工作细节

**以太网**

- 以太网不是单指一个协议，而是基于以太网蓝皮书的一组协议，现代的以太网协议是在IEEE 802.3基础上定义的，用于光纤、双绞线或铜电缆上的以太网协议各种各样且速度也不同
- 为了给每台主机一个唯一标识，以太网引入了介质访问控制地址概念，即MAC地址，其在理论上是一个48bit数字，唯一分配给连接在以太网网络中的每个硬件，常见的是网卡。为了保证MAC地址的唯一性，网卡生产商在硬件的生产过程中将MAC地址烧到了网卡中，MAC地址中的前24bit称作组织唯一标识符（OUI），是由IEEE给厂家分配的唯一代码，后24bit由厂家自己分配保证生产的硬件是唯一的
- MAC地址不仅使用在以太网中，其已经用于大多数的IEEE 802系列的链路层协议中，包括无线网和蓝牙
- 自MAC地址出现以来，已经在两个重要方面得到了发展：
  1. 作为真正的唯一硬件标识符，其不再可靠，现在许多网卡允许软件任意修改MAC地址
  2. 为了解决各种各样的问题，IEEE引入了64bit MAC地址的概念，称为扩展的以太网接口标识符（EUI64），必要时通过在OUI的右侧插入两个字节FFFE将48bit MAC地址转换成EUI64
- 帧结构：
  - 前导序列和帧开始标志（0-7byte）：所有帧都是一样的，包含十六进制值0x55 0x55 0x55 0x55 0x55 0x55 0x55 0xD5，其为一个二进制模式，帮助底层硬件同步和准备接受到来的帧。通常网卡会将前导序列和帧开始标志从数据报中剥离出来，剩下的字符被传递到以太网模块进行处理
  - 目的地址（8-13byte）：帧接收方的MAC地址。FF：FF：FF：FF：FF：FF称为广播地址，表示同时向局域网中的所有主机都发送该帧
  - 源地址（14-19byte）：帧发送方的MAC地址。
  - 帧长度/类型域（20-21byte）：表示帧的长度或者类型的共用的域。当表示帧长度时，其指定了帧中数据部分的字符数；当表示帧类型时，其包含了一个以太网类型，唯一标识了用于解释数据的协议。为了帮助解释，以太网标准规定帧内封装的报文数据最大长度为1500字节，这是一次传输中所能传递数据的最大容量，所以称为最大传输单元（MTU）。若该域的取值小等于1500表示帧长度，大于等于1536表示协议类型
  - 数据（22byte-...，包含46-1500byte）：帧内封装的报文数据，通常是一个网络层的数据报，通过在链路层交付到适当的主机
  - 帧校验序列（帧尾，FCS）：由两个地址域、帧长度/类型域、数据域和其他填充信息生成的循环冗余校验（CRC32）值
- 网络中每台主机接收帧，读取帧之后确定它是否是接收者，若是，提取帧中的数据域，并根据帧长度/类型域取值处理这些数据
- 虽然没有统一的标准，但许多现在以太网网卡支持最大传输单元大于1500 byte，这些巨型帧的长度通常可高达9000byte，为了支持这个长度，在帧头指定一种以太网类型，然后基于传入的数据同时依赖底层硬件来计算帧的大小

### 2.5 网络层

- 链路层的不足：

  - 烧在硬件中的MAC地址限制的硬件的灵活性。比如要换个硬件时，MAC地址改变，导致其他人无法通过之前的MAC进行访问
  - 链路层不支持将互联网划分成更小的局域网络。因为要使用以太网，首先所有主机都需要链在一个连通的网络中，当一个主机向其他主机发送信息时会发送给每一个主机，大量数据包会造成网络瘫痪
  - 链路层不支持使用不同的链路层协议进行主机之间的通信，

  网络层的任务是在链路层基础上提供一套逻辑地址的基础设施，主机硬件可以很容易的更换，主机群可以划分为子网，在两个遥远的子网中的主机可以使用不同的链路层协议和物理介质相互发送信息

#### 2.5.1 IPv4

- IPv4的IP地址是32bit数字，通常以英文句号分隔的4个8bit数字形式展示，互联网上的每台主机都有唯一的IP地址后，发送方想将数据包投递给接收方只需在数据包的包头中指定接收方的IP地址即可

- IPv4数据包结构：

  - 版本号（0-3bit）：标识目前采用的IP协议的版本号，IPv4为0100
  - IP数据包的包头长度（4-7bit）：描述IP包头的长度，以32bit为单位，因为在IP数据包的包头中有可变长的可选部分，所以IP数据包的包头长度可变。可存储最大值为15，所以包头最长为15*32bit，包头有20byte的必须信息，所以存储值最小为5
  - 服务类型（8-15bit）：用于从拥塞控制到差异化服务识别的各种目的
  - IP数据包的包总长（16-31bit）：以byte为单位计算的IP数据包的长度，包括头部和数据
  - 片标识符（32-47bit）、片标记（48-50bit）、片偏移（51-63bit）：用于重组分片数据包
  - 生存时间（64-71bit）：用于限制数据包转发的次数
  - 协议（72-79bit）：标识用于解释数据内容所使用的协议
  - 头部校验和（80-95bit）：用于IPv4头部的正确性检测，仅仅针对头部数据，数据部分若需要确保完整性，则交由上层来保证，通常这不是必须的
  - 源地址（96-127bit）：是数据包放松放的IP地址
  - 目标地址（128-159bit）：既可以是数据包接收方的IP地址，也可以是发送给多台主机的特殊地址
  - 可选项（160-...）

  IP数据包的包头长度以32bit为单位，而IP数据包的包总长以8bit为单位，因为所有的数据包包头长度都是4个字节的整数倍，所有字节长度都能被4整除，可以节省两个0

**直接路由和地址解析协议**

- 地址解析协议（ARP）包含两部分：用于查询IP地址所对应的MAC地址的报文结构和记录它们之间映射关系的对应表

- ARP在技术上是一个链路层协议，因为其直接使用链路层的地址形式发送数据包而不需要网络层提供的路由，由于该协议包括了网络层的IP地址进而破坏了网络层的抽象，所以可以将其视为两层之间的桥梁，而不仅仅是一个链路层协议

- 当网络层需要使用链路层向一台主机发送数据包时，首先查询ARP对应表获取目标IP地址所对应的MAC地址，若找到则IP模块使用该MAC地址构造一个链路层帧，将该帧发送给链路层实现传输，若未找到，则ARP模块通过给链路层网络中所有可达的主机发送ARP报文来获取对应的MAC地址

- ARP报文格式：

  - 硬件类型（0-15bit）：指明了链路层所使用的硬件接口类型
  - 协议类型（16-31bit）：指明了正在使用的网络层协议所对应的以太网类型值，IPv4为0x0800
  - 硬件地址类型（32-39bit）：指明了以字节为单位的链路层硬件地址长度，大部分情况下该值为MAC地址的长度，即6byte
  - IP地址长度（40-47bit）：指明了以字节为单位的网络层协议逻辑地址长度，对于IPv4为4字节
  - 操作类型（49-63bit）：表示报文是信息请求还是相应
  - 发送方硬件地址（长度可变）：报文发送方的硬件地址
  - 发送方IP地址（长度可变）：报文发送方的网络层地址。这两个地址要和前面指定的长度一致
  - 目标硬件地址（长度可变）：报文接收方的硬件地址，若报文类型是请求，那额目标硬件地址未知，会被接收方忽略
  - 目标IP地址（长度可变）：报文接收方的IP地址

- 将一主机向互联网上所有主机广播了它的初始ARP请求该请求包含主机A的MAC地址和IP地址，给网络上其他主机把该主机信息更新到ARP对应表的机会

  该系统有个安全漏洞，若没有一种方法来验证ARP信息的真实性，路由器可能无意中将本属于一台主机的数据包错误的发送给恶意主机，这不止允许了嗅探数据包，还可能造成被窃取的数据包无法到达原本的目的主机，彻底扰乱了互连网的秩序

**子网和间接路由**

- 子网掩码：32bit数，通常写成以点分隔的4个8bit数字，与IP地址得表示方法一样，若主机的IP地址和子网掩码做按位与运算得到的结果相同，则主机处于同一个子网中
- 子网中有两个地址是保留的，不被其他主机使用：
  - 网络地址，子网中任意的IP地址与子网掩码按位与的结果
  - 广播地址，由子网掩码按位非的结果与网络地址按位或运算得到，即网络地址不能定义子网的二进制位都设置为1
- 无类别域间路由（CIDR）：子网表示成它的网络地址后跟一个斜杠，接着是子网掩码的有效位数
- 当一台主机的IPv4模块向另一台远程主机发送数据包时，首先决定是使用ARP表及直连路由还是使用间接路由，每个IPv4模块包含一个路由表，对于每一个可达的目标子网，路由表包含一行信息，内容是如何将数据包发送到子网
- 路由表：
  - 目标子网：指的是包含目标IP地址和子网
  - 网关：指当前子网通过链路层发送数据包的下一台主机的IP地址，要求这台主机可以通过直达路由可达，若网关域为空，表示整个目标子网是可以通过直达路由可达的，使数据包可以直接通过链路层发送
  - 网卡：指的是转发数据包的网卡
- 目标子网0.0.0.0/0称为默认网络，其定义了一个包含所有IP地址的子网，其在路由表的最后一栏，当一个目标子网和路由表中的全都不匹配则一定匹配默认网络
- 数据包没经过一个路由器，IPv4头部的生存空间值减1，当减少为0时，路由器将会丢弃收到的TTL=0的数据报，避免IP数据包在网络中的无限循环和收发，改变TTL需要重新计算头部校验和 ，增加了主机处理和转发数据包的时间
- 网络层的所有协议都是不可靠的，不可靠指不保证数据传输和传输的顺序
- 有两个特殊的IP地址：
  - 回路地址，或称本地地址（127.0.0.1）：若要求IP模块发送数据包到本地地址，它不会发送到任何地方，而是处理为刚刚收到的数据报，并将其发送到下一层进行处理。技术上，整个127.0.0.0/8的地址块均为本地地址，但一些操作系统的防火墙默认只允许标记为127.0.0.1的数据包这样做
  - 广播地址（255.255.255.255）：数据包会被发送到相同链路层网络的所有主机，但路由器发送，通常的实现方法是将数据包打包成链路层帧，并发送到广播MAC地址FF：FF：FF：FF：FF：FF

**分片**

- 分片：若IP模块要传输的IP数据包比链路层的最大传输单元要大，就要被分割成一些数据包的长度为链路层最大传输单元的小片段

- IP分片数据包和普通的IP数据包类似，只需要在头部设置片标识符、片标记和片偏移三个域。当IP模块将IP数据包分割成一组小的片段时，为每一个片段创建一个新的IP包，并设置这些域的值

  - 片标识符（16bit）：标识原始的数据包，这一组所有被拆分的分片数据包都被标记相同的值
  - 片偏移（13bit）：该IP数据包从开始到属于这个分片数据包的位置，这一组所有被拆分的分片数据包被标记不同的值。一个65535byte的数据包最大片段偏移值是13bit，所以要求所有的偏移是8byte的整数倍，这是偏移量所能取得的最高精度
  - 片标记（3bit）：除了最后一个片段的其他所有分片数据包都会设置成0x4f，称为MF，表示还有更多的数据包，一台机器必须等收齐该组所有的分片数据包之后才能将重建的数据包传输给上层。最后一个分片数据包不再使用这个片标记域，表明原始数据包中再没更多的分片数据包了

- 片标记域还有另一个功能，若IP数据包的原始发送者将其设置为0x2，称为DF，指明在任何情况下，这个数据包都不能被分片，此时若IP模块必须通过链路层转发一个比最大传输单元大的数据包，该包将被丢弃

- 尽管IP数据包分片技术使得发送大数据包称为可能，但存在两种低效率情况：

  - 增加了网络上发送的数据量
  - 若一个分片数据包在传输过程中丢失了，那接收方必须丢弃整个数据包，即大的数据包丢失分片数据包的概率更大，建议通过保证所有IP数据包长度都小于链路层最大传输单元，尽量避免使用分片技术

  游戏开发者做了近似，数据包MTU的最小值为1500byte，还必须包括20byte的IP头、IP数据和任何协议，所以最好将IP包的数据限制在1300byte以内

#### 2.5.2 IPv6

- IP地址长度为128bit，前64bit称为网络前缀，用于表示网络；后64bit称为接口ID，表示个体主机
- 邻居发现协议（NDP）代替了地址解析协议ARP和动态主机配置协议DHCP的一些功能，路由器公布它们的网络前缀和路由表信息，主机查询和宣布它们的IP地址和链路层地址
- IPv6不再支持路由层面的数据包分片技术，删除了IP头部所有与分片技术相关的域，节省了每个数据包的带宽，若一个IPv6数据包到达路由器，发现对于链路层来说太大，则路由器直接丢弃这个包并告知发送方该包太大

### 2.6 传输层

- 传输层的任务是实现主机上单独进程之间的通信，为此其进入了端口概念。端口是16bit的无符号数，是一台特定主机的通信端点。使用传输层模块时，一个进程绑定一个特定的端口，告诉传输层模块它想获得所有发送到这个端口的内容。理论上，一个进程可以绑定到任何端口，用于任何传输目的，但一台主机上的两个进程试图绑定同一个端口就出现了问题，若需要多个进程绑定同一个端口，大部分实现都需要特定的标识

- 为了避免进程争夺端口，互联网名称与数学地址分配机构（ICANN），又称互联网数字分配机构，负责端口号的注册，任何协议和引用开发者都可以注册所需要的端口，每一个传输层的协议只能注册一个端口号。

- 端口号1024-49151为用户端口或称注册端口，任何协议和应用开发者可以向IANA申请这个范围的端口号，审核之后，该端口号注册就被授予了，若一个用户端口号已经被IANA注册给一个特定的应用或协议，则其他应用或协议想要绑定这个端口都是不合法的，尽管大部分传输层的实现都没有保证这一条

- 端口号0-1023位系统端口或预留端口，IANA对这些端口的注册要求更加严格，需要更彻底的审查，大部分操作系统只允许root级别的进程才能绑定到系统端口，需要更高安全级别时才使用

- 端口号49152到65535称为动态端口，IANA不负责这些端口的注册，任何进程使用它们都是公平的，若一个进程试图绑定一个动态端口，发现该端口被占用，应该尝试查询其他动态端口，知道一个没被占用的端口为止。游戏使用动态端口即可

- 一旦应用程序确定了一个可以使用的端口，则必须使用一个传输层协议才能发送数据

  | 名称               | 缩写 | 协议号 |
  | ------------------ | ---- | ------ |
  | 传输控制协议       | TCP  | 6      |
  | 用户数据包协议     | UDP  | 17     |
  | 数据报拥塞控制协议 | DCCP | 33     |
  | 流控制传输协议     | SCTP | 132    |

#### 2.6.1 UDP

- UDP是一个轻量级的协议，其封装数据并将其从一台主机的一个端口发送到另一台主机的一个端口
- UDP数据报结构：包含一个8字节的报头，后跟数据
  - 源端口号（0-15bit）：标识发送发将UDP数据报发送出去的端口
  - 目标端口号（16-31bit）：数据报的目标端口，UDP模块将数据报发送给与这个端口绑定的进程
  - 数据报长度（32-47bit）：包括报头和数据部分在内的总字节数
  - 检验和（48-63bit）：由UDP报头、数据部分和IP头的某些域计算得到。是一个可选项，若不做计算取值为0，当底层验证了数据则该域可以忽略

#### 2.6.2 TCP

- TCP是在两主机之间创建持久性的连接，提供可靠数据传输，其保证所有的数据都按序抵达接收方
- TCP的数据传输单元称为TCP报文段，指的是TCP用于传输大量的字节流，底层数据包封装这个数据流的每个单独报文段，一个报文段包含TCP首部和段内数据部分
- 报文段结构：
  - 源端口号（0-15bit）：发送方的端口号
  - 目标端口号（16-31bit）：接收方的端口号
  - 序列号（32-63bit）：一个单调递增的数字，通过TCP所传输的每个字节都有一个连续的序列号，用于这个字节的唯一标识。报文段的序列号一般是本报文段所发送的第一个字节的序号，但在三次握手中不是
  - 确认号（64-95bit）：包含发送方期望收到的下一个字节的序列号，对所有序列号低于这个数字的数据做一个实际的确认，因为TCP保证所有的数据都是按序传输
  - 数据偏移（96-99bit）：表示以32bit为单位的TCP头部大小。TCP允许头部的最后添加一些可选项，所以 取值范围20-64byte
  - 保留（100-102bit）
  - 控制位（103-111bit）：关于头部的元数据
  - 接收窗口（112-127bit）：表述对于传入的数据，剩余缓冲空间的最大容量
  - 校验和（128-143bit）
  - 紧急指针（144-159bit）：表示TCP段数据的第一个字节和紧急数据的第一个字节之间的距离。在控制位中URG标志设置了才有效
- 许多RFC，包括定义主要传输层协议的，都明确的规定8个bit大小的数据块为一个位组，而不是使用松散的定义一个字节为8bit

**可靠性**

- 源主机给目的主机发送一个唯一标识的数据包，然后源主机等待来自目的主机的确认响应的数据包，若在一定的时间内没有收到期望的确认，则重新发送这个数据包，重复这个过程直到所有的数据都被发送和确认

  <img src=".\图12.2 TCP可靠数据传输的流程图.png" alt="图12.2 TCP可靠数据传输的流程图" style="zoom:80%;" />

**三次握手**

- 第一次：主机A通过发送一个报文段发起连接，包含一个SYN标志和随机的初始序列号，告诉主机B主机A想开始一个TCP连接

  第二次：主机B愿意并且能开放该连接，将响应一个包含SYN标志和ACK标志的数据包，通过将确认号设置为主机A的初始序列号加1来确认主机A的序列号，主机B将选取自己的随机序列号开始与主机A传输

  第三次：主机A发送包含ACK标志的报文段确认收到主机B的初始序列号，ACK是主机B初始序列号加1。若缺少该步，主机B就可能受到了已经超时的A的链接请求然后一直处于等待接收状态，或者服务器端在发送SYN-ACK就认为连接成功开始发数据，而客户端没收到的话就仍然等待SYN-ACK报文段，

  若发生超时，主机A收不到SYN-ACK报文段，可能是主机B没有收到SYN报文段或是主机B的响应报文丢失了，主机A要重新发送初始报文段，若主机B确实收到过该SYN报文段，则主机B就知道是因为SYN-ACK响应报文段丢失，那么它将重新发送SYN-ACK报文段

**数据传输**

- 为了传输数据，主机在每个即将发送的报文段中包含数据载荷，每个报文段标记为数据中第一个字节的序列号，即报文段的序列号应该是上一个报文段的序列号加上上一个报文段的数据量
- TCP模块必须存储发送出去的每一个字节，直到这个字节已经被接收方确认收到，TCP才能将这个报文段从缓冲区删除
- TCP保证数据按序到达，所以若主机收到数据报的序列号不是所期望的，则可以有两种选择：
  - 直接丢弃该数据报，等待按序重传
  - 缓存它，同时不确认这个报文也不转发给应用层处理，主机根据它的序列号将它复制到本地流缓冲区的合适位置，当这个序列号之前的所有报文都抵达，主机再确认这个乱序的数据报，并发送到应用层处理，而不需要发送方重传
- 以太网传输的未被分片的数据部分最多是1460个字节，也被称为最大分段大小（MSS）
- 流量控制：防止一台快速传输的主机压制另外一台处理较慢的主机，TCP头部包含一个接收窗口域，来指明数据发送方有多少可用的接收缓冲区
- TCP数据流的理论带宽限制可以定义为：带宽限制*接收窗口/往返时间RTT
- TCP规范允许延迟确认，主机收到TCP报文段之后不用马上响应确认，而是等待500ms，或接收下一个报文段，哪种情况先发生就采取哪种方式
- 流量控制帮助TCP保护处理较慢的主机不被数据淹没，但没办法阻止较慢的的网络和路由器不被淹没，为了避免不必要的网络堵塞，TCP实现拥塞控制
- 为了降低拥塞，TCP模块主动限制网络汇总传输的未被确认的数据量，根据已经确认的和丢弃的数据包的数量计算限制本身，具体算法是依赖于实现的，当通产是某种AIMD（加性增乘性减）：当连接刚刚建立时，TCP模块设置避免拥塞的限制为最大分段大小MSS的很小的倍数，通常设置为两倍，每当确认一个报文段就将限制增加一个最大分段大小，一旦数据被丢弃，TCP模块马上将限制值减少一半，怀疑这个丢失是网络拥塞导致的，使用这种方式最终会打到一个平衡状态
- TCP还可以通过发送大小尽可能接近最大分段大小的数据报来降低网络拥塞，这意味着TCP模块需要维护一个向外发送的缓冲区来手机上层要发送的数据，许多TCP的实现使用纳格算法决定什么时候收集数据和发送报文段，其是一个规则的集合。习惯上，若有未被确认的数据在传输就收集数据，知道数据量大于最大分段大小或拥塞控制窗口，取这两个值中的最小值，发送在这两个限制下的最大报文段
- 当游戏使用TCP作为传输层协议时，纳格算法是游戏玩家的克星，尽管其减少了带宽的使用，但明显增加了数据发送的延时，若一个实时游戏需要向服务器发送很少量的更新，在有足够的更新累加起来填充最大分段大小之前，游戏已经运行了很多帧了，所以大部分TCP实现提供了一个选项来禁用这个拥塞控制功能

**断开连接**

- 第一次：当客户端没有要发送的数据时，会发送一个FIN数据报，表示准备停止发送数据，所有在缓冲区中等待的数据，包括FIN数据报仍然会被传输以及在必要的时候重传直到被确认，但TCP模块不会接收来自上层的新数据（终止等待1）。服务器可以接收数据，并且确认所有收到的数据

  第二次：服务器收到FIN报文，发出确认报文（关闭等待）。客户端收到服务器的确认后，等待服务器发送连接释放报文（终止等待2）

  第三次：当服务器没有要发送的数据时，发送一个FIN数据报（最后确认）

  第四次：客户端收到FIN报文后发出确认（时间等待），此时TCP连接还未释放，必须经过2*最长报文段寿命（MSL）时间后（假设网络拥堵，若该时间再收到服务器的FIN报文段则可以重发确认，若超过这个时间则推断ACK接受成功），客户端撤销相应的TCB，才进入关闭状态。服务器只要收到了客户端发出的确认，立即进入关闭状态，在撤销TCB后就结束这次TCB连接

### 2.7 应用层

#### 2.7.1 DHCP

- 动态主机配置协议DHCP允许主机在接入网络时请求自动配置信息。

  接入网络时，主机创建一个DHCP DISCOVER消息，包含自己的MAC地址，并使用UDP协议以广播方式发送到255.255.255.255：67，该消息会发送给子网中的每个主机，任何DHCP服务器都会受到该消息。

  若服务器有可以提供给客户端的IP地址，就准备一个DHCP OFFER数据包，该数据包包含可提供的IP地址和这个客户端的MAC地址，此刻该客户端没有IP地址，所以服务器通过UDP 68端口把数据包广播到整个子网，所有的DHCP客户端都会受到这个数据包，检查消息中的MAC地址来判断自己是否是期望的接受者。

  当正确的客户端收到该消息，读取所提供的IP地址并决定是否接受这个分配，若接受回复一个广播的DHCP REQUEST消息请求这个IP地址，若该IP地址仍然可用则服务器再一次回复一个广播的DHCP ACK消息，这个消息与客户端确认IP地址已经分配，并传达其他必要的网络消息，如子网掩码、路由器地址、可使用DNS服务器等等

#### 2.7.2 DNS

- 域名系统DNS协议能够将域名和子域名翻译成IP地址，名称服务器存储域名和IP地址的映射
- 将域名翻译成IP地址时，浏览器向名称服务器的IP地址发送一个DNS查询，该IP地址已经是配置好的。若被查询的名称服务器不是该区域的权威服务器，则通常有一个指针指向更权威的名称服务器接着查询，第二次查询的记过通常被缓存以便下一次可以马上回答该域名的查询
- DNS协议的查询和响应通常通过UDP协议发送，使用端口号53

### 2.8 NAT

- 若一个IP地址被称为公开可路由的，互联网上任意正确配置的路由器都可以给这个IP地址所在的主机发送数据包，这需要任何公开可路由地址都是唯一分配给一台主机的
- 网络地址转换NAT可以将整个子网的主机通过一个共享的公开IP地址连接到互联网
- 配置一个NAT网络，必须给网络中的每台主机分配一个本地可路由的IP地址
- IANA留为己用的本地IP地址：10.0.0.0/8，172.16.0.0/12，198.168.0.0/16
- 路由器同时拥有针对内部网卡的本地IP地址和针对外部网卡的ISP分配的公开IP地址，因为本地地址网卡连接的本地网络，所以称为局域网端口，公开地址网卡连接额是全球，所以称为广域网端口
- 路由器在路由IP数据包时，其NAT模块会重写这个IP数据包，将本地IP地址替换成路由器自己的公开IP地址。为了能给真正的内部主机返回响应，路由器需要一些机制来识别传入数据包的内部接收者，一种方式是简历一个表来记录每个发出去的数据包的IP地址，当收到来自外部IP地址的响应时，路由器查找哪台内部主机给这个地址发送数据包了，然后使用内部主机的IP地址重写数据包，但多台内部主机向同一台外部主机发送数据时该方法失效
- 所有现代NAT路由器采用的解决方案都暴力的破坏了网络层和传输层之间的抽象，通过同时重写IP头部的IP地址和传输层头部的端口号，通过分配路由器中唯一端口号保证和主机一一对应，路由器可以创建更精确的映射和标记系统，NAT表中记录这些映射关系
- 为了更加安全，许多路由器将原始的目的IP地址和端口添加到NAT表的表项中，当响应数据包到达路由器，NAT模块首先使用数据包的源端口查询表项，然后证实响应数据包的源IP地址和端口与原始发送出去的数据包的目的IP地址和端口一致，数据包被丢弃

**NAT穿越**

- 因为NAT，两台主机无法直接跨子网域进行连接，两种解决方法：

  - 让使用者在路由器上手动配置端口转发，不适合游戏使用
  - UDP对NAT的简单穿越方式STUN

- 使用STUN时，主机与第三方主机通信，第三方告诉主机如何彼此之间创建连接，这样它们的路由器NAT表中就得到了所需的表项，所以它们可以进行直接通信：

  主机A和主机B先向服务器发送数据包，服务器记录该情况，此时服务器知道路由器A和路由器B的公开IP地址和目的端口，然后将路由器B的连接信息传给主机A，主机A发送一个报文给主机B的公开IP地址，仅仅让路由器A的NAT表中记录主机B，之后服务器通知主机B可以和主机A通信，此时主机B开始和主机A进行通信

- 并不是所有的NAT都是用NAT穿越技术，有些NAT给内部主机分配不一致的外部端口，称为对称NAT，每个即将发出的请求收到唯一的外部端口，即使发出这个请求的源IP地址和端口已经在NAT表中，这破坏了STUN。有时不安全的对称NAT按序分配外部端口，所以可以使用端口分配预测方法在对称NAT上实现类似STUN的技术，安全一些的对称NAT使用随机端口分配方法，这样不容易预测

- STUN方法只适用于UDP协议，使用TCP时，将使用TCP打洞技术，前提是NAT路由器支持该技术

- 另一个流行的方法称为因特网网关设备协议IGDP也允许NAT路由器穿越，一些通用即插即用的路由器使用该协议允许局域网主机手动配置外部端口与内部端口的映射关系，但不是所有路由器都支持该技术