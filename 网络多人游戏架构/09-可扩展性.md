### 9.1 对象范围和相关性

- 一个对象在范围内或相关是指应该通知客户端关于该对象的更新信息。小规模游戏可以让所有对象对所有客户单都是在范围内或相关，对于大规模游戏则不行。

#### 9.1.1 静态区域

- 减少相关对象的一种方法是将世界划分为一些静态区域，只有和玩家在同一静态区域的对象才被认为是相关的，通常用于共享世界游戏如MMORPG
- 几种不同的方法处理区域边界的过渡：
  - 区域间穿梭时显示正在加载的画面，给客户端提供足够的时间来接受新区域所有对象的复制信息
  - 对象根据区域过渡时相关性的改变而淡入浅出，假定区域的地形不变可以将地形直接存储在客户端上，这项穿越区域边界时玩家身后的区域不会完全小时，但这会带来一些安全问题，一种解决方法是对数据加密
- 静态区域的一个不足，其设计以玩家大致俊宇分布在各个区域内为前提，大量玩家聚集在同一个区域可能导致游戏崩溃，一个可行但不好的解决方法是当一个区域玩家数量到达一个数量时，将后续玩家传送到相邻区域，还有个解决方法是分割成多个实例
- 静态区域通常不用于动作游戏，大多数动作游戏的战斗区域比MMO游戏中看到的小得多，且动作游戏的速度意味着穿越区域边界引起的延迟是不能接受的

#### 9.1.2 使用视锥

- 使用视椎体，只有处于玩家视锥体之内的才认为是相关的
- 视椎体判断对象范围在考虑延迟时会有些问题，玩家视椎体之外的都在范围外，当玩家快速旋转时，需要将这信息传给服务器，然后服务器要发送出现在范围内的对象的数据，可能会产生不能接受的延迟
- 一种解决方案是同时使用视锥和基于距离的系统，任何出现在该距离之内或在视锥范围内的对象都被认为是在范围内的，其他对象则在范围外

#### 9.1.3 其他可见性技术

- 潜在可见集（PVS），从世界的每个位置，哪些区域是潜在可见的。其通常比单独的静态区域小得多，且认为潜在可见区域将包含相关对象
- 一个典型的PVS实现，世界被划分为凸多边形的集合，离线为每个凸多边形计算潜在可见的其他凸多边形的集合，运行时服务器确定玩家位于哪个凸多边形，从这个凸多边形预先生成的多边形集合可以用于确定潜在可见性的所有对象集合，这些对象将被标记为相关
- 传送门（portal）技术，每间屋子是一个区域，每扇门或者窗被认为是一个传送门，传送门创建的截锥和视锥结合大大降低了相关对象的数量，其比PVS需要更多的运行处理时间。若在客户端使用该技术来防止过多绘制，可以方便扩展到对象范围判断
- 层次裁剪技术，如二叉树，四叉树，八叉树，kd树

#### 9.1.4 不可见时的相关性

- 一些特定对象的可见性不是在所有情况下都直接关系到相关性，如手雷，枪声。玩家需要收到这些信息
- 解决方法之一是将特定对象和其他对象对象区分对待，如通过半径而不是可见性判断是否被复制
- 另一种方法是通过RPC复制爆炸特效给没有见到手雷的客户端，该方法可以减少发送给客户端的数据量

### 9.2 服务器分区

- 服务器分区或分片是指同时运行多个服务器进程的概念，通过建立多个独立的服务器，任何一个特定服务器上的负载都不会过重
- 大多数动作游戏自然的使用这种方法，因为每个动作游戏都有活跃玩家的数量上限
- 服务区分区方法中，经常发生一台机器实际能同时运行多个服务器进程，在许多预算较多的游戏中，开发商在数据中心提供的机器是用于运行多个服务器进程的，这些游戏中游戏架构需要对分布在多台机器上的多个进程进行考虑。一种方法是一个主进程决定什么时候在哪台机器上创建服务器进程，当游戏结束时服务器进程在退出前写任何任何永久性数据，当玩家开始一个新的比赛，主进程可以确定最小负载的机器是哪台，并在这台机器上创建新的服务器进程，开发商也可以为服务器使用云托管
- 服务器分区也被用作静态区域的一个扩展，每个静态区域或区域的集合作为一个单独的服务器进程运行。若一个服务器上有太多的玩家仍会遇见性能问题，该一个解决方案是强制在队列中等待，另一种解决方案称为时间膨胀，其允许服务器所有玩家保持连接状态，但服务器减慢了游戏的时间步长

### 9.3 实例化

- 实例化中，一个共享的游戏同时支持多个不同的副本，其通常适用于所有角色在同一台服务器上的共享世界游戏，但这些角色同一时刻可能不会在同一副本。如当一个地区的人超过的一个副本的上限，就会创建新的副本。大多数实例化的游戏中，都以一个传送门或类似结构将玩家通过一个共享区域转移到另一个副本
- 从设计角度看，实例化允许游戏内容更符合单机游戏或小型多人游戏，同时角色仍然绑定在共享世界，一些游戏甚至使用实例化作为允许一个区域在任务线的过程中演变的方式。优点是可以降低特定服务器进程的负载，缺点是其降低了共享世界的感觉。

### 9.4 优先级和频率

- 有些游戏服务器的性能不是问题，而问题在于给客户端发送的数据量。一种方法是给不同的对象赋予优先级，具有高优先级的对象首先被复制，低优先级的对象只有在高优先级对象复制完之后才能赋值。当然仍要允许低优先级的对象偶尔通过，可以让不同对象有不同的复制频率来实现，低优先级复制频率低，或结合频率计算动态优先级（类似于最高响应比优先