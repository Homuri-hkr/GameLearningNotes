### 11.1 Unreal4

#### 11.1.1 套接字和基本的网络体系

- ISocketSubsystem接口类为Unreal支持的不同平台做了实现
- 套接字子系统负责创建套接字和地址，Create函数返回创建的FSocket类的指针，然后就可以使用标准的函数发送和接受数据。UNetDriver类负责接受、过滤、处理和发送数据包

#### 11.1.2 游戏对象和拓扑

- Actor几乎是所有游戏对象类的基类。其有个重要的子类是Pawn，是可以被控制的Actor，即有一个指向Controller类实例的指针，Controller也是Actor的子类，其仍是需要被更新的游戏对象
- 对于网络游戏，Unreal只支持客户端-服务器模型，服务器可以以两种不同的模式运行：专用服务器和监听服务器。专用服务器中服务器作为与其他所有客户端分开的一个进程运行，通常完全运行在一个单独机器上。监听服务器模式下，一个游戏实例既可以是服务器也是一个客户端

#### 11.1.3 Actor复制

- Unreal使用客户端-服务器模型，需要有一种方法让服务器给所有的客户端发送actor的更新。其尝试确定与任何一个客户端相关的actor集合，若一个actor只会和一个特定的客户端相关，那么可以在那个客户端上生成该actor而不需要在服务器上生成。也可以使用不同的标识进一步调整actor的相关性
- 在网络多人游戏中，回一次运行几个独立的游戏实例，每个实例可以查询每个actor的角色，这是为了确定谁具有该actor的控制权，根据查询角色的实例不同，特定的actor的角色也可以不同
- 三种角色：
  - 权威：游戏实例是actor的权威
  - 模拟代理：在客户端上，意味着服务器是actor的权威，模拟代理意味着客户端可以模拟actor的某些方面
  - 自治代理：直接从当前的游戏实例接收输入事件的代理，当代理在模拟时，应考虑玩家的输入
- 在多人游戏中，服务器不总是actor的权威，如本地粒子效果，服务器甚至不知道其存在。但每个以放服务器作为角色权威的actor都将被复制给所有相关的客户端，这些actor中，可以指定哪些属性应该被复制哪些不应该。Unreal中的actor复制仅仅是从服务器到客户端，客户端没有办法创建一个actor将其复制给服务器或其他客户端
- unreal也有更先进的赋值配置，如可以根据特定的条件仅仅复制一个属性，可以每当一个特定的属性从服务器复制过来时就在客户端上执行自定函数。该引擎使用了复杂的宏集合来跟踪所有不同的复制属性，当类的头文件中增加一个变量时，可以通过宏在变量上标注合适的复制信息
- Unreal实现了actor移动的客户端预测，若一个actor被设置为BReplicateMovement标识，则将根据复制过来的速度信息，复制并预测模拟代理的移动，若有需要可以重写该方法为角色移动实现客户端预测

#### 11.1.4 远程过程调用

- Unreal有三种类型的RPC：服务器、客户端、多播
  - 服务器函数是客户端上调用并在服务器上执行的函数。服务器不会让任何客户端调用游戏世界中所有actor上的服务器RPC，只有拥有这个actor的客户端可以在actor上成功的执行服务器RPC，拥有者和权威角色的游戏实例不同，拥有者是actor相关联的PlayerController
  - 客户端函数：当服务器调用客户端函数时，该过程调用被发送给拥有actor的客户端
  - 多播函数：被发送到多个游戏实例，其在服务器上调用，并在服务器和所有客户端上执行的函数
- Unreal提供了RPC是否可靠的选项，意味着对于低优先级的时间可以将它们的RPC标记为不可靠的，在发生数据包丢失时可以提升性能

### 11.2 Unity

- Unity5.1引入了UNET的新网络库，有两种不同的API：高层API可以处理大多数网络游戏的应用案例，底层传输层API可以根据需要定制互联网通信

#### 11.2.1 传输层API

- UNET提供的传输层API是针对平台相关套接字的封装，其提供了创建与其他主机连接的功能，该连接可以用来发送和接受数据。
- 创建连接时可以决定该连接的可靠性，创建时不是明确请求UDP或UDP连接，而是指定希望使用连接的方式。可以创建一个通信通道，并从枚举类型QoSType中选择一个值。包括：
  - UNreliable。发送消息没有任何保证
  - UnreliableSequenced：不能保证消息到达，但是乱序的消息会被丢掉。可用于电话通信
  - Reliable：只要连接没有断，就能保证消息能到达
  - ReliableFragmented：一个可靠的消息可以被分割成几个数据包，在希望网络传输大文件时是非常有用的，其可以在接受端进行重组

#### 11.2.2 游戏对象和拓扑

- Unreal是使用比较完整的层次结构，Unity采取更加模块化的方法。
- Unity中的GameObject类主要是针对组件类的容器，所有的行为都委托给所讨论的GameObject中所包含的组件类，使得对于游戏对象不同方面的行为有了一个更好的描述，尽管当多个组件间存在依赖时可能使编程更困难。一般情况下，一个GameObject有一个或多个从MonoBehavior继承的组件为GameObject实现任何自定义的功能
- 高层网络APU中，Unity使用NetworkManager类封装网络游戏中的状态，其以三种不同的模式运行：单独的客户端、单独的（专用的）服务器、组合“主机（既是客户端也是服务器）。即Unity实际上同时支持专用服务器模式和监听服务器模式

#### 11.2.3 生成对象和复制

- Unity网络游戏中生成对象和在单人游戏中不同，当游戏对象通过NetworkServer.Spawn函数在服务器上生成，意味着该游戏对象可以通过生成的网络实例ID被服务器跟踪。以该方式生成的游戏对象可以被复制并在所有客户端上生成。为了在客户端上生成正确的游戏对象，应该为游戏对象注册正确的预制体。
- Unity中的预制体可被认为是组件、数据和脚本的集合，通过在客户端上注册预制体，当服务器通知客户端生成该游戏对象的实例时保证所有的对象数据都已准备好
- 一旦对象在服务器上生成，它行为组件内的属性可通过几种不同的方法被复制到客户端，但为了其正常工作，必须从NetworkBehaviour继承而不是MonoBehavior，复制变量的最简单的方法是给希望复制的每个变量标记[SyncVar]属性，可以用于原生类型和Unity类型，任何标记为该属性都都会自动将值的变化复制到客户端。SyncVar也可以用于用户定义的结构体，但结构体中一个数据的改变整个结构体都全部被复制，会造成带宽的浪费。若需更加细粒度的控制变量的复制，那么需要重写OnSerialize和OnDeserialize成员函数来手工对需要同步的变啦滚进行读和写，但其不能和SyncVar同时使用

#### 11.2.4 远程过程调用

- Unity中，命令是指客户端发给服务器的动作，只对玩家控制的对象有效。客户端RPC函数是指服务器发给客户端动作，这类型的RPC函数只在NetworkBehaviour的子类中被支持
- 标记函数某种类型的远程过程调用使用[Command]属性，且函数名以Cmd为前缀。若函数是客户端RPC则标记为[ClientRpc]属性并以Rpc开头。这两种函数都可以像标准函数一样调用，并且自动创建网络数据和远程执行

#### 11.2.5 比赛安排

- UNET库也提供与游戏服务相关的比赛安排功能，其比赛安排模块可以被用于请求并列出当前游戏会话，一旦发现合适的会话就可能加入游戏。该功能可以通过NetworkMatch类添加到MonoBehavior子类中，之后会触发回调如OnMatchCreate、OnMatchList、OnMatchJoined