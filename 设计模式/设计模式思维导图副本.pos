{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","structure":"mind_right","leftChildren":[{"id":"872d5d5d7a30","title":"创建型模式","lineStyle":{"randomLineColor":"#FA5465"},"children":[{"id":"714241216d7b","title":"工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个对象，使一个类的实例化延迟到子类","children":[{"id":"012d0077bd6a","title":"简单工厂vs工厂方法","children":[{"id":"8c33211a2945","title":"工厂方法模式将简单工厂的内部逻辑判断移动到客户端进行，使符合开放封闭原则","children":[],"parent":"012d0077bd6a"}],"parent":"714241216d7b"}],"parent":"872d5d5d7a30"},{"id":"517fe5b13b21","title":"抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口（这些类可能有多个实现），而无须指定它们具体的类","children":[{"id":"92b040fc1282","title":"优点","children":[{"id":"93d60b1bebac","title":"易于交换产品系列，在一个应用中只需要在初始化时出现一次就使得改变一个应用的具体工厂变得非常容易，只需要改变具体工厂即可使用不同的产品配置","children":[],"parent":"92b040fc1282"},{"id":"8c91604b84ba","title":"让具体的创建实例过程与客户端分离，客户端只通过抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中","children":[],"parent":"92b040fc1282"}],"parent":"517fe5b13b21"}],"parent":"872d5d5d7a30"},{"id":"7663697c9dfb","title":"建造者模式：将一个复杂对象的构件和它的表示分离，使同样的构件过程可以创建不同的表示","children":[{"id":"0b80bb62ebfd","title":"使用场景","children":[{"id":"042dd7b3eac2","title":"创建复杂对象的算法应该独立于该对象的组成部分以及装配方式时","children":[],"parent":"0b80bb62ebfd"}],"parent":"7663697c9dfb"},{"id":"9271f0ce0c75","title":"优点","children":[{"id":"9d51d7df1c7b","title":"使建造代码与表示代码分离，若需要盖板边一个产品的内部表示，只需要再定义一个具体的建造者即可","children":[],"parent":"9271f0ce0c75"}],"parent":"7663697c9dfb"}],"parent":"872d5d5d7a30"},{"id":"d6e8bf4b1729","title":"原型模式：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象","children":[{"id":"2088535ecdf0","title":"优点","children":[{"id":"6d290fc219e7","title":"不用重新初始化对象，而是动态获得对象运行时的状态","children":[],"parent":"2088535ecdf0"},{"id":"3b0e276e8323","title":"在初始化信息不发生变化的情况下，既隐藏了对象创建的细节，又对性能大大提高","children":[],"parent":"2088535ecdf0"}],"parent":"d6e8bf4b1729"}],"parent":"872d5d5d7a30"},{"id":"a3522634a761","title":"单例模式：保证一个类仅有一个实例，并提供一个访问它的去哪聚访问点","children":[{"id":"b17c31309dea","title":"优点","children":[{"id":"1bf47bbbbc54","title":"严格控制客户端怎样访问以及何时访问它，即对唯一实例的受控访问","children":[],"parent":"b17c31309dea"}],"parent":"a3522634a761"}],"parent":"872d5d5d7a30"}],"parent":"root"},{"id":"94efad923c1d","title":"行为型模式","lineStyle":{"randomLineColor":"#80BA4C"},"children":[{"id":"7160d4e823e0","title":"命令模式：将请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志以及支持可撤销操作","children":[{"id":"5349872efef5","title":"优点","children":[{"id":"8894d610768e","title":"较容易的设计一个命令队列","children":[],"parent":"5349872efef5"},{"id":"dbedbcb88e0d","title":"在需要的情况下，较容易的将命令记入日志","children":[],"parent":"5349872efef5"},{"id":"a586e8860df2","title":"允许接受请求的一方决定是否要否决请求","children":[],"parent":"5349872efef5"},{"id":"c634008889a0","title":"容易实现对请求的撤销和重做","children":[],"parent":"5349872efef5"},{"id":"74050053b3f5","title":"添加新的命令很容易","children":[],"parent":"5349872efef5"},{"id":"bd0a1e3a49c4","title":"将请求一个操作的对象与知道怎么执行一个操作的对象分割开","children":[],"parent":"5349872efef5"}],"parent":"7160d4e823e0"}],"parent":"94efad923c1d"},{"id":"b5e219ae09c6","title":"职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将该对象连成一条链，并沿该链传递请求直到有一个对象处理它为止","children":[{"id":"0ab762135271","title":"优点","children":[{"id":"891e49534714","title":"接收者和发送这都不知道对方的明确信息，且链中的对象也并不知道链的结构，它们仅需保持后继者的引用","children":[],"parent":"0ab762135271"}],"parent":"b5e219ae09c6"}],"parent":"94efad923c1d"},{"id":"31fe793ca55c","title":"模板方法模式：定义一个操纵中的算法的骨架，而将这一些步骤延迟到子类中，使子类可以不改变一个算法的接口即可重定义该算法的某些特定步骤","children":[{"id":"819aba9493ac","title":"优点","children":[{"id":"6e6fb1ae591e","title":"把不变的行为移动到父类，去除子类中重复的代码","children":[],"parent":"819aba9493ac"}],"parent":"31fe793ca55c"}],"parent":"94efad923c1d"},{"id":"de8246295333","title":"观察者模式：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个对象，该对象在状态发生变化时会通知所有观察者对象，使其能自动更新自己","children":[{"id":"4e6d9ca91134","title":"使用情景","children":[{"id":"3c2fdf0de50d","title":"当一个对象的改变需要同时改变其他对象，且不知道具体有多少对象有待改变","children":[],"parent":"4e6d9ca91134"}],"parent":"de8246295333"},{"id":"13d7a6d38c8b","title":"不足","children":[{"id":"bb2bdfa27f62","title":"当接口不能统一，或者没有观察者这样的接口就无法使用该模式","children":[],"parent":"13d7a6d38c8b"}],"parent":"de8246295333"}],"parent":"94efad923c1d"},{"id":"13bf371a9488","title":"状态模式：当一个对象的内在状态改变时允许其改变其行为，该对象像是改变了其类","children":[{"id":"0dd1232ce020","title":"优点","children":[{"id":"e08ca4bef620","title":"将特定状态相关的行为放入一个对象中，并将不同状态的行为分割开","children":[],"parent":"0dd1232ce020"},{"id":"4a28d93f790e","title":"消除庞大的条件分支语句，减少相互间的依赖","children":[],"parent":"0dd1232ce020"}],"parent":"13bf371a9488"},{"id":"4c61bb632d95","title":"使用情景","children":[{"id":"5ee687b35fa1","title":"一个对象的行为取决于它的状态并且必须在运行时根据状态改变行为","children":[],"parent":"4c61bb632d95"}],"parent":"13bf371a9488"}],"parent":"94efad923c1d"},{"id":"340bc5a158a4","title":"策略模式：定义一系列算法的方法，这些算法完成相同的工作，只是实现不同，可以使用相同的方式调用所有方法，减少了各种算法类与使用算法类之间的耦合","children":[{"id":"8b9eb9ab8ab1","title":"优点","children":[{"id":"60b0b53ff119","title":"以相同方式调用所有做相同工作的算法，减少各种算法类和使用算法类之间的耦合","children":[],"parent":"8b9eb9ab8ab1"},{"id":"81f074e40711","title":"策略类层次为上下文定义了一系列可供重用的算法或行为，继承有助于析取算法中的公共功能","children":[],"parent":"8b9eb9ab8ab1"},{"id":"7ca9ad2c86d9","title":"简化了单元测试，每个算法都有自己的类，可以通过接口单独测试","children":[],"parent":"8b9eb9ab8ab1"}],"parent":"340bc5a158a4"},{"id":"6182c0abe807","title":"使用情景","children":[{"id":"50b40c52f89a","title":"需要在不同时间应用不同的业务规则","children":[],"parent":"6182c0abe807"}],"parent":"340bc5a158a4"}],"parent":"94efad923c1d"},{"id":"b76996264477","title":"备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象外保存该状态，以后就可以将对象恢复到原先保存的状态","children":[{"id":"a6d7015ccfc3","title":"优点","children":[{"id":"2399490e8ae1","title":"将保存的细节封装给备忘录，当要更改或保存细节时不需要影响客户端","children":[],"parent":"a6d7015ccfc3"}],"parent":"b76996264477"},{"id":"6d5728510de9","title":"使用情景","children":[{"id":"8b58e7b94afe","title":"适用于功能比较复杂，但需要维护或记录属性历史","children":[],"parent":"6d5728510de9"},{"id":"23c43f57f1fb","title":"需要保存的属性只是众多属性中的一小部分","children":[],"parent":"6d5728510de9"}],"parent":"b76996264477"}],"parent":"94efad923c1d"},{"id":"fd23df88528b","title":"迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示","children":[{"id":"317ad3863ea7","title":"使用情景","children":[{"id":"955cfacb0e04","title":"当需要访问一个聚集对象，且不管对象是什么都需要遍历时","children":[],"parent":"317ad3863ea7"}],"parent":"fd23df88528b"},{"id":"dabed1521a24","title":"优点","children":[{"id":"9ecf94f3b04d","title":"不暴露集合内部结构，又可让外部代码透明的访问集合内部的数据","children":[],"parent":"dabed1521a24"}],"parent":"fd23df88528b"}],"parent":"94efad923c1d"},{"id":"e160f355657a","title":"中介者模式：对一个中介对象来防撞一系列的度夏宁交互，中介者使各对象不需要显式的互相引用，从而耦合松散，而且可以独立改变它们之间的交互","children":[{"id":"6f9695182712","title":"使用情景","children":[{"id":"d67dab378e00","title":"一组对象以定义良好但复杂的方式进行同性的场合","children":[],"parent":"6f9695182712"},{"id":"b7fbbfb6cd08","title":"定制一个分布在多个类中的行为，而又不想生成太多的子类","children":[],"parent":"6f9695182712"}],"parent":"e160f355657a"},{"id":"6e2954558d58","title":"优点","children":[{"id":"68afea0263d7","title":"减少了各个类的耦合，可以独立的更改和复用各个类","children":[],"parent":"6e2954558d58"},{"id":"bf588eb07c17","title":"由于把对象如何协作进行了抽象，将终结作为一个独立概念并将其封装在一个对象中，关注的对象就从对象本身的行为转移到行为的交互上，即在更宏观的角度看待系统","children":[],"parent":"6e2954558d58"}],"parent":"e160f355657a"},{"id":"da55e373fbb0","title":"缺点","children":[{"id":"dabb241d5415","title":"将交互复杂性变为中介者的复杂性，使得中介者会变得比任何一个类都复杂","children":[],"parent":"da55e373fbb0"}],"parent":"e160f355657a"}],"parent":"94efad923c1d"},{"id":"8a0bf442456c","title":"解释器模式：给定一个语言，定义它的文法的表示，并定义一个解释器，该解释器解释语言中的句子","children":[{"id":"813bb474851e","title":"优点","children":[{"id":"ab7ad9923b79","title":"容易改变和扩展文法。该模式使用类标识文法规则，可以通过继承来进行扩展和更改","children":[],"parent":"813bb474851e"},{"id":"477ee603f9fc","title":"容易实现文法，定义在抽象语法树中各个节点的类的实现大体相似，易于直接编写","children":[],"parent":"813bb474851e"}],"parent":"8a0bf442456c"},{"id":"f78ee5f7fe69","title":"缺点","children":[{"id":"d48410f4bac5","title":"为文法中每一条规则至少定义了一个类，对包含许多规则的文法可能难以管理和维护","children":[],"parent":"f78ee5f7fe69"}],"parent":"8a0bf442456c"},{"id":"403fba9994c4","title":"使用情景","children":[{"id":"8239b6f65cfa","title":"当有一个语言需要解释执行，且可将该语言中的句子表示为一个抽象语法树时","children":[],"parent":"403fba9994c4"}],"parent":"8a0bf442456c"}],"parent":"94efad923c1d"},{"id":"d289f7ad4133","title":"访问者模式：表示一个作用于某对象结构中的各元素的操作，可使不改变元素的类的前提下定义作用于这些元素的新操作","children":[{"id":"aa8666d213a7","title":"使用情景","children":[{"id":"2b5ce072a38b","title":"系统有比较稳定的数据结构，又有易于变化的算法","children":[],"parent":"aa8666d213a7"}],"parent":"d289f7ad4133"},{"id":"c69f8df9b31b","title":"优点","children":[{"id":"44641df7bd77","title":"增加新的操作很容易，只需增加一个新的访问者","children":[],"parent":"c69f8df9b31b"}],"parent":"d289f7ad4133"},{"id":"113a01a1b607","title":"缺点","children":[{"id":"045a90c8ad23","title":"增加新的数据结构困难","children":[],"parent":"113a01a1b607"}],"parent":"d289f7ad4133"}],"parent":"94efad923c1d"}],"parent":"root"}],"title":"设计模式","watermark":"","root":true,"theme":"delicate_caihong","children":[{"id":"6ea915e2bb93","title":"面向对象设计原则","lineStyle":{"randomLineColor":"#3D5EC2"},"children":[{"id":"b4adb3c84a74","title":"开放封闭原则：软件实体（类、模块、函数等）应该可以扩展但不可修改","children":[],"parent":"6ea915e2bb93"},{"id":"07e455a558ba","title":"单一职责原则：就一个类而言应该仅有一个引起它变化的原因","children":[],"parent":"6ea915e2bb93"},{"id":"2320178ef7fb","title":"依赖倒转原则：抽象不应该依赖细节，细节应该依赖抽象","children":[],"parent":"6ea915e2bb93"},{"id":"c3498ee840fb","title":"里氏代换原则：一个软件实体若使用的是一个父类，则一定适用于子类","children":[],"parent":"6ea915e2bb93"},{"id":"667d59cbeb59","title":"迪米特法则：若两个类不必彼此通信，则不应当发生直接的相互作用","children":[],"parent":"6ea915e2bb93"},{"id":"1c1ad79f74eb","title":"合成/聚合复用原则：尽量使用合成/聚合，尽量不使用继承","children":[],"parent":"6ea915e2bb93"},{"id":"b0848da665d9","title":"接口分离原则：不能强迫用户去依赖他们不使用的接口","children":[],"parent":"6ea915e2bb93"}],"parent":"root"},{"id":"0a151f0440b5","title":"结构型模式","lineStyle":{"randomLineColor":"#0FBAB0"},"children":[{"id":"c957cfea44ca","title":"适配器模式：将一个类的接口转换成客户希望的另一个接口，使原本由于接口不兼容而不能一起工作的那些类可以一起工作","children":[{"id":"8275b55921d1","title":"使用情景","children":[{"id":"561b6c98d057","title":"使用一个已经存在的类，但它的接口和要求不同且行为一致时，且双方都不太容易更改","children":[],"parent":"8275b55921d1"}],"parent":"c957cfea44ca"},{"id":"afb16a8025ac","title":"优点","children":[{"id":"d5b48bec0b87","title":"客户代码可以统一调用统一接口，更简单、直接、紧凑","children":[],"parent":"afb16a8025ac"}],"parent":"c957cfea44ca"}],"parent":"0a151f0440b5"},{"id":"b5168904b1f0","title":"组合模式：将对象组合成树形结构以表示部分整体的层次结构，使得用户对单个和组合对象具有一致性","children":[{"id":"73aa1a86325a","title":"透明方式：在组件中声明所有管理子对象的方法","children":[],"parent":"b5168904b1f0"},{"id":"a61ca69e1d2d","title":"安全方式：在组件中不声明叶子节点中不使用的方法","children":[],"parent":"b5168904b1f0"},{"id":"c198ffcca5bb","title":"使用情景","children":[{"id":"38d48f2c0323","title":"需求是体现部分与整体层次的结构时，希望用户可以忽略组合对虾干与单个对象的不同，统一的使用组合结构中所有对象时","children":[],"parent":"c198ffcca5bb"}],"parent":"b5168904b1f0"},{"id":"093a0e075f3c","title":"优点","children":[{"id":"41140ae538dc","title":"组合模式定义了包含基本对象和组合对象的层次结构，基本对象可以被组合成更复杂的组合对象组合对象也能被组合，客户代码中任何用到基本对象的地方都可以使用组合对象。即一致的使用组合结构和单个对象","children":[],"parent":"093a0e075f3c"}],"parent":"b5168904b1f0"}],"parent":"0a151f0440b5"},{"id":"c381e31ddb57","title":"装饰模式：动态给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更灵活","children":[{"id":"62e91583f17c","title":"优点","children":[{"id":"448065804889","title":"每个装饰对象的实现和如何使用该对象分离开，只用关心自己的功能，不需要关心如何被添加到对象链当中","children":[],"parent":"62e91583f17c"}],"parent":"c381e31ddb57"},{"id":"14a939480936","title":"使用情景","children":[{"id":"ec4a29e97470","title":"当系统需要新功能，是向旧的勒种添加新代码，且通常装饰了原有类的核心职责或主要行为","children":[],"parent":"14a939480936"}],"parent":"c381e31ddb57"}],"parent":"0a151f0440b5"},{"id":"135172763eb1","title":"外观模式：为子系统中的一组接口提供一个一致的界面，其定义了高层接口使子系统更加容易使用","children":[{"id":"0630808291a8","title":"使用情景","children":[{"id":"3c0bb9f42d43","title":"初期有意识将两个不同层分离，层与层之间建立外观类","children":[],"parent":"0630808291a8"},{"id":"a32244fea413","title":"，开发阶段子系统往往因为不断重构演化变的复杂，添加外观可以减少依赖","children":[],"parent":"0630808291a8"},{"id":"d07d4afa0cfe","title":"维护遗留系统，系统难以维护和扩展，为新系统开发一个外观类，提供设计粗糙或高度复杂的遗留代码的比较简单的接口，让新系统与外观对象交互，外观类与遗留代码交互","children":[],"parent":"0630808291a8"}],"parent":"135172763eb1"}],"parent":"0a151f0440b5"},{"id":"85874f9980cc","title":"享元模式：运用共享技术有效支持大量细粒度对象","children":[{"id":"b667988148d1","title":"优点","children":[{"id":"202804d10d03","title":"避免大量非常相似类的开销","children":[],"parent":"b667988148d1"}],"parent":"85874f9980cc"},{"id":"6df35b4f4492","title":"使用情景","children":[{"id":"9bfaf34d3b7d","title":"一个应用程序使用了大量对象，且造成了很大的存储开销时","children":[],"parent":"6df35b4f4492"},{"id":"cc036d65e8f0","title":"对象的大多数状态可以为外部状态，若删除这些状态就可以用相对教授的共享对象取代多组对象","children":[],"parent":"6df35b4f4492"}],"parent":"85874f9980cc"}],"parent":"0a151f0440b5"},{"id":"fe1ac7057cea","title":"代理模式：为其他对象提供一种代理以控制这个对象的访问","children":[{"id":"71a3c3a4d65e","title":"使用情景","children":[{"id":"15a63be95d82","title":"远程代理：为一个对象在不同的地址空间提供局部代表，可以隐藏一个对象存在于不同地址空间的事实","children":[],"parent":"71a3c3a4d65e"},{"id":"893ca1e522c0","title":"虚拟代理：根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象","children":[],"parent":"71a3c3a4d65e"},{"id":"0ff455c622eb","title":"安全代理：控制真实对象访问时的权限","children":[],"parent":"71a3c3a4d65e"},{"id":"628e97dff9f7","title":"只能直营：调用真实对象时，代理处理另一些事情","children":[],"parent":"71a3c3a4d65e"}],"parent":"fe1ac7057cea"}],"parent":"0a151f0440b5"}],"parent":"root"}],"note":""}},"meta":{"id":"60ddbddef346fb04d2d3f584","member":"5ecd2453f346fb69071b5eaa","exportTime":"2021-07-10 19:09:32","diagramInfo":{"category":"mind_free","title":"思维导图","created":"2021-07-01 21:06:38","creator":"5ecd2453f346fb69071b5eaa","modified":"2021-07-10 16:31:56"},"type":"ProcessOn Schema File","version":"1.0"}}